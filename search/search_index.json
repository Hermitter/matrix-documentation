{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"MATRIX Ecosystem Overview (COMPILE OKAY TRA-TRA-TRA) Objective: Hardware shouldn't be hard The MATRIX Ecosystem was created to make powerful hardware projects very approachable for software developers. The pillars of MATRIX, computer vision, hardware interfaces, distributed internet communication, and data-driven end-user clients, are all programming disciplines which require years for an individual to master, or for a team to build a solution around. Programming Layers The MATRIX platform adds powerful capabilities to your Raspberry Pi, depending on your background and the kind of application you want to write, you may need to decide on which layer best fits your need. The documentation is organized according to these layers: MATRIX Open System (MOS) Language: Javascript Highest level of abstraction integrating with MATRIX hardware via MATRIX CORE . This layer requires an online connection and offers an integrated IoT environment that's easy to use. Remote App Deployment Mobile Interface Online Dashboard App Store \u26a0\ufe0f CURRENTLY UNDER MAINTENANCE \u26a0\ufe0f Read more about MATRIX OS MATRIX CORE Languages: Over 40 (Examples in Javascript Python) Abstraction layer for MATRIX HAL . Hosts a ZeroMQ + Protobuf communication layer which makes device information accessible via high-level interfaces. Supports 40+ different languages through Protocol Buffers: C++, Python, Ruby, PHP, Java, etc. Read more about MATRIX CORE MATRIX HAL Language: C++ Interacts with the kernel modules by using C++ drivers, enabling it to access available sensors and components on your device. Read more about MATRIX HAL Devices Each programming layer in the MATRIX platform is compatible with each MATRIX product, excluding specific components on the boards. MATRIX Creator A fully-featured development board for the Raspberry Pi with various sensors and communication protocols such as a 3D Gyroscope, Accelerometer, an 8 Microphone Array, zigbee, Z-Wave, and more! Read more about the MATRIX Creator MATRIX Voice A voice and audio focused development board with an 8 microphone array that enables you to create your own audio driven applications or use voice assistants such as Amazon Alexa , Google Assistant , PocketSphinx, etc. Read more about the MATRIX Voice Support Post questions or comments on community.matrix.one Alert issues on our GitHub under the corresponding repository Submit documentation issues or improvements to the MATRIX Documentation Repository","title":"Overview"},{"location":"#matrix-ecosystem-overview-compile-okay-tra-tra-tra","text":"","title":"MATRIX Ecosystem Overview (COMPILE OKAY TRA-TRA-TRA)"},{"location":"#programming-layers","text":"The MATRIX platform adds powerful capabilities to your Raspberry Pi, depending on your background and the kind of application you want to write, you may need to decide on which layer best fits your need. The documentation is organized according to these layers:","title":"Programming Layers"},{"location":"#devices","text":"Each programming layer in the MATRIX platform is compatible with each MATRIX product, excluding specific components on the boards.","title":"Devices"},{"location":"#support","text":"Post questions or comments on community.matrix.one Alert issues on our GitHub under the corresponding repository Submit documentation issues or improvements to the MATRIX Documentation Repository","title":"Support"},{"location":"dictionary/","text":"Glossary The dictionary will describe all components of the system. MATRIX Open Source (MATRIX OS) Top-level application layer which integrates into the MATRIX Creator hardware, and Raspberry Pi. MATRIX Command Line Interface (MATRIX CLI) Command Line Interface that integrates into the top-level MATRIX OS. Built to allow quick application development and application management on the Raspberry Pi. CORE C++ abstraction layer for HAL. Hosts the ZeroMQ communication layer which makes the sensors accessible via high-level interfaces. CORE Eye C++ Computer Vision Framework. Hardware Abstraction Layer (HAL) C++ drivers for sensors and available components. Applications An application is a service running inside of a container on a physical or simulated instance of a device. Driven by MATRIX OS. Devices A device is a physical or simulated instance of the hardware. Determined by the MATRIX OS. Cross-Talk Event-based triggers that can occur across applications, and/or devices.","title":"Dictionary"},{"location":"dictionary/#glossary","text":"The dictionary will describe all components of the system.","title":"Glossary"},{"location":"dictionary/#matrix-open-source-matrix-os","text":"Top-level application layer which integrates into the MATRIX Creator hardware, and Raspberry Pi.","title":"MATRIX Open Source (MATRIX OS)"},{"location":"dictionary/#matrix-command-line-interface-matrix-cli","text":"Command Line Interface that integrates into the top-level MATRIX OS. Built to allow quick application development and application management on the Raspberry Pi.","title":"MATRIX Command Line Interface (MATRIX CLI)"},{"location":"dictionary/#core","text":"C++ abstraction layer for HAL. Hosts the ZeroMQ communication layer which makes the sensors accessible via high-level interfaces.","title":"CORE"},{"location":"dictionary/#core-eye","text":"C++ Computer Vision Framework.","title":"CORE Eye"},{"location":"dictionary/#hardware-abstraction-layer-hal","text":"C++ drivers for sensors and available components.","title":"Hardware Abstraction Layer (HAL)"},{"location":"dictionary/#applications","text":"An application is a service running inside of a container on a physical or simulated instance of a device. Driven by MATRIX OS.","title":"Applications"},{"location":"dictionary/#devices","text":"A device is a physical or simulated instance of the hardware. Determined by the MATRIX OS.","title":"Devices"},{"location":"dictionary/#cross-talk","text":"Event-based triggers that can occur across applications, and/or devices.","title":"Cross-Talk"},{"location":"help/","text":"Support Post questions or comments on community.matrix.one Alert issues on our GitHub under the corresponding repository Submit documentation issues or improvements to the MATRIX Documentation Repository","title":"Support"},{"location":"help/#support","text":"Post questions or comments on community.matrix.one Alert issues on our GitHub under the corresponding repository Submit documentation issues or improvements to the MATRIX Documentation Repository","title":"Support"},{"location":"upgrades/","text":"Support Post questions or comments on community.matrix.one Post package issues on github under matrix-io Submit documentation issues or improvements at matrix-io/matrix-documentation Upgrade Because we are currently in Alpha stage, we are constantly updating and releasing new versions of our debian packages. To keep up to date, please regularly run: MATRIX Creator Packages sudo apt-get update sudo apt-get upgrade sudo shutdown -r now //sudo reboot MATRIX OS Bypass Automatic Upgrades The MATRIX OS upgrades packages, and systems, automagically on initialization. If you would like to bypass this, set the NO_UPGRADE environment flag to true. NO_UPGRADE=true node index.js Manual Upgrades On your Raspberry Pi, execute the following commands to make sure your hardware is up to date manually. cd matrix-os git checkout master git pull npm install npm upgrade matrix-app-config-helper matrix-firebase matrix-node-sdk matrix-eventfilter git submodule update --init MATRIX CLI On your PC, Linux, or Mac computer, you can update your Command Line Tools by just making sure you have installed the latest. sudo npm install matrix-cli -g","title":"Upgrades"},{"location":"upgrades/#support","text":"Post questions or comments on community.matrix.one Post package issues on github under matrix-io Submit documentation issues or improvements at matrix-io/matrix-documentation","title":"Support"},{"location":"upgrades/#upgrade","text":"Because we are currently in Alpha stage, we are constantly updating and releasing new versions of our debian packages. To keep up to date, please regularly run:","title":"Upgrade"},{"location":"upgrades/#matrix-creator-packages","text":"sudo apt-get update sudo apt-get upgrade sudo shutdown -r now //sudo reboot","title":"MATRIX Creator Packages"},{"location":"upgrades/#matrix-os","text":"","title":"MATRIX OS"},{"location":"upgrades/#bypass-automatic-upgrades","text":"The MATRIX OS upgrades packages, and systems, automagically on initialization. If you would like to bypass this, set the NO_UPGRADE environment flag to true. NO_UPGRADE=true node index.js","title":"Bypass Automatic Upgrades"},{"location":"upgrades/#manual-upgrades","text":"On your Raspberry Pi, execute the following commands to make sure your hardware is up to date manually. cd matrix-os git checkout master git pull npm install npm upgrade matrix-app-config-helper matrix-firebase matrix-node-sdk matrix-eventfilter git submodule update --init","title":"Manual Upgrades"},{"location":"upgrades/#matrix-cli","text":"On your PC, Linux, or Mac computer, you can update your Command Line Tools by just making sure you have installed the latest. sudo npm install matrix-cli -g","title":"MATRIX CLI"},{"location":"matrix-core/overview/","text":"MATRIX CORE Previously known as MATRIX MALOS. MATRIX CORE is an abstraction layer for MATRIX HAL and the foundation for MATRIX OS . This layer uses Protocol Buffers ZeroMQ to communicate with your MATRIX device. Applications for your MATRIX device can be programmed with any language that supports these tools. Getting Started Learn how to install MATRIX CORE and gain a deeper understanding of how this layer interacts with your MATRIX device. Setup tutorials and hello world examples for Javascript, Python, and Golang are available here. Driver Protocols See the available drivers you can interact with and the protocols they require for communicating with your application. Library Examples Javascript Python Troubleshooting Look at common debugging solutions for any issues you encounter.","title":"Overview"},{"location":"matrix-core/overview/#getting-started","text":"Learn how to install MATRIX CORE and gain a deeper understanding of how this layer interacts with your MATRIX device. Setup tutorials and hello world examples for Javascript, Python, and Golang are available here.","title":"Getting Started"},{"location":"matrix-core/overview/#driver-protocols","text":"See the available drivers you can interact with and the protocols they require for communicating with your application.","title":"Driver Protocols"},{"location":"matrix-core/overview/#library-examples","text":"","title":"Library Examples"},{"location":"matrix-core/overview/#troubleshooting","text":"Look at common debugging solutions for any issues you encounter.","title":"Troubleshooting"},{"location":"matrix-core/troubleshooting/","text":"Community Please visit our community support forums at community.matrix.one Check Active MATRIX CORE Services Run the following command on your Raspberry Pi's terminal to see the MATRIX Services currently running. ps aux | grep 'malos' Reinstall MATRIX CORE If you experience strange behavior, reinstall MATRIX CORE. Uninstall the matrixio-malos package. sudo apt-get --purge remove matrixio-malos Reboot your device. sudo reboot Install MATRIX CORE here . Audio Open Error If you encounter the error log below, your microphones are being used by the Pocketsphinx service for the Wakeword Driver . arecord: main:788: audio open error: Device or resource busy You can solve this by running the following command to kill the service. sudo pkill malos_wakeword","title":"Troubleshooting"},{"location":"matrix-core/troubleshooting/#community","text":"Please visit our community support forums at community.matrix.one","title":"Community"},{"location":"matrix-core/troubleshooting/#check-active-matrix-core-services","text":"Run the following command on your Raspberry Pi's terminal to see the MATRIX Services currently running. ps aux | grep 'malos'","title":"Check Active MATRIX CORE Services"},{"location":"matrix-core/troubleshooting/#reinstall-matrix-core","text":"If you experience strange behavior, reinstall MATRIX CORE. Uninstall the matrixio-malos package. sudo apt-get --purge remove matrixio-malos Reboot your device. sudo reboot Install MATRIX CORE here .","title":"Reinstall MATRIX CORE"},{"location":"matrix-core/troubleshooting/#audio-open-error","text":"If you encounter the error log below, your microphones are being used by the Pocketsphinx service for the Wakeword Driver . arecord: main:788: audio open error: Device or resource busy You can solve this by running the following command to kill the service. sudo pkill malos_wakeword","title":"Audio Open Error"},{"location":"matrix-core/getting-started/","text":"Getting Started Installation Learn how to install MATRIX CORE on your MATRIX Device. Understanding CORE Understand how MATRIX CORE uses ZeroMQ to communicate with Protocol Buffers. Programming Languages Javascript Setup Use Javascript to program with MATRIX CORE. Python Setup Use Python to program with MATRIX CORE. Golang Setup Use Golang to program with MATRIX CORE.","title":"Index"},{"location":"matrix-core/getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"matrix-core/getting-started/#programming-languages","text":"","title":"Programming Languages"},{"location":"matrix-core/getting-started/core-installation/","text":"Installing MATRIX CORE Make sure you have setup your MATRIX Creator or MATRIX Voice before continuing. Installation Before starting, ensure you have access to the terminal of your Raspberry Pi via an SSH-session or a connected screen, mouse, and keyboard. Then insert and run the following commands into your Raspberry Pi's terminal, one at a time. Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the the MATRIX CORE packages. sudo apt-get install matrixio-malos Reboot your device. sudo reboot MATRIX CORE will now be running as a service each time your Raspberry Pi boots up. These remaining commands will install ZeroMQ . echo deb http://download.opensuse.org/repositories/network:/messaging:/zeromq:/release-stable/Debian_9.0/ ./ | sudo tee /etc/apt/sources.list.d/zeromq.list wget https://download.opensuse.org/repositories/network:/messaging:/zeromq:/release-stable/Debian_9.0/Release.key -O- | sudo apt-key add Next Steps Now that you have MATRIX CORE and ZeroMQ installed, please take a look at Understanding CORE here . If you're already familiar, you can learn how to setup a programming language for communicating with CORE. We currently have tutorials for the following languages: Javascript Python Golang Helpful Information Upgrading If you need to upgrade your MATRIX CORE package at any time, please run the following commands on your Raspberry Pi. sudo apt-get update sudo apt-get upgrade A reboot will be required after upgrading your packages. sudo reboot Stopping & Starting If you need to manually stop MATRIX CORE use: sudo pkill -9 malos If you need to manually start MATRIX CORE again use: malos","title":"Installation"},{"location":"matrix-core/getting-started/core-installation/#installation","text":"Before starting, ensure you have access to the terminal of your Raspberry Pi via an SSH-session or a connected screen, mouse, and keyboard. Then insert and run the following commands into your Raspberry Pi's terminal, one at a time. Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the the MATRIX CORE packages. sudo apt-get install matrixio-malos Reboot your device. sudo reboot MATRIX CORE will now be running as a service each time your Raspberry Pi boots up. These remaining commands will install ZeroMQ . echo deb http://download.opensuse.org/repositories/network:/messaging:/zeromq:/release-stable/Debian_9.0/ ./ | sudo tee /etc/apt/sources.list.d/zeromq.list wget https://download.opensuse.org/repositories/network:/messaging:/zeromq:/release-stable/Debian_9.0/Release.key -O- | sudo apt-key add","title":"Installation"},{"location":"matrix-core/getting-started/core-installation/#next-steps","text":"Now that you have MATRIX CORE and ZeroMQ installed, please take a look at Understanding CORE here . If you're already familiar, you can learn how to setup a programming language for communicating with CORE. We currently have tutorials for the following languages: Javascript Python Golang","title":"Next Steps"},{"location":"matrix-core/getting-started/core-installation/#helpful-information","text":"","title":"Helpful Information"},{"location":"matrix-core/getting-started/golang-installation/","text":"Ensure you have MATRIX CORE installed, before moving on. Installing Golang This setup will go through how to install Golang and the dependencies needed to create a Go application that can communicate with MATRIX CORE. Run the following on your Raspberry Pi. Before downloading Go, you'll need to make sure you have git installed. sudo apt-get install git Download and install Go v1.11.2 . wget https://dl.google.com/go/go1.11.2.linux-armv6l.tar.gz sudo tar -C /usr/local -xvzf go1.11.2.linux-armv6l.tar.gz rm go1.11.2.linux-armv6l.tar.gz Setup the GOPATH directory and environment variables. mkdir -p ~/go/{bin,src,pkg} echo -e \\n##Golang Environment Variables## | sudo tee -a /etc/profile echo 'export PATH=$PATH:/usr/local/go/bin' | sudo tee -a /etc/profile echo 'export GOPATH=$HOME/go' | sudo tee -a /etc/profile echo 'export PATH=$PATH:$GOPATH/bin' | sudo tee -a /etc/profile source /etc/profile Make sure Go is properly installed. The command below should output go version go1.11 linux/arm . go version Installing ZMQ Dependency Although ZMQ has already been installed, Go requires an extra dependency. sudo apt-get install libsodium-dev Creating A Go Application Making Your Project Directory Use the following commands to initialize a Go project folder, in the home directory ~/ of your MATRIX device. cd ~/ mkdir go-matrix-core-app cd go-matrix-core-app go mod init go-matrix-core-app Installing Go Packages for ZMQ and Protocol Buffers While inside your project folder, use the commands below to install the required dependencies for interacting with MATRIX CORE. go get github.com/pebbe/zmq4 go get github.com/matrix-io/matrix-protos-go Check If Everything Works Creating main.go To ensure your installation has succeeded, create a file named main.go and paste the code below. package main import ( fmt math/rand time github.com/golang/protobuf/proto core github.com/matrix-io/matrix-protos-go/matrix_io/malos/v1 zmq github.com/pebbe/zmq4 ) // Global Vars var portStatus = make(chan string, 4) // Channel To Ensure Port Goroutines Are Called var everloop = core.EverloopImage{} // State Of All MATRIX LEDs func main() { fmt.Println( Starting MATRIX CORE Everloop ) // Asynchronously Start MATRIX CORE Ports go keepAlivePort() // Ping Once go errorPort() // Report Any Errors go dataUpdatePort() // Receive # Of Leds Starts basePort() // Wait For Each Port Connection (ensures each goroutine is able to run) for portStatus := range portStatus { fmt.Println( received , portStatus) } } // BASE PORT \\\\ (port where configurations are sent) func basePort() { // Connect ZMQ Socket To MATRIX CORE pusher, _ := zmq.NewSocket(zmq.PUSH) // Create A Pusher Socket pusher.Connect( tcp://127.0.0.1:20021 ) // Connect Pusher To Base Port // Notify That Port Is Ready portStatus - Base Port: CONNECTED // Keep Sending Everloop Image for { // Create (x) Amount Of Randomly Colored LEDs for i := int32(0); i everloop.EverloopLength; i++ { led := core.LedValue{ Red: (uint32)(rand.Int31n(200) + 1), Green: (uint32)(rand.Int31n(255) + 1), Blue: (uint32)(rand.Int31n(50) + 1), White: 0, } // Add New LED to Everloop LED Array everloop.Led = append(everloop.Led, led) } // Create Everloop Driver Configuration Protocol configuration := core.DriverConfig{ Image: everloop, } //Encode Protocol Buffer var encodedConfiguration, _ = proto.Marshal( configuration) // Send Protocol Buffer pusher.Send(string((encodedConfiguration)), 1) // Reset Everloop Array everloop.Led = []*core.LedValue{} // Loop delay time.Sleep(50 * time.Millisecond) } } // KEEP-ALIVE PORT \\\\ (port where pings are sent) func keepAlivePort() { // Connect ZMQ Socket To MATRIX CORE pusher, _ := zmq.NewSocket(zmq.PUSH) // Create A Pusher Socket pusher.Connect( tcp://127.0.0.1:20022 ) // Connect Pusher To Keep-Alive Port // Notify That Port Is Ready portStatus - Keep-Alive Port: CONNECTED // Send Keep Alive Message pusher.Send( , 1) } // ERROR PORT \\\\ (port where errors are received) func errorPort() { // Connect ZMQ Socket To MATRIX CORE subscriber, _ := zmq.NewSocket(zmq.SUB) // Create A Subscriber Socket subscriber.Connect( tcp://127.0.0.1:20023 ) // Connect Subscriber To Data Update Port subscriber.SetSubscribe( ) // Subscribe To Error Port Messages // Notify That Port Is Ready portStatus - Error Port: CONNECTED // Wait For Error for { // On Error message, _ := subscriber.Recv(2) // Print Error fmt.Println( ERROR: , message) } } // DATA UPDATE PORT \\\\ (port where updates are received) func dataUpdatePort() { // Connect ZMQ Socket To MATRIX CORE subscriber, _ := zmq.NewSocket(zmq.SUB) // Create A Subscriber Socket subscriber.Connect( tcp://127.0.0.1:20024 ) // Connect Subscriber To Data Update Port subscriber.SetSubscribe( ) // Subscribe To Data Update Port Messages // Notify That Port Is Ready portStatus - Data Update Port: CONNECTED // Wait For Data for { // On Data message, _ := subscriber.Recv(2) // Decode Protocol Buffer Update everloop Struct LED Count proto.Unmarshal([]byte(message), everloop) // Print Data fmt.Print( \\nEverloop Length: , everloop.EverloopLength, \\n\\n ) // Start Base Port go basePort() // Send Configuration Message // Close Data Update Port return } } Running main.go Once you have main.go ready, use the following command to run a simple hello world app. go run main.go Result Next Steps Now that everything is properly installed, learn more about the Everloop and other Driver Protocols MATRIX Core has to offer. Go examples coming soon!","title":"Golang Setup"},{"location":"matrix-core/getting-started/golang-installation/#installing-golang","text":"This setup will go through how to install Golang and the dependencies needed to create a Go application that can communicate with MATRIX CORE. Run the following on your Raspberry Pi. Before downloading Go, you'll need to make sure you have git installed. sudo apt-get install git Download and install Go v1.11.2 . wget https://dl.google.com/go/go1.11.2.linux-armv6l.tar.gz sudo tar -C /usr/local -xvzf go1.11.2.linux-armv6l.tar.gz rm go1.11.2.linux-armv6l.tar.gz Setup the GOPATH directory and environment variables. mkdir -p ~/go/{bin,src,pkg} echo -e \\n##Golang Environment Variables## | sudo tee -a /etc/profile echo 'export PATH=$PATH:/usr/local/go/bin' | sudo tee -a /etc/profile echo 'export GOPATH=$HOME/go' | sudo tee -a /etc/profile echo 'export PATH=$PATH:$GOPATH/bin' | sudo tee -a /etc/profile source /etc/profile Make sure Go is properly installed. The command below should output go version go1.11 linux/arm . go version","title":"Installing Golang"},{"location":"matrix-core/getting-started/golang-installation/#installing-zmq-dependency","text":"Although ZMQ has already been installed, Go requires an extra dependency. sudo apt-get install libsodium-dev","title":"Installing ZMQ Dependency"},{"location":"matrix-core/getting-started/golang-installation/#creating-a-go-application","text":"","title":"Creating A Go Application"},{"location":"matrix-core/getting-started/golang-installation/#check-if-everything-works","text":"","title":"Check If Everything Works"},{"location":"matrix-core/getting-started/golang-installation/#next-steps","text":"Now that everything is properly installed, learn more about the Everloop and other Driver Protocols MATRIX Core has to offer. Go examples coming soon!","title":"Next Steps"},{"location":"matrix-core/getting-started/javascript-installation/","text":"Ensure you have MATRIX CORE installed, before moving on. Installing Node.js This setup will go through how to install Node.js and the dependencies needed to create a Node application that can communicate with MATRIX CORE. Run the following commands on your MATRIX device(Raspberry Pi) to install Node Version Manager which will then be used to install version 8.6 of Node.js. It is strongly recommended to use version 8.6 of Node.js curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash . ~/.bashrc nvm install 8.6 Creating A Node.js Application Making Your Project Directory Use the following commands to initialize a Node project folder, in the home directory ~/ of your MATRIX device. cd ~/ mkdir js-matrix-core-app cd js-matrix-core-app npm init Installing npm Packages for ZMQ and Protocol Buffers While staying inside your app folder, use the commands below to install the ZMQ and MATRIX Protocol Buffers npm packages. This allows you to interact with MATRIX Core through Node.js. npm install zeromq --save npm install matrix-protos --save Check If Everything Works Creating app.js To ensure your installation has succeeded, create a file named app.js and paste the code below. // Set Initial Variables \\\\ var zmq = require('zeromq');// Asynchronous Messaging Framework var matrix_io = require('matrix-protos').matrix_io;// Protocol Buffers for MATRIX function var matrix_ip = '127.0.0.1';// Local IP var matrix_everloop_base_port = 20021// Port for Everloop driver var matrix_device_leds = 0;// Holds amount of LEDs on MATRIX device // ERROR PORT \\\\ var errorSocket = zmq.socket('sub');// Create a Subscriber socket errorSocket.connect('tcp://' + matrix_ip + ':' + (matrix_everloop_base_port + 2));// Connect Subscriber to Error port errorSocket.subscribe('');// Subscribe to messages // On Message errorSocket.on('message', (error_message) = { console.log('Error received: ' + error_message.toString('utf8'));// Log error }); // DATA UPDATE PORT \\\\ var updateSocket = zmq.socket('sub');// Create a Subscriber socket updateSocket.connect('tcp://' + matrix_ip + ':' + (matrix_everloop_base_port + 3));// Connect Subscriber to Data Update port updateSocket.subscribe('');// Subscribe to messages // On Message updateSocket.on('message', (buffer) = { var data = matrix_io.malos.v1.io.EverloopImage.decode(buffer);// Extract message matrix_device_leds = data.everloopLength;// Save MATRIX device LED count }); // KEEP-ALIVE PORT \\\\ var pingSocket = zmq.socket('push');// Create a Pusher socket pingSocket.connect('tcp://' + matrix_ip + ':' + (matrix_everloop_base_port + 1));// Connect Pusher to Keep-alive port pingSocket.send('');// Send a single ping // BASE PORT \\\\ var configSocket = zmq.socket('push');// Create a Pusher socket configSocket.connect('tcp://' + matrix_ip + ':' + matrix_everloop_base_port);// Connect Pusher to Base port // Create an empty Everloop image var image = matrix_io.malos.v1.io.EverloopImage.create(); // Loop every 50 milliseconds setInterval(function(){ // For each device LED for (var i = 0; i matrix_device_leds; ++i) { // Set individual LED value image.led[i] = { red: Math.floor(Math.random() * 200)+1, green: Math.floor(Math.random() * 255)+1, blue: Math.floor(Math.random() * 50)+1, white: 0 }; } // Store the Everloop image in MATRIX configuration var config = matrix_io.malos.v1.driver.DriverConfig.create({ 'image': image }); // Send MATRIX configuration to MATRIX device if(matrix_device_leds 0) configSocket.send(matrix_io.malos.v1.driver.DriverConfig.encode(config).finish()); },50); Running app.js Once you have the app.js code copied, use the following command to run a simple hello world app. node app.js Result Next Steps Now that everything is properly installed, learn more about the Everloop and other Driver Protocols MATRIX Core has to offer, or view the available Javascript examples .","title":"Javascript Setup"},{"location":"matrix-core/getting-started/javascript-installation/#installing-nodejs","text":"This setup will go through how to install Node.js and the dependencies needed to create a Node application that can communicate with MATRIX CORE. Run the following commands on your MATRIX device(Raspberry Pi) to install Node Version Manager which will then be used to install version 8.6 of Node.js. It is strongly recommended to use version 8.6 of Node.js curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.33.11/install.sh | bash . ~/.bashrc nvm install 8.6","title":"Installing Node.js"},{"location":"matrix-core/getting-started/javascript-installation/#creating-a-nodejs-application","text":"","title":"Creating A Node.js Application"},{"location":"matrix-core/getting-started/javascript-installation/#check-if-everything-works","text":"","title":"Check If Everything Works"},{"location":"matrix-core/getting-started/javascript-installation/#next-steps","text":"Now that everything is properly installed, learn more about the Everloop and other Driver Protocols MATRIX Core has to offer, or view the available Javascript examples .","title":"Next Steps"},{"location":"matrix-core/getting-started/python-installation/","text":"Ensure you have MATRIX CORE installed, before moving on. Creating A Python Project This setup will go through how to install all the necessary python packages needed to program with MATRIX CORE. First, use the commands below to create a folder, inside in the home directory ~/ of your MATRIX device(Raspberry Pi). This will be where you'll put your python scripts. cd ~/ mkdir python-matrix-core-app cd python-matrix-core-app Installing Python Packages While inside your project directory, use the following commands to install all the necessary Python packages needed to interact with MATRIX CORE. wget https://github.com/matrix-io/matrix-creator-malos/blob/master/src/python_test/Pipfile -O Pipfile wget https://github.com/matrix-io/matrix-creator-malos/blob/master/src/python_test/Pipfile.lock -O Pipfile.lock wget https://raw.githubusercontent.com/matrix-io/matrix-creator-malos/master/src/python_test/requirements.txt -O requirements.txt wget https://raw.githubusercontent.com/matrix-io/matrix-creator-malos/master/src/python_test/utils.py -O utils.py sudo apt-get install build-essential python-dev Python 2 Packages Required packages for Python 2 can be installed by using the following command. pip install -r requirements.txt Python 3 Packages Instead of pip, Python 3 packages will require pip3 which can be installed with the command below. sudo apt-get install python3-pip You can now install the required packages for Python 3. pip3 install -r requirements.txt Check If Everything Works Creating app.py To ensure your installation has succeeded, create a file named app.py and paste the code below. ## Set Initial Variables ## import os # Miscellaneous operating system interface import zmq # Asynchronous messaging framework import time # Time access and conversions from random import randint # Random numbers import sys # System-specific parameters and functions from matrix_io.proto.malos.v1 import driver_pb2 # MATRIX Protocol Buffer driver library from matrix_io.proto.malos.v1 import io_pb2 # MATRIX Protocol Buffer sensor library from multiprocessing import Process, Manager, Value # Allow for multiple processes at once from zmq.eventloop import ioloop, zmqstream# Asynchronous events through ZMQ matrix_ip = '127.0.0.1' # Local device ip everloop_port = 20021 # Driver Base port led_count = 0 # Amount of LEDs on MATRIX device # Handy function for connecting to the Error port from utils import register_error_callback ## BASE PORT ## def config_socket(ledCount): # Define zmq socket context = zmq.Context() # Create a Pusher socket socket = context.socket(zmq.PUSH) # Connect Pusher to configuration socket socket.connect('tcp://{0}:{1}'.format(matrix_ip, everloop_port)) # Loop forever while True: # Create a new driver config driver_config_proto = driver_pb2.DriverConfig() # Create an empty Everloop image image = [] # For each device LED for led in range(ledCount): # Set individual LED value ledValue = io_pb2.LedValue() ledValue.blue = randint(0, 50) ledValue.red = randint(0, 200) ledValue.green = randint(0, 255) ledValue.white = 0 image.append(ledValue) # Store the Everloop image in driver configuration driver_config_proto.image.led.extend(image) # Send driver configuration through ZMQ socket socket.send(driver_config_proto.SerializeToString()) #Wait before restarting loop time.sleep(0.05) ## KEEP ALIVE ## def ping_socket(): # Define zmq socket context = zmq.Context() # Create a Pusher socket ping_socket = context.socket(zmq.PUSH) # Connect to the socket ping_socket.connect('tcp://{0}:{1}'.format(matrix_ip, everloop_port+1)) # Ping with empty string to let the drive know we're still listening ping_socket.send_string('') ## ERROR PORT ## def everloop_error_callback(error): # Log error print('{0}'.format(error)) ## DATA UPDATE PORT ## def update_socket(): # Define zmq socket context = zmq.Context() # Create a Subscriber socket socket = context.socket(zmq.SUB) # Connect to the Data Update port socket.connect('tcp://{0}:{1}'.format(matrix_ip, everloop_port+3)) # Connect Subscriber to Error port socket.setsockopt(zmq.SUBSCRIBE, b'') # Create the stream to listen to data from port stream = zmqstream.ZMQStream(socket) # Function to update LED count and close connection to the Data Update Port def updateLedCount(data): # Extract data and pass into led_count global variable global led_count led_count = io_pb2.LedValue().FromString(data[0]).green # Log LEDs print('{0} LEDs counted'.format(led_count)) # If LED count obtained if led_count 0: # Close Data Update Port connection ioloop.IOLoop.instance().stop() print('LED count obtained. Disconnecting from data publisher {0}'.format(everloop_port+3)) # Call updateLedCount() once data is received stream.on_recv(updateLedCount) # Log and begin event loop for ZMQ connection to Data Update Port print('Connected to data publisher with port {0}'.format(everloop_port+3)) ioloop.IOLoop.instance().start() ## START PROCESSES ## if __name__ == '__main__': # Initiate asynchronous events ioloop.install() # Start Error Port connection Process(target=register_error_callback, args=(everloop_error_callback, matrix_ip, everloop_port)).start() # Ping the Keep-alive Port once ping_socket() # Start Data Update Port connection close after response update_socket() # Send Base Port configuration try: config_socket(led_count) # Avoid logging Everloop errors on user quiting except KeyboardInterrupt: print(' quit') Running app.py Once you have the app.py code copied, use one of the following commands to run a simple hello world app. Python 2 python app.py Python 3 python3 app.py Result Next Steps Now that everything is properly installed, learn more about the Everloop and other Driver Protocols MATRIX Core has to offer, or view the available Python examples .","title":"Python Setup"},{"location":"matrix-core/getting-started/python-installation/#creating-a-python-project","text":"This setup will go through how to install all the necessary python packages needed to program with MATRIX CORE. First, use the commands below to create a folder, inside in the home directory ~/ of your MATRIX device(Raspberry Pi). This will be where you'll put your python scripts. cd ~/ mkdir python-matrix-core-app cd python-matrix-core-app","title":"Creating A Python Project"},{"location":"matrix-core/getting-started/python-installation/#installing-python-packages","text":"While inside your project directory, use the following commands to install all the necessary Python packages needed to interact with MATRIX CORE. wget https://github.com/matrix-io/matrix-creator-malos/blob/master/src/python_test/Pipfile -O Pipfile wget https://github.com/matrix-io/matrix-creator-malos/blob/master/src/python_test/Pipfile.lock -O Pipfile.lock wget https://raw.githubusercontent.com/matrix-io/matrix-creator-malos/master/src/python_test/requirements.txt -O requirements.txt wget https://raw.githubusercontent.com/matrix-io/matrix-creator-malos/master/src/python_test/utils.py -O utils.py sudo apt-get install build-essential python-dev","title":"Installing Python Packages"},{"location":"matrix-core/getting-started/python-installation/#check-if-everything-works","text":"","title":"Check If Everything Works"},{"location":"matrix-core/getting-started/python-installation/#next-steps","text":"Now that everything is properly installed, learn more about the Everloop and other Driver Protocols MATRIX Core has to offer, or view the available Python examples .","title":"Next Steps"},{"location":"matrix-core/getting-started/understanding-core/","text":"Overview MATRIX CORE functions by sending and receiving Protocol Buffers over a ZeroMQ connection. This can be used to query sensors and control any MATRIX device from any language that supports Protocol Buffers (version 3.X) and ZeroMQ. This is the basis for how the MATRIX OS layer can communicate with your MATRIX device. Ports Protocol MATRIX CORE contains drivers (components sensors) that communicate with your MATRIX device. This occurs by having each driver send or receive Protocol Buffers over a ZeroMQ driver port. Depending on the driver port it may allow for read-only , write-only or read-write . Current Driver Base Ports: IMU - 20013 Humidity - 20017 Everloop - 20021 Pressure - 20025 UV - 20029 Servo - 20045 GPIO - 20049 Wakeword - 60001 Each driver reserves 4 ports beginning with their base port as shown above. The other 3 ports are in sequential order counting up from the base port . Below is an example of all IMU ports. Note, not all drivers utilize every port. All IMU Ports IMU Base Port - 20013 IMU Keep-Alive Port - 20014 IMU Error Port - 20015 IMU Data Update Port - 20016 The following list contains the port types currently defined in MATRIX CORE. Base Port The base port is used to configure a driver on your MATRIX device. This port is a ZeroMQ PULL port that accepts a configuration which is created as a protocol buffer. To send a configuration you need to create a valid message for each driver. For example, the UV driver uses a configuration message to set the refresh rate and timeout for sending UV data. Configuration messages are named DriverConfig . The file for where this is defined can be seen here . Below is an example for a UV configuration message: message DriverConfig { // Delay between updates. In seconds. float delay_between_updates = 1; // Timeout after last ping. float timeout_after_last_ping = 2; } Once the DriverConfig message is filled out, it needs to be serialized as a string and sent to the ZeroMQ configuration port. Keep-alive Port Port : base port + 1 The Keep-alive port is a ZeroMQ PULL port that is required for certain drivers to keep their function alive. Drivers that are pushing data need this in place to let it know if data will continue to be requested. For example, the Everloop driver doesn't require Keep-alive messages, but the Humidity driver does. Any message that is sent to the Keep-alive port will be discarded, so an empty string \"\" makes for a good Keep-alive message. Error Port Port : base port + 2 Programs can subscribe to this port to receive driver related errors. The Error port is a ZeroMQ PUSH port that will send you a string with any errors that it has encountered. Data Update Port Port : base port + 3 This ZeroMQ PUSH port is used by drivers that send data (Humidity, UV, etc.). Each driver uses a different message to report data to programs that subscribe for these updates. To demonstrate, the UV driver will be used as an example. You can find the file here . The message follows: // Basic UV radiation lecture. message UV{ // UV index float uv_index = 1; // OMS risk string oms_risk = 2; } Applications that subscribe to UV driver updates will receive a string with serialized messages of type UV. Once received, the message needs to be deserialized by the application for the values can be used. Next Steps We currently provide libraries and examples for the following languages: Javascript Python If you want to use another protocol buffer supported programming language then we suggest you view the Protocol Buffers Documentation for the language you want to use in MATRIX CORE. Remember to use ZeroMQ for sending these Protocol Buffers. You can view the protocols for each of our drivers here .","title":"Understanding CORE"},{"location":"matrix-core/getting-started/understanding-core/#overview","text":"MATRIX CORE functions by sending and receiving Protocol Buffers over a ZeroMQ connection. This can be used to query sensors and control any MATRIX device from any language that supports Protocol Buffers (version 3.X) and ZeroMQ. This is the basis for how the MATRIX OS layer can communicate with your MATRIX device.","title":"Overview"},{"location":"matrix-core/getting-started/understanding-core/#ports-protocol","text":"MATRIX CORE contains drivers (components sensors) that communicate with your MATRIX device. This occurs by having each driver send or receive Protocol Buffers over a ZeroMQ driver port. Depending on the driver port it may allow for read-only , write-only or read-write . Current Driver Base Ports: IMU - 20013 Humidity - 20017 Everloop - 20021 Pressure - 20025 UV - 20029 Servo - 20045 GPIO - 20049 Wakeword - 60001 Each driver reserves 4 ports beginning with their base port as shown above. The other 3 ports are in sequential order counting up from the base port . Below is an example of all IMU ports. Note, not all drivers utilize every port. All IMU Ports IMU Base Port - 20013 IMU Keep-Alive Port - 20014 IMU Error Port - 20015 IMU Data Update Port - 20016 The following list contains the port types currently defined in MATRIX CORE. Base Port The base port is used to configure a driver on your MATRIX device. This port is a ZeroMQ PULL port that accepts a configuration which is created as a protocol buffer. To send a configuration you need to create a valid message for each driver. For example, the UV driver uses a configuration message to set the refresh rate and timeout for sending UV data. Configuration messages are named DriverConfig . The file for where this is defined can be seen here . Below is an example for a UV configuration message: message DriverConfig { // Delay between updates. In seconds. float delay_between_updates = 1; // Timeout after last ping. float timeout_after_last_ping = 2; } Once the DriverConfig message is filled out, it needs to be serialized as a string and sent to the ZeroMQ configuration port. Keep-alive Port Port : base port + 1 The Keep-alive port is a ZeroMQ PULL port that is required for certain drivers to keep their function alive. Drivers that are pushing data need this in place to let it know if data will continue to be requested. For example, the Everloop driver doesn't require Keep-alive messages, but the Humidity driver does. Any message that is sent to the Keep-alive port will be discarded, so an empty string \"\" makes for a good Keep-alive message. Error Port Port : base port + 2 Programs can subscribe to this port to receive driver related errors. The Error port is a ZeroMQ PUSH port that will send you a string with any errors that it has encountered. Data Update Port Port : base port + 3 This ZeroMQ PUSH port is used by drivers that send data (Humidity, UV, etc.). Each driver uses a different message to report data to programs that subscribe for these updates. To demonstrate, the UV driver will be used as an example. You can find the file here . The message follows: // Basic UV radiation lecture. message UV{ // UV index float uv_index = 1; // OMS risk string oms_risk = 2; } Applications that subscribe to UV driver updates will receive a string with serialized messages of type UV. Once received, the message needs to be deserialized by the application for the values can be used.","title":"Ports &amp; Protocol"},{"location":"matrix-core/getting-started/understanding-core/#next-steps","text":"We currently provide libraries and examples for the following languages: Javascript Python If you want to use another protocol buffer supported programming language then we suggest you view the Protocol Buffers Documentation for the language you want to use in MATRIX CORE. Remember to use ZeroMQ for sending these Protocol Buffers. You can view the protocols for each of our drivers here .","title":"Next Steps"},{"location":"matrix-core/javascript-examples/","text":"Javascript Examples Everloop LED interface. Humidity Humidity and temperature measurement. IMU Inertial Measurement Unit. Pressure Pressure, altitude and temperature measurement. UV Ultraviolet light sensor. Servo Adjust servo positions. GPIO General Purpose Input/Output. Wakeword Create custom voice commands with Pocket Sphinx.","title":"Index"},{"location":"matrix-core/javascript-examples/#javascript-examples","text":"","title":"Javascript Examples"},{"location":"matrix-core/javascript-examples/everloop/","text":"Everloop Javascript Example Device Compatibility Overview The Everloop driver allows for: Reading amount of LEDs your MATRIX device has. Setting the RGBW colors for each individual LED. Available ZeroMQ Ports Base port : 20021 Keep-alive port : 20022 Error port : 20023 Data update port : 20024 Code Example The following sections show how to implement a connection to each of the Everloop driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the main logic for our Everloop example goes. Once we connect to the **Base Port**, the program will start an endless loop to create and send LED configurations with randomly generated RGBW values. However, before sending the LED configuration to you MATRIX device, it will wait until the amount of `matrix_device_leds` is defined. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message, an empty string, will grant us a response from the **Data Update Port** with the value we need for `matrix_device_leds`. \u0002wzxhzdk:2\u0003 Error Port Connecting to the **Error Port** is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. \u0002wzxhzdk:3\u0003 Data Update Port A connection to the **Data Update Port** will allow us to receive the LED count we want for the `matrix_device_leds` variable. Once that variable is set, the MATRIX device will begin reading the Everloop images being sent to the base port. \u0002wzxhzdk:4\u0003 Data Output The javascript object below is an example output you'll receive from the **Data Update Port**. \u0002wzxhzdk:5\u0003","title":"Everloop"},{"location":"matrix-core/javascript-examples/everloop/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/javascript-examples/everloop/#overview","text":"The Everloop driver allows for: Reading amount of LEDs your MATRIX device has. Setting the RGBW colors for each individual LED.","title":"Overview"},{"location":"matrix-core/javascript-examples/everloop/#code-example","text":"The following sections show how to implement a connection to each of the Everloop driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the main logic for our Everloop example goes. Once we connect to the **Base Port**, the program will start an endless loop to create and send LED configurations with randomly generated RGBW values. However, before sending the LED configuration to you MATRIX device, it will wait until the amount of `matrix_device_leds` is defined. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message, an empty string, will grant us a response from the **Data Update Port** with the value we need for `matrix_device_leds`. \u0002wzxhzdk:2\u0003 Error Port Connecting to the **Error Port** is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. \u0002wzxhzdk:3\u0003 Data Update Port A connection to the **Data Update Port** will allow us to receive the LED count we want for the `matrix_device_leds` variable. Once that variable is set, the MATRIX device will begin reading the Everloop images being sent to the base port. \u0002wzxhzdk:4\u0003","title":"Code Example"},{"location":"matrix-core/javascript-examples/gpio/","text":"General Purpose Input Output (GPIO) Javascript Example Device Compatibility Overview The GPIO driver supports: Reading pin input Setting pin output Device Pinouts : MATRIX Creator MATRIX Voice Available ZeroMQ Ports Base port : 20049 Keep-alive port : 20050 Error port : 20051 Data Update port : 20052 Code Example The following sections show how to implement a connection to each of the GPIO driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our GPIO example goes. Once we connect to the **Base Port**, we will pass a configuration to the GPIO driver. With this, we can set the update rate, timeout, and pin configuration. This example will use `pin: 0` and **toggle the pin state between on ** through a `toggle()` function. > Each `pin` will save its last set `value` until the next device boot. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message, an empty string, will grant us a response from the **Data Update Port** for the current GPIO pin values. An interval for pinging is then set to continuously obtain that data. The, previously defined, toggle function is also called to swap the pin state after a ping. \u0002wzxhzdk:2\u0003 Error Port Connecting to the **Error Port** is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. \u0002wzxhzdk:3\u0003 Data Update Port A connection to the **Data Update Port** is then made to allow us to receive the current IMU data we want. The message received from the GPIO driver is converted into a 16 bit array, named `gpioValues` that represents each pin on your MATRIX device. \u0002wzxhzdk:4\u0003 Data Output The Javascript object below is an example output you'll receive from the **Data Update Port**. For readability, the code above has converted the output as a 16-bit value and turned it into an array. \u0002wzxhzdk:5\u0003","title":"GPIO"},{"location":"matrix-core/javascript-examples/gpio/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/javascript-examples/gpio/#overview","text":"The GPIO driver supports: Reading pin input Setting pin output Device Pinouts : MATRIX Creator MATRIX Voice","title":"Overview"},{"location":"matrix-core/javascript-examples/gpio/#code-example","text":"The following sections show how to implement a connection to each of the GPIO driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our GPIO example goes. Once we connect to the **Base Port**, we will pass a configuration to the GPIO driver. With this, we can set the update rate, timeout, and pin configuration. This example will use `pin: 0` and **toggle the pin state between on ** through a `toggle()` function. > Each `pin` will save its last set `value` until the next device boot. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message, an empty string, will grant us a response from the **Data Update Port** for the current GPIO pin values. An interval for pinging is then set to continuously obtain that data. The, previously defined, toggle function is also called to swap the pin state after a ping. \u0002wzxhzdk:2\u0003 Error Port Connecting to the **Error Port** is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. \u0002wzxhzdk:3\u0003 Data Update Port A connection to the **Data Update Port** is then made to allow us to receive the current IMU data we want. The message received from the GPIO driver is converted into a 16 bit array, named `gpioValues` that represents each pin on your MATRIX device. \u0002wzxhzdk:4\u0003","title":"Code Example"},{"location":"matrix-core/javascript-examples/humidity/","text":"Humidity Javascript Example Humidity NEWWWW is currently under maintenance Device Compatibility Overview The Humidity driver allows for: Reading relative humidity on the board Obtaining temperature in Celsius and raw values Calibrating temperature Available ZeroMQ Ports Base port : 20017 Keep-alive port : 20018 Error port : 20019 Data update port : 20020 Code Example The following sections show how to implement a connection to each of the Humidity driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our Humidity example goes. Once we connect to the **Base Port**, we will pass a configuration to the humidity driver. With this we can set the update rate, timeout, and temperature configuration. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message, an empty string, will grant us a response from the **Data Update Port** for the current humidity value. An interval for pinging is then set to continuously obtain that data. \u0002wzxhzdk:2\u0003 Error Port Connecting to the **Error Port** is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. \u0002wzxhzdk:3\u0003 Data Update Port A connection to the **Data Update Port** will allow us to receive the current humidity data we want. \u0002wzxhzdk:4\u0003 Data Output The javascript object below is an example output you'll receive from the **Data Update Port**. \u0002wzxhzdk:5\u0003","title":"Humidity"},{"location":"matrix-core/javascript-examples/humidity/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/javascript-examples/humidity/#overview","text":"The Humidity driver allows for: Reading relative humidity on the board Obtaining temperature in Celsius and raw values Calibrating temperature","title":"Overview"},{"location":"matrix-core/javascript-examples/humidity/#code-example","text":"The following sections show how to implement a connection to each of the Humidity driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our Humidity example goes. Once we connect to the **Base Port**, we will pass a configuration to the humidity driver. With this we can set the update rate, timeout, and temperature configuration. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message, an empty string, will grant us a response from the **Data Update Port** for the current humidity value. An interval for pinging is then set to continuously obtain that data. \u0002wzxhzdk:2\u0003 Error Port Connecting to the **Error Port** is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. \u0002wzxhzdk:3\u0003 Data Update Port A connection to the **Data Update Port** will allow us to receive the current humidity data we want. \u0002wzxhzdk:4\u0003","title":"Code Example"},{"location":"matrix-core/javascript-examples/imu/","text":"Inertial Measurement Unit (IMU) Javascript Example Device Compatibility Overview The IMU driver reports values for: Yaw, Pitch, and Roll Acceleration for x , y , z axes Gyroscope for x , y , z axes Magnetometer for x , y , z axes Available ZeroMQ Ports Base port : 20013 Keep-alive port : 20014 Error port : 20015 Data Update port : 20016 Code Example The following sections show how to implement a connection to each of the IMU driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our IMU example goes. Once we connect to the **Base Port**, we will pass a configuration to the IMU driver. With this we can set the update rate and timeout configuration. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message, an empty string, will grant us a response from the **Data Update Port** for the current IMU values. An interval for pinging is then set to continuously obtain that data. \u0002wzxhzdk:2\u0003 Error Port Connecting to the **Error Port** is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. \u0002wzxhzdk:3\u0003 Data Update Port A connection to the **Data Update Port** is then made to allow us to receive the current IMU data we want. \u0002wzxhzdk:4\u0003 Data Output The javascript object below is an example output you'll receive from the **Data Update Port**. \u0002wzxhzdk:5\u0003","title":"IMU"},{"location":"matrix-core/javascript-examples/imu/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/javascript-examples/imu/#overview","text":"The IMU driver reports values for: Yaw, Pitch, and Roll Acceleration for x , y , z axes Gyroscope for x , y , z axes Magnetometer for x , y , z axes","title":"Overview"},{"location":"matrix-core/javascript-examples/imu/#code-example","text":"The following sections show how to implement a connection to each of the IMU driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our IMU example goes. Once we connect to the **Base Port**, we will pass a configuration to the IMU driver. With this we can set the update rate and timeout configuration. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message, an empty string, will grant us a response from the **Data Update Port** for the current IMU values. An interval for pinging is then set to continuously obtain that data. \u0002wzxhzdk:2\u0003 Error Port Connecting to the **Error Port** is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. \u0002wzxhzdk:3\u0003 Data Update Port A connection to the **Data Update Port** is then made to allow us to receive the current IMU data we want. \u0002wzxhzdk:4\u0003","title":"Code Example"},{"location":"matrix-core/javascript-examples/pressure/","text":"Pressure Javascript Example Device Compatibility Overview The Pressure driver reports values for: Pressure Altitude Temperature Based on component location, the temperature values from the Humidity driver are recommended over the Pressure driver Available ZeroMQ Ports Base port : 20025 Keep-alive port : 20026 Error port : 20027 Data Update port : 20028 Code Example The following sections show how to implement a connection to each of the Pressure driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. var zmq = require('zeromq');// Asynchronous Messaging Framework var matrix_io = require('matrix-protos').matrix_io;// Protocol Buffers for MATRIX function var matrix_ip = '127.0.0.1';// Local IP var matrix_pressure_base_port = 20025;// Port for Pressure driver Base Port Here is where the configuration for our Pressure example goes. Once we connect to the **Base Port**, we will pass a configuration to the pressure driver. With this we can set the update rate and timeout configuration. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message, an empty string, will grant us a response from the **Data Update Port** for the current pressure value. An interval for pinging is then set to continuously obtain that data. \u0002wzxhzdk:2\u0003 Error Port Connecting to the **Error Port** is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. \u0002wzxhzdk:3\u0003 Data Update Port A connection to the **Data Update Port** will allow us to receive the current pressure data we want. \u0002wzxhzdk:4\u0003 Data Output The javascript object below is an example output you'll receive from the **Data Update Port**. \u0002wzxhzdk:5\u0003","title":"Pressure"},{"location":"matrix-core/javascript-examples/pressure/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/javascript-examples/pressure/#overview","text":"The Pressure driver reports values for: Pressure Altitude Temperature Based on component location, the temperature values from the Humidity driver are recommended over the Pressure driver","title":"Overview"},{"location":"matrix-core/javascript-examples/pressure/#code-example","text":"The following sections show how to implement a connection to each of the Pressure driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. var zmq = require('zeromq');// Asynchronous Messaging Framework var matrix_io = require('matrix-protos').matrix_io;// Protocol Buffers for MATRIX function var matrix_ip = '127.0.0.1';// Local IP var matrix_pressure_base_port = 20025;// Port for Pressure driver Base Port Here is where the configuration for our Pressure example goes. Once we connect to the **Base Port**, we will pass a configuration to the pressure driver. With this we can set the update rate and timeout configuration. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message, an empty string, will grant us a response from the **Data Update Port** for the current pressure value. An interval for pinging is then set to continuously obtain that data. \u0002wzxhzdk:2\u0003 Error Port Connecting to the **Error Port** is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. \u0002wzxhzdk:3\u0003 Data Update Port A connection to the **Data Update Port** will allow us to receive the current pressure data we want. \u0002wzxhzdk:4\u0003","title":"Code Example"},{"location":"matrix-core/javascript-examples/servo/","text":"Servo Javascript Example Device Compatibility Overview The Servo driver can set the angle of your servos through the pins of your MATRIX device. Device Pinouts : MATRIX Creator MATRIX Voice Available ZeroMQ Ports Base port : 20045 Error port : 20047 Code Example The following sections show how to implement a connection to each of the Servo driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our servo example goes. Once we connect to the **Base Port**, We will pass a configuration to the servo driver. With this we can choose the pin we want to edit and the angle to set for it. This example will send random numbers to any servo attached to pin 0. \u0002wzxhzdk:1\u0003 Error Port Connecting to the **Error Port** is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. \u0002wzxhzdk:2\u0003","title":"Servo"},{"location":"matrix-core/javascript-examples/servo/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/javascript-examples/servo/#overview","text":"The Servo driver can set the angle of your servos through the pins of your MATRIX device. Device Pinouts : MATRIX Creator MATRIX Voice","title":"Overview"},{"location":"matrix-core/javascript-examples/servo/#code-example","text":"The following sections show how to implement a connection to each of the Servo driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our servo example goes. Once we connect to the **Base Port**, We will pass a configuration to the servo driver. With this we can choose the pin we want to edit and the angle to set for it. This example will send random numbers to any servo attached to pin 0. \u0002wzxhzdk:1\u0003 Error Port Connecting to the **Error Port** is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. \u0002wzxhzdk:2\u0003","title":"Code Example"},{"location":"matrix-core/javascript-examples/uv/","text":"UV Javascript Example Device Compatibility Overview The UV driver reports values for: UV Index scale used in the United States conforms with international guidelines for UVI reporting established by the World Health Organization. From UV Index Scale UV Risk scale established by World Health Organization. From UV Index Scale Available ZeroMQ Ports Base port : 20029 Keep-alive port : 20030 Error port : 20031 Data Update port : 20032 Code Example The following sections show how to implement a connection to each of the UV driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our UV example goes. Once we connect to the **Base Port**, We will pass a configuration to the UV driver. With this we can set the update rate and timeout configuration. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message, an empty string, will grant us a response from the **Data Update Port** for the current UV value. An interval for pinging is then set to continuously obtain that data. \u0002wzxhzdk:2\u0003 Error Port Connecting to the **Error Port** is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. \u0002wzxhzdk:3\u0003 Data Update Port A connection to the **Data Update Port** will allow us to receive the current UV data we want. \u0002wzxhzdk:4\u0003 Data Output The javascript object below is an example output you'll receive from the **Data Update Port**. \u0002wzxhzdk:5\u0003","title":"UV"},{"location":"matrix-core/javascript-examples/uv/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/javascript-examples/uv/#overview","text":"The UV driver reports values for: UV Index scale used in the United States conforms with international guidelines for UVI reporting established by the World Health Organization. From UV Index Scale UV Risk scale established by World Health Organization. From UV Index Scale","title":"Overview"},{"location":"matrix-core/javascript-examples/uv/#code-example","text":"The following sections show how to implement a connection to each of the UV driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our UV example goes. Once we connect to the **Base Port**, We will pass a configuration to the UV driver. With this we can set the update rate and timeout configuration. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message, an empty string, will grant us a response from the **Data Update Port** for the current UV value. An interval for pinging is then set to continuously obtain that data. \u0002wzxhzdk:2\u0003 Error Port Connecting to the **Error Port** is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. \u0002wzxhzdk:3\u0003 Data Update Port A connection to the **Data Update Port** will allow us to receive the current UV data we want. \u0002wzxhzdk:4\u0003","title":"Code Example"},{"location":"matrix-core/javascript-examples/wakeword/","text":"Wakeword Javascript Example Device Compatibility Overview The Wakeword driver allows for: Reading custom wakewords created with Sphinx Knowledge Base . Notifications on which wakewords are heard. Available ZeroMQ Ports Base port : 60001 Error port : 60003 Data update port : 60004 Code Example The following sections show how to implement a connection to each of the Wakeword driver's ports. You can download this example here . Before moving on, please take a look at the Wakeword driver's protocol page and follow the Installation Creating Custom Phrases sections. Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables and the path for our Sphinx Knowledge Base files. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our wakeword example goes. Once we connect to the **Base Port**, We will pass a configuration to the Wakeword driver. With this we can set our wakeword configurations. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message will grant us a response from the Data Update Port with the wake words that were understood. \u0002wzxhzdk:2\u0003 Error Port Connecting to the **Error Port** is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. > The Error Port is currently reporting false errors. \u0002wzxhzdk:3\u0003 Data Update Port A connection to the **Data Update Port** is then made to allow us to receive each custom phrase the Wakeword driver picks up. \u0002wzxhzdk:4\u0003 Data Output The javascript object below is an example output you'll receive from the **Data Update Port**. All wakeword strings are capitalized. \u0002wzxhzdk:5\u0003","title":"Wakeword"},{"location":"matrix-core/javascript-examples/wakeword/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/javascript-examples/wakeword/#overview","text":"The Wakeword driver allows for: Reading custom wakewords created with Sphinx Knowledge Base . Notifications on which wakewords are heard.","title":"Overview"},{"location":"matrix-core/javascript-examples/wakeword/#code-example","text":"The following sections show how to implement a connection to each of the Wakeword driver's ports. You can download this example here . Before moving on, please take a look at the Wakeword driver's protocol page and follow the Installation Creating Custom Phrases sections. Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Javascript. We also define a few helpful variables and the path for our Sphinx Knowledge Base files. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our wakeword example goes. Once we connect to the **Base Port**, We will pass a configuration to the Wakeword driver. With this we can set our wakeword configurations. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message will grant us a response from the Data Update Port with the wake words that were understood. \u0002wzxhzdk:2\u0003 Error Port Connecting to the **Error Port** is optional, but highly recommended if you want to log any errors that occur within MATRIX CORE. > The Error Port is currently reporting false errors. \u0002wzxhzdk:3\u0003 Data Update Port A connection to the **Data Update Port** is then made to allow us to receive each custom phrase the Wakeword driver picks up. \u0002wzxhzdk:4\u0003","title":"Code Example"},{"location":"matrix-core/protocols/","text":"Driver Protocols Everloop LED interface. Humidity Humidity and temperature measurement. IMU Inertial Measurement Unit. Pressure Pressure, altitude and temperature measurement. UV Ultraviolet light sensor. Servo Adjust servo positions. GPIO General Purpose Input/Output. Wakeword Create custom voice commands with Pocket Sphinx.","title":"Index"},{"location":"matrix-core/protocols/#driver-protocols","text":"","title":"Driver Protocols"},{"location":"matrix-core/protocols/everloop/","text":"Everloop Device Compatibility Overview The Everloop driver allows for: Reading amount of LEDs your MATRIX device has. Setting the RGBW colors for each individual LED. Available ZeroMQ Ports Base port : 20021 Keep-alive port : 20022 Error port : 20023 Data update port : 20024 Protocol Base Port This port accepts a single configuration for communicating with the Everloop driver. * `image` - the everloop configuration that's created from an `EverloopImage` message. \u0002wzxhzdk:0\u0003 View the defined message here . `EverloopImage` * `led` - Must hold the value for each LED on your MATRIX device. Each LED is defined as one `LedValue`. \u0002wzxhzdk:1\u0003 View the defined message here . Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string `\"\"` because the contents of a keep-alive message are never read. Error Port Applications can subscribe to this port to receive driver related errors. Data Update Port Applications can subscribe to this port for Everloop data. The output will be a serialized message of type `EverloopImage` with the following information. \u0002wzxhzdk:2\u0003 View the defined message here .","title":"Everloop"},{"location":"matrix-core/protocols/everloop/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/protocols/everloop/#overview","text":"The Everloop driver allows for: Reading amount of LEDs your MATRIX device has. Setting the RGBW colors for each individual LED.","title":"Overview"},{"location":"matrix-core/protocols/everloop/#protocol","text":"Base Port This port accepts a single configuration for communicating with the Everloop driver. * `image` - the everloop configuration that's created from an `EverloopImage` message. \u0002wzxhzdk:0\u0003 View the defined message here . `EverloopImage` * `led` - Must hold the value for each LED on your MATRIX device. Each LED is defined as one `LedValue`. \u0002wzxhzdk:1\u0003 View the defined message here . Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string `\"\"` because the contents of a keep-alive message are never read. Error Port Applications can subscribe to this port to receive driver related errors. Data Update Port Applications can subscribe to this port for Everloop data. The output will be a serialized message of type `EverloopImage` with the following information. \u0002wzxhzdk:2\u0003 View the defined message here .","title":"Protocol"},{"location":"matrix-core/protocols/gpio/","text":"General Purpose Input Output (GPIO) Device Compatibility Overview The GPIO driver supports: a Pin input Pin output Updates for the current state of all GPIO pins Device Pinouts : MATRIX Creator MATRIX Voice Available ZeroMQ Ports Base port : 20049 Keep-alive port : 20050 Error port : 20051 Data Update port : 20052 Protocol Base Port This port accepts 3 configuration for communicating with the GPIO driver. * `delay_between_updates` - controls the output speed of messages from the **Data Update port**. * `timeout_after_last_ping` - stops sending messages from the **Data Update port** if nothing has been sent to the **Keep-alive port** after the specified amount of seconds. * `gpio` - the gpio configuration that's created from a `GpioParams` message. \u0002wzxhzdk:0\u0003 View the defined message here . `GpioParams` * `pin` - Selects the pin you want to use on your MATRIX device. * `EnumMode` - Determines input or output mode for GPIO pins. * `value` - Set as 1 or 0 to signify on/off. > Each `pin` will save its last set `value` until the next device boot. \u0002wzxhzdk:1\u0003 View the defined message here . Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string `\"\"` because the contents of a keep-alive message are never read. Error Port Applications can subscribe to this port to receive driver related errors. Data Update Port Applications can subscribe to this port for GPIO data. The output will be a serialized message of type `GpioParams` with the following information. \u0002wzxhzdk:2\u0003 View the defined message here .","title":"GPIO"},{"location":"matrix-core/protocols/gpio/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/protocols/gpio/#overview","text":"The GPIO driver supports: a Pin input Pin output Updates for the current state of all GPIO pins Device Pinouts : MATRIX Creator MATRIX Voice","title":"Overview"},{"location":"matrix-core/protocols/gpio/#protocol","text":"Base Port This port accepts 3 configuration for communicating with the GPIO driver. * `delay_between_updates` - controls the output speed of messages from the **Data Update port**. * `timeout_after_last_ping` - stops sending messages from the **Data Update port** if nothing has been sent to the **Keep-alive port** after the specified amount of seconds. * `gpio` - the gpio configuration that's created from a `GpioParams` message. \u0002wzxhzdk:0\u0003 View the defined message here . `GpioParams` * `pin` - Selects the pin you want to use on your MATRIX device. * `EnumMode` - Determines input or output mode for GPIO pins. * `value` - Set as 1 or 0 to signify on/off. > Each `pin` will save its last set `value` until the next device boot. \u0002wzxhzdk:1\u0003 View the defined message here . Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string `\"\"` because the contents of a keep-alive message are never read. Error Port Applications can subscribe to this port to receive driver related errors. Data Update Port Applications can subscribe to this port for GPIO data. The output will be a serialized message of type `GpioParams` with the following information. \u0002wzxhzdk:2\u0003 View the defined message here .","title":"Protocol"},{"location":"matrix-core/protocols/humidity/","text":"Humidity Humidity is currently under maintenance Device Compatibility Overview The Humidity driver allows for: Reading relative humidity on the board Obtaining temperature in Celsius and raw values Calibrating temperature Available ZeroMQ Ports Base port : 20017 Keep-alive port : 20018 Error port : 20019 Data update port : 20020 Protocol Base Port This port accepts three configurations for communicating with the Humidity driver. * `delay_between_updates` - controls the output speed of messages from the **Data Update port**. * `timeout_after_last_ping` - stops sending messages from the **Data Update port** if nothing has been sent to the **Keep-alive port** after the specified amount of seconds. * `humidity` - the humidity configuration that's created from a `HumidityParams` message. \u0002wzxhzdk:0\u0003 View the defined message here . `HumidityParams` * `current_temperature` - a reference of the current temperature for calibration. \u0002wzxhzdk:1\u0003 View the defined message here . Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string `\"\"` because the contents of a keep-alive message are never read. Error Port Applications can subscribe to this port to receive driver related errors. Data Update Port Applications can subscribe to this port for humidity data. The output will be a serialized message of type `Humidity` with the following information. \u0002wzxhzdk:2\u0003 View the defined message here .","title":"Humidity"},{"location":"matrix-core/protocols/humidity/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/protocols/humidity/#overview","text":"The Humidity driver allows for: Reading relative humidity on the board Obtaining temperature in Celsius and raw values Calibrating temperature","title":"Overview"},{"location":"matrix-core/protocols/humidity/#protocol","text":"Base Port This port accepts three configurations for communicating with the Humidity driver. * `delay_between_updates` - controls the output speed of messages from the **Data Update port**. * `timeout_after_last_ping` - stops sending messages from the **Data Update port** if nothing has been sent to the **Keep-alive port** after the specified amount of seconds. * `humidity` - the humidity configuration that's created from a `HumidityParams` message. \u0002wzxhzdk:0\u0003 View the defined message here . `HumidityParams` * `current_temperature` - a reference of the current temperature for calibration. \u0002wzxhzdk:1\u0003 View the defined message here . Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string `\"\"` because the contents of a keep-alive message are never read. Error Port Applications can subscribe to this port to receive driver related errors. Data Update Port Applications can subscribe to this port for humidity data. The output will be a serialized message of type `Humidity` with the following information. \u0002wzxhzdk:2\u0003 View the defined message here .","title":"Protocol"},{"location":"matrix-core/protocols/imu/","text":"Inertial Measurement Unit (IMU) Device Compatibility Overview The IMU driver reports values for: Yaw, Pitch, and Roll Acceleration for x , y , z axes Gyroscope for x , y , z axes Magnetometer for x , y , z axes Available ZeroMQ Ports Base port : 20013 Keep-alive port : 20014 Error port : 20015 Data Update port : 20016 Protocol Base Port This port accepts 2 configurations for communicating with the IMU driver. delay_between_updates - controls the output speed of messages from the Data Update port . timeout_after_last_ping - stops sending messages from the Data Update port if nothing has been sent to the Keep-alive port after the specified amount of seconds. message DriverConfig { // Delay between updates in seconds float delay_between_updates = 1; // Timeout after last ping float timeout_after_last_ping = 2; View the defined message here . Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string `\"\"` because the contents of a keep-alive message are never read. Error Port Applications can subscribe to this port to receive driver related errors. Data Update Port Applications can subscribe to this port for IMU data. The output will be a serialized message of type `Imu` with the following information. \u0002wzxhzdk:1\u0003 View the defined message here .","title":"IMU"},{"location":"matrix-core/protocols/imu/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/protocols/imu/#overview","text":"The IMU driver reports values for: Yaw, Pitch, and Roll Acceleration for x , y , z axes Gyroscope for x , y , z axes Magnetometer for x , y , z axes","title":"Overview"},{"location":"matrix-core/protocols/imu/#protocol","text":"Base Port This port accepts 2 configurations for communicating with the IMU driver. delay_between_updates - controls the output speed of messages from the Data Update port . timeout_after_last_ping - stops sending messages from the Data Update port if nothing has been sent to the Keep-alive port after the specified amount of seconds. message DriverConfig { // Delay between updates in seconds float delay_between_updates = 1; // Timeout after last ping float timeout_after_last_ping = 2; View the defined message here . Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string `\"\"` because the contents of a keep-alive message are never read. Error Port Applications can subscribe to this port to receive driver related errors. Data Update Port Applications can subscribe to this port for IMU data. The output will be a serialized message of type `Imu` with the following information. \u0002wzxhzdk:1\u0003 View the defined message here .","title":"Protocol"},{"location":"matrix-core/protocols/pressure/","text":"Pressure Device Compatibility Overview The Pressure driver reports values for: Pressure Altitude Temperature Based on component location, the temperature values from the Humidity driver are recommended over the Pressure driver Available ZeroMQ Ports Base port : 20025 Keep-alive port : 20026 Error port : 20027 Data Update port : 20028 Protocol Base Port This port accepts 2 configurations for communicating with the Pressure driver. * `delay_between_updates` - controls the output speed of messages from the **Data Update port**. * `timeout_after_last_ping` - stops sending messages from the **Data Update port** if nothing has been sent to the **Keep-alive port** after the specified amount of seconds. \u0002wzxhzdk:0\u0003 View the defined message here . Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string `\"\"` because the contents of a keep-alive message are never read. Error Port Applications can subscribe to this port to receive driver related errors. Data Update Port Applications can subscribe to this port for pressure data. The output will be a serialized message of type `Pressure` with the following information. \u0002wzxhzdk:1\u0003 View the defined message here .","title":"Pressure"},{"location":"matrix-core/protocols/pressure/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/protocols/pressure/#overview","text":"The Pressure driver reports values for: Pressure Altitude Temperature Based on component location, the temperature values from the Humidity driver are recommended over the Pressure driver","title":"Overview"},{"location":"matrix-core/protocols/pressure/#protocol","text":"Base Port This port accepts 2 configurations for communicating with the Pressure driver. * `delay_between_updates` - controls the output speed of messages from the **Data Update port**. * `timeout_after_last_ping` - stops sending messages from the **Data Update port** if nothing has been sent to the **Keep-alive port** after the specified amount of seconds. \u0002wzxhzdk:0\u0003 View the defined message here . Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string `\"\"` because the contents of a keep-alive message are never read. Error Port Applications can subscribe to this port to receive driver related errors. Data Update Port Applications can subscribe to this port for pressure data. The output will be a serialized message of type `Pressure` with the following information. \u0002wzxhzdk:1\u0003 View the defined message here .","title":"Protocol"},{"location":"matrix-core/protocols/servo/","text":"Servo Device Compatibility Overview The Servo driver can set the angle of your servos through the pins of your MATRIX device. Device Pinouts : MATRIX Creator MATRIX Voice Available ZeroMQ Ports Base port : 20045 Error port : 20047 Protocol Base Port This port accepts a single configuration for communicating with the Servo driver. * `servo` - the servo configuration that's created from a `ServoParams` message. \u0002wzxhzdk:0\u0003 View the defined message here . `ServoParams` * `pin` - Selects the pin you want to use on your MATRIX device. * `angle` - emits a signal input that represents the angle set. \u0002wzxhzdk:1\u0003 View the defined message here . Error Port Applications can subscribe to this port to receive driver related errors.","title":"Servo"},{"location":"matrix-core/protocols/servo/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/protocols/servo/#overview","text":"The Servo driver can set the angle of your servos through the pins of your MATRIX device. Device Pinouts : MATRIX Creator MATRIX Voice","title":"Overview"},{"location":"matrix-core/protocols/servo/#protocol","text":"Base Port This port accepts a single configuration for communicating with the Servo driver. * `servo` - the servo configuration that's created from a `ServoParams` message. \u0002wzxhzdk:0\u0003 View the defined message here . `ServoParams` * `pin` - Selects the pin you want to use on your MATRIX device. * `angle` - emits a signal input that represents the angle set. \u0002wzxhzdk:1\u0003 View the defined message here . Error Port Applications can subscribe to this port to receive driver related errors.","title":"Protocol"},{"location":"matrix-core/protocols/uv/","text":"UV Device Compatibility Overview The UV driver reports values for: UV Index scale used in the United States conforms with international guidelines for UVI reporting established by the World Health Organization. From UV Index Scale UV Risk scale established by World Health Organization. From UV Index Scale Available ZeroMQ Ports Base port : 20029 Keep-alive port : 20030 Error port : 20031 Data Update port : 20032 Protocol Base Port This port accepts 2 configurations for communicating with the UV driver. delay_between_updates - controls the output speed of messages from the Data Update port . timeout_after_last_ping - stops sending messages from the Data Update port if nothing has been sent to the Keep-alive port after the specified amount of seconds. message DriverConfig { // Delay between updates in seconds float delay_between_updates = 1; // Timeout after last ping float timeout_after_last_ping = 2; View the defined message here . Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string `\"\"` because the contents of a keep-alive message are never read. Error Port Applications can subscribe to this port to receive driver related errors. Data Update Port Applications can subscribe to this port for UV data. The output will be a serialized message of type `UV` with the following information. \u0002wzxhzdk:1\u0003 View the defined message here .","title":"UV"},{"location":"matrix-core/protocols/uv/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/protocols/uv/#overview","text":"The UV driver reports values for: UV Index scale used in the United States conforms with international guidelines for UVI reporting established by the World Health Organization. From UV Index Scale UV Risk scale established by World Health Organization. From UV Index Scale","title":"Overview"},{"location":"matrix-core/protocols/uv/#protocol","text":"Base Port This port accepts 2 configurations for communicating with the UV driver. delay_between_updates - controls the output speed of messages from the Data Update port . timeout_after_last_ping - stops sending messages from the Data Update port if nothing has been sent to the Keep-alive port after the specified amount of seconds. message DriverConfig { // Delay between updates in seconds float delay_between_updates = 1; // Timeout after last ping float timeout_after_last_ping = 2; View the defined message here . Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string `\"\"` because the contents of a keep-alive message are never read. Error Port Applications can subscribe to this port to receive driver related errors. Data Update Port Applications can subscribe to this port for UV data. The output will be a serialized message of type `UV` with the following information. \u0002wzxhzdk:1\u0003 View the defined message here .","title":"Protocol"},{"location":"matrix-core/protocols/wakeword/","text":"Wakeword Device Compatibility Overview The Wakeword driver allows for: Reading custom wakewords created with Sphinx Knowledge Base . Notifications on which wakewords are heard. Available ZeroMQ Ports Base port : 60001 Error port : 60003 Data update port : 60004 Installation In order to use MATRIX CORE wakeword, you must install the following on your MATRIX device. Install the MATRIX Kernel modules. sudo apt install matrixio-kernel-modules Install the MATRIX CORE Wakeword Package . sudo apt install matrixio-malos-wakeword Perform a reboot before moving on. sudo reboot Creating Custom Phrases To create custom phrases, you must upload a .txt file to Sphinx Knowledge Base . Below is an example text file that has each phrase separated by a line break. Once this is uploaded to the Sphinx Knowledge base, you will need to download the language model .lm and dictation .dic files for the Wakeword Driver. matrix start action matrix stop action matrix ring red matrix ring blue matrix ring green matrix ring clear Protocol Base Port This port accepts a single configuration for communicating with the Wakeword driver. * `wakeword` - the wakeword configuration that's created from a `WakeWordParams` message. \u0002wzxhzdk:4\u0003 View the defined message here . `WakeWordParams` * `MicChannel` - Desired MATRIX device microphone to use. * `lm_path` - File path for language model. **Obtained from Sphinx Knowledge Base**. * `dic_path` - File path for dictation. **Obtained from Sphinx Knowledge Base**. * `enable_verbose` - Boolean to send output to stdout. * `stop_recognition` - Stop Pocket Sphinx service. \u0002wzxhzdk:5\u0003 View the defined message here . Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string `\"\"` because the contents of a keep-alive message are never read. Error Port Applications can subscribe to this port to receive driver related errors. Data Update Port Applications can subscribe to this port for Everloop data. The output will be a serialized message of type `EverloopImage` with the following information. \u0002wzxhzdk:6\u0003 View the defined message here .","title":"Wakeword"},{"location":"matrix-core/protocols/wakeword/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/protocols/wakeword/#overview","text":"The Wakeword driver allows for: Reading custom wakewords created with Sphinx Knowledge Base . Notifications on which wakewords are heard.","title":"Overview"},{"location":"matrix-core/protocols/wakeword/#installation","text":"In order to use MATRIX CORE wakeword, you must install the following on your MATRIX device. Install the MATRIX Kernel modules. sudo apt install matrixio-kernel-modules Install the MATRIX CORE Wakeword Package . sudo apt install matrixio-malos-wakeword Perform a reboot before moving on. sudo reboot","title":"Installation"},{"location":"matrix-core/protocols/wakeword/#creating-custom-phrases","text":"To create custom phrases, you must upload a .txt file to Sphinx Knowledge Base . Below is an example text file that has each phrase separated by a line break. Once this is uploaded to the Sphinx Knowledge base, you will need to download the language model .lm and dictation .dic files for the Wakeword Driver. matrix start action matrix stop action matrix ring red matrix ring blue matrix ring green matrix ring clear","title":"Creating Custom Phrases"},{"location":"matrix-core/protocols/wakeword/#protocol","text":"Base Port This port accepts a single configuration for communicating with the Wakeword driver. * `wakeword` - the wakeword configuration that's created from a `WakeWordParams` message. \u0002wzxhzdk:4\u0003 View the defined message here . `WakeWordParams` * `MicChannel` - Desired MATRIX device microphone to use. * `lm_path` - File path for language model. **Obtained from Sphinx Knowledge Base**. * `dic_path` - File path for dictation. **Obtained from Sphinx Knowledge Base**. * `enable_verbose` - Boolean to send output to stdout. * `stop_recognition` - Stop Pocket Sphinx service. \u0002wzxhzdk:5\u0003 View the defined message here . Keep-alive Port This driver needs keep-alive messages in order to send data to your application. It's recommended to send an empty string `\"\"` because the contents of a keep-alive message are never read. Error Port Applications can subscribe to this port to receive driver related errors. Data Update Port Applications can subscribe to this port for Everloop data. The output will be a serialized message of type `EverloopImage` with the following information. \u0002wzxhzdk:6\u0003 View the defined message here .","title":"Protocol"},{"location":"matrix-core/python-examples/","text":"Python Examples Everloop LED interface. Humidity Humidity and temperature measurement. IMU Inertial Measurement Unit. Pressure Pressure, altitude and temperature measurement. UV Ultraviolet light sensor. Servo Adjust servo positions. GPIO General Purpose Input/Output. Wakeword Create custom voice commands with Pocket Sphinx.","title":"Index"},{"location":"matrix-core/python-examples/#python-examples","text":"","title":"Python Examples"},{"location":"matrix-core/python-examples/everloop/","text":"Everloop Python Example Device Compatibility Overview The Everloop driver allows for: Reading amount of LEDs your MATRIX device has. Setting the RGBW colors for each individual LED. Available ZeroMQ Ports Base port : 20021 Keep-alive port : 20022 Error port : 20023 Data update port : 20024 Code Example The following sections show how to implement a connection to each of the Everloop driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our Everloop example goes. Once we connect to the **Base Port**, we will pass a configuration to the Everloop driver. With this we can set the LED configuration. The `while True` loop is used to show how you can rapidly push different LED colors. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message will grant us a response from the **Data Update Port** for the current LED count of your MATRIX device. The code below will give only send one ping because LED count will not change. \u0002wzxhzdk:2\u0003 Error Port The **Error Port** connection is taken care of by the `utils import`. Below we define a function to be called and given any error messages that occur within MATRIX CORE. \u0002wzxhzdk:3\u0003 Data Update Port A connection to the **Data Update Port** will allow us to receive the current LED count on your MATRIX device. Once we connect to the port, the `updateLedCount` function will pass the LED count to a global variable and then close the connection the **Data-update Port**. \u0002wzxhzdk:4\u0003 Data Output The Python object below is an example output you'll receive from the **Data Update Port**. > The output name will be changed in a following update \u0002wzxhzdk:5\u0003 Start Processes This is where we begin the asynchronous events for each of the driver ports and where we define the functions we want to use for each port. This example is only using the **Error Port** connection asynchronously because the **Keep-alive Port** and **Data-update Port** are only used once. \u0002wzxhzdk:6\u0003","title":"Everloop"},{"location":"matrix-core/python-examples/everloop/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/python-examples/everloop/#overview","text":"The Everloop driver allows for: Reading amount of LEDs your MATRIX device has. Setting the RGBW colors for each individual LED.","title":"Overview"},{"location":"matrix-core/python-examples/everloop/#code-example","text":"The following sections show how to implement a connection to each of the Everloop driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our Everloop example goes. Once we connect to the **Base Port**, we will pass a configuration to the Everloop driver. With this we can set the LED configuration. The `while True` loop is used to show how you can rapidly push different LED colors. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message will grant us a response from the **Data Update Port** for the current LED count of your MATRIX device. The code below will give only send one ping because LED count will not change. \u0002wzxhzdk:2\u0003 Error Port The **Error Port** connection is taken care of by the `utils import`. Below we define a function to be called and given any error messages that occur within MATRIX CORE. \u0002wzxhzdk:3\u0003 Data Update Port A connection to the **Data Update Port** will allow us to receive the current LED count on your MATRIX device. Once we connect to the port, the `updateLedCount` function will pass the LED count to a global variable and then close the connection the **Data-update Port**. \u0002wzxhzdk:4\u0003","title":"Code Example"},{"location":"matrix-core/python-examples/gpio/","text":"General Purpose Input Output (GPIO) Python Example Device Compatibility Overview The GPIO driver supports: Reading pin input Setting pin output Device Pinouts : MATRIX Creator MATRIX Voice Available ZeroMQ Ports Base port : 20049 Keep-alive port : 20050 Error port : 20051 Data Update port : 20052 Code Example The following sections show how to implement a connection to each of the GPIO driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our GPIO example goes. Once we connect to the **Base Port**, we will pass a configuration to the GPIO driver. With this, we can set the update rate, timeout, and pin configuration. This example will use `pin: 0` and **toggle the pin state between on ** through a `toggle()` function. > Each `pin` will save its last set `value` until the next device boot. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message will grant us a response from the **Data Update Port** for the current GPIO values. The `utils import` from the **Initial Variables** section takes care of this. Error Port The **Error Port** connection is also taken care of by the `utils import`. Below we define a function to be called and given any error messages that occur within MATRIX CORE. \u0002wzxhzdk:2\u0003 Data Update Port A connection to the **Data Update Port** is then made to allow us to receive the current IMU data we want. The message received from the GPIO driver is converted into a 16 bit array, named `gpioValues` that represents each pin on your MATRIX device. \u0002wzxhzdk:3\u0003 Data Output The Python object below is an example output you'll receive from the **Data Update Port**. For readability, the code above has converted the output as a 16-bit value and turned it into an array. \u0002wzxhzdk:4\u0003 Start Processes This is where we begin the asynchronous events for each of the driver ports and where we define the functions we want to use for each port. \u0002wzxhzdk:5\u0003","title":"GPIO"},{"location":"matrix-core/python-examples/gpio/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/python-examples/gpio/#overview","text":"The GPIO driver supports: Reading pin input Setting pin output Device Pinouts : MATRIX Creator MATRIX Voice","title":"Overview"},{"location":"matrix-core/python-examples/gpio/#code-example","text":"The following sections show how to implement a connection to each of the GPIO driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our GPIO example goes. Once we connect to the **Base Port**, we will pass a configuration to the GPIO driver. With this, we can set the update rate, timeout, and pin configuration. This example will use `pin: 0` and **toggle the pin state between on ** through a `toggle()` function. > Each `pin` will save its last set `value` until the next device boot. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message will grant us a response from the **Data Update Port** for the current GPIO values. The `utils import` from the **Initial Variables** section takes care of this. Error Port The **Error Port** connection is also taken care of by the `utils import`. Below we define a function to be called and given any error messages that occur within MATRIX CORE. \u0002wzxhzdk:2\u0003 Data Update Port A connection to the **Data Update Port** is then made to allow us to receive the current IMU data we want. The message received from the GPIO driver is converted into a 16 bit array, named `gpioValues` that represents each pin on your MATRIX device. \u0002wzxhzdk:3\u0003","title":"Code Example"},{"location":"matrix-core/python-examples/humidity/","text":"Humidity Python Example Humidity is currently under maintenance Device Compatibility Overview The Humidity driver allows for: Reading relative humidity on the board Obtaining temperature in Celsius and raw values Calibrating temperature Available ZeroMQ Ports Base port : 20017 Keep-alive port : 20018 Error port : 20019 Data update port : 20020 Code Example The following sections show how to implement a connection to each of the Humidity driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our humidity example goes. Once we connect to the **Base Port**, we will pass a configuration to the humidity driver. With this we can set the update rate, timeout, and temperature configuration. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message will grant us a response from the **Data Update Port** for the current humidity value. The `utils import` from the **Initial Variables** section takes care of this. Error Port The **Error Port** connection is also taken care of by the `utils import`. Below we define a function to be called and given any error messages that occur within MATRIX CORE. \u0002wzxhzdk:2\u0003 Data Update Port A connection to the **Data Update Port** will allow us to receive the current humidity data we want. The `utils import` takes care of this as well. We can define a function and expect humidity data to be passed to it. \u0002wzxhzdk:3\u0003 Data Output The Python object below is an example output you'll receive from the **Data Update Port**. \u0002wzxhzdk:4\u0003 Start Processes This is where we begin the asynchronous events for each of the driver ports and where we define the functions we want to use for each port. \u0002wzxhzdk:5\u0003","title":"Humidity"},{"location":"matrix-core/python-examples/humidity/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/python-examples/humidity/#overview","text":"The Humidity driver allows for: Reading relative humidity on the board Obtaining temperature in Celsius and raw values Calibrating temperature","title":"Overview"},{"location":"matrix-core/python-examples/humidity/#code-example","text":"The following sections show how to implement a connection to each of the Humidity driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our humidity example goes. Once we connect to the **Base Port**, we will pass a configuration to the humidity driver. With this we can set the update rate, timeout, and temperature configuration. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message will grant us a response from the **Data Update Port** for the current humidity value. The `utils import` from the **Initial Variables** section takes care of this. Error Port The **Error Port** connection is also taken care of by the `utils import`. Below we define a function to be called and given any error messages that occur within MATRIX CORE. \u0002wzxhzdk:2\u0003 Data Update Port A connection to the **Data Update Port** will allow us to receive the current humidity data we want. The `utils import` takes care of this as well. We can define a function and expect humidity data to be passed to it. \u0002wzxhzdk:3\u0003","title":"Code Example"},{"location":"matrix-core/python-examples/imu/","text":"Inertial Measurement Unit (IMU) Python Example Device Compatibility Overview The IMU driver reports values for: Yaw, Pitch, and Roll Acceleration for x , y , z axes Gyroscope for x , y , z axes Magnetometer for x , y , z axes Available ZeroMQ Ports Base port : 20013 Keep-alive port : 20014 Error port : 20015 Data Update port : 20016 Code Example The following sections show how to implement a connection to each of the IMU driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our IMU example goes. Once we connect to the **Base Port**, we will pass a configuration to the IMU driver. With this we can set the update rate, timeout, and temperature configuration. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message will grant us a response from the **Data Update Port** for the current IMU value. The `utils import` from the **Initial Variables** section takes care of this. Error Port The **Error Port** connection is also taken care of by the `utils import`. Below we define a function to be called and given any error messages that occur within MATRIX CORE. \u0002wzxhzdk:2\u0003 Data Update Port A connection to the **Data Update Port** will allow us to receive the current IMU data we want. The `utils import` takes care of this as well. We can define a function and expect IMU data to be passed to it. \u0002wzxhzdk:3\u0003 Data Output The Python object below is an example output you'll receive from the **Data Update Port**. \u0002wzxhzdk:4\u0003 Start Processes This is where we begin the asynchronous events for each of the driver ports and where we define the functions we want to use for each port. \u0002wzxhzdk:5\u0003","title":"IMU"},{"location":"matrix-core/python-examples/imu/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/python-examples/imu/#overview","text":"The IMU driver reports values for: Yaw, Pitch, and Roll Acceleration for x , y , z axes Gyroscope for x , y , z axes Magnetometer for x , y , z axes","title":"Overview"},{"location":"matrix-core/python-examples/imu/#code-example","text":"The following sections show how to implement a connection to each of the IMU driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our IMU example goes. Once we connect to the **Base Port**, we will pass a configuration to the IMU driver. With this we can set the update rate, timeout, and temperature configuration. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message will grant us a response from the **Data Update Port** for the current IMU value. The `utils import` from the **Initial Variables** section takes care of this. Error Port The **Error Port** connection is also taken care of by the `utils import`. Below we define a function to be called and given any error messages that occur within MATRIX CORE. \u0002wzxhzdk:2\u0003 Data Update Port A connection to the **Data Update Port** will allow us to receive the current IMU data we want. The `utils import` takes care of this as well. We can define a function and expect IMU data to be passed to it. \u0002wzxhzdk:3\u0003","title":"Code Example"},{"location":"matrix-core/python-examples/pressure/","text":"Pressure Python Example Device Compatibility Overview The Pressure driver reports values for: Pressure Altitude Temperature Based on component location, the temperature values from the Humidity driver are recommended over the Pressure driver Available ZeroMQ Ports Base port : 20025 Keep-alive port : 20026 Error port : 20027 Data Update port : 20028 Code Example The following sections show how to implement a connection to each of the Pressure driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our pressure example goes. Once we connect to the **Base Port**, we will pass a configuration to the pressure driver. With this we can set the update rate, timeout, and temperature configuration. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message will grant us a response from the **Data Update Port** for the current pressure value. The `utils import` from the **Initial Variables** section takes care of this. Error Port The **Error Port** connection is also taken care of by the `utils import`. Below we define a function to be called and given any error messages that occur within MATRIX CORE. \u0002wzxhzdk:2\u0003 Data Update Port A connection to the **Data Update Port** will allow us to receive the current pressure data we want. The `utils import` takes care of this as well. We can define a function and expect pressure data to be passed to it. \u0002wzxhzdk:3\u0003 Data Output The Python object below is an example output you'll receive from the **Data Update Port**. \u0002wzxhzdk:4\u0003 Start Processes This is where we begin the asynchronous events for each of the driver ports and where we define the functions we want to use for each port. \u0002wzxhzdk:5\u0003","title":"Pressure"},{"location":"matrix-core/python-examples/pressure/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/python-examples/pressure/#overview","text":"The Pressure driver reports values for: Pressure Altitude Temperature Based on component location, the temperature values from the Humidity driver are recommended over the Pressure driver","title":"Overview"},{"location":"matrix-core/python-examples/pressure/#code-example","text":"The following sections show how to implement a connection to each of the Pressure driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our pressure example goes. Once we connect to the **Base Port**, we will pass a configuration to the pressure driver. With this we can set the update rate, timeout, and temperature configuration. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message will grant us a response from the **Data Update Port** for the current pressure value. The `utils import` from the **Initial Variables** section takes care of this. Error Port The **Error Port** connection is also taken care of by the `utils import`. Below we define a function to be called and given any error messages that occur within MATRIX CORE. \u0002wzxhzdk:2\u0003 Data Update Port A connection to the **Data Update Port** will allow us to receive the current pressure data we want. The `utils import` takes care of this as well. We can define a function and expect pressure data to be passed to it. \u0002wzxhzdk:3\u0003","title":"Code Example"},{"location":"matrix-core/python-examples/servo/","text":"Servo Python Example Device Compatibility Overview The Servo driver can set the angle of your servos through the pins of your MATRIX device. Device Pinouts : MATRIX Creator MATRIX Voice Available ZeroMQ Ports Base port : 20045 Error port : 20047 Code Example The following sections show how to implement a connection to each of the Servo driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our servo example goes. Once we connect to the **Base Port**, we will pass a configuration to the servo driver. With this we can choose the pin we want to edit and the angle to set for it. This example will send random numbers to any servo attached to pin 0. This example has a `moveServo()` function that calls itself to send random angles to your servo. \u0002wzxhzdk:1\u0003 Error Port The **Error Port** connection is taken care of by the `utils import`. Below we define a function to be called and given any error messages that occur within MATRIX CORE. \u0002wzxhzdk:2\u0003 Start Processes This is where we begin the asynchronous events for each of the driver ports used and where we define the functions we want to use for each port. \u0002wzxhzdk:3\u0003","title":"Servo"},{"location":"matrix-core/python-examples/servo/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/python-examples/servo/#overview","text":"The Servo driver can set the angle of your servos through the pins of your MATRIX device. Device Pinouts : MATRIX Creator MATRIX Voice","title":"Overview"},{"location":"matrix-core/python-examples/servo/#code-example","text":"The following sections show how to implement a connection to each of the Servo driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our servo example goes. Once we connect to the **Base Port**, we will pass a configuration to the servo driver. With this we can choose the pin we want to edit and the angle to set for it. This example will send random numbers to any servo attached to pin 0. This example has a `moveServo()` function that calls itself to send random angles to your servo. \u0002wzxhzdk:1\u0003 Error Port The **Error Port** connection is taken care of by the `utils import`. Below we define a function to be called and given any error messages that occur within MATRIX CORE. \u0002wzxhzdk:2\u0003 Start Processes This is where we begin the asynchronous events for each of the driver ports used and where we define the functions we want to use for each port. \u0002wzxhzdk:3\u0003","title":"Code Example"},{"location":"matrix-core/python-examples/uv/","text":"UV Python Example Device Compatibility Overview The UV driver reports values for: UV Index scale used in the United States conforms with international guidelines for UVI reporting established by the World Health Organization. From UV Index Scale UV Risk scale established by World Health Organization. From UV Index Scale Available ZeroMQ Ports Base port : 20029 Keep-alive port : 20030 Error port : 20031 Data Update port : 20032 Code Example The following sections show how to implement a connection to each of the UV driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our UV example goes. Once we connect to the **Base Port**, we will pass a configuration to the UV driver. With this we can set the update rate, timeout, and temperature configuration. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message will grant us a response from the **Data Update Port** for the current UV value. The `utils import` from the **Initial Variables** section takes care of this. Error Port The **Error Port** connection is also taken care of by the `utils import`. Below we define a function to be called and given any error messages that occur within MATRIX CORE. \u0002wzxhzdk:2\u0003 Data Update Port A connection to the **Data Update Port** will allow us to receive the current UV data we want. The `utils import` takes care of this as well. We can define a function and expect UV data to be passed to it. \u0002wzxhzdk:3\u0003 Data Output The Python object below is an example output you'll receive from the **Data Update Port**. \u0002wzxhzdk:4\u0003 Start Processes This is where we begin the asynchronous events for each of the driver ports and where we define the functions we want to use for each port. \u0002wzxhzdk:5\u0003","title":"UV"},{"location":"matrix-core/python-examples/uv/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/python-examples/uv/#overview","text":"The UV driver reports values for: UV Index scale used in the United States conforms with international guidelines for UVI reporting established by the World Health Organization. From UV Index Scale UV Risk scale established by World Health Organization. From UV Index Scale","title":"Overview"},{"location":"matrix-core/python-examples/uv/#code-example","text":"The following sections show how to implement a connection to each of the UV driver's ports. You can download this example here . Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables for easy references. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our UV example goes. Once we connect to the **Base Port**, we will pass a configuration to the UV driver. With this we can set the update rate, timeout, and temperature configuration. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message will grant us a response from the **Data Update Port** for the current UV value. The `utils import` from the **Initial Variables** section takes care of this. Error Port The **Error Port** connection is also taken care of by the `utils import`. Below we define a function to be called and given any error messages that occur within MATRIX CORE. \u0002wzxhzdk:2\u0003 Data Update Port A connection to the **Data Update Port** will allow us to receive the current UV data we want. The `utils import` takes care of this as well. We can define a function and expect UV data to be passed to it. \u0002wzxhzdk:3\u0003","title":"Code Example"},{"location":"matrix-core/python-examples/wakeword/","text":"Wakeword Python Example Device Compatibility Overview The Wakeword driver allows for: Reading custom wakewords created with Sphinx Knowledge Base . Notifications on which wakewords are heard. Available ZeroMQ Ports Base port : 60001 Error port : 60003 Data update port : 60004 Code Example The following sections show how to implement a connection to each of the IMU driver's ports. You can download this example here . Before moving on, please take a look at the Wakeword driver's protocol page and follow the Installation Creating Custom Phrases sections. Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables and the path for our Sphinx Knowledge Base files. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our wakeword example goes. Once we connect to the **Base Port**, we will pass a configuration to the Wakeword driver. With this we can set our wakeword configurations. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message will grant us a response from the Data Update Port with the wake words that were understood. \u0002wzxhzdk:2\u0003 Error Port The **Error Port** connection is also taken care of by the `utils import`. Below we define a function to be called and given any error messages that occur within MATRIX CORE. > The Error Port is currently reporting false errors. \u0002wzxhzdk:3\u0003 Data Update Port A connection to the **Data Update Port** is then made to allow us to receive each custom phrase the Wakeword driver picks up. \u0002wzxhzdk:4\u0003 Data Output The Python object below is an example output you'll receive from the **Data Update Port**. All wakeword strings are capitalized. \u0002wzxhzdk:5\u0003 Start Processes This is where we begin the asynchronous events for each of the driver ports and where we define the functions we want to use for each port. \u0002wzxhzdk:6\u0003","title":"Wakeword"},{"location":"matrix-core/python-examples/wakeword/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-core/python-examples/wakeword/#overview","text":"The Wakeword driver allows for: Reading custom wakewords created with Sphinx Knowledge Base . Notifications on which wakewords are heard.","title":"Overview"},{"location":"matrix-core/python-examples/wakeword/#code-example","text":"The following sections show how to implement a connection to each of the IMU driver's ports. You can download this example here . Before moving on, please take a look at the Wakeword driver's protocol page and follow the Installation Creating Custom Phrases sections. Initial Variables Before we go into connecting to each port, the variables defined below are needed in order to access the ZeroMQ and MATRIX Protocol Buffer libraries for Python. We also define a few helpful variables and the path for our Sphinx Knowledge Base files. \u0002wzxhzdk:0\u0003 Base Port Here is where the configuration for our wakeword example goes. Once we connect to the **Base Port**, we will pass a configuration to the Wakeword driver. With this we can set our wakeword configurations. \u0002wzxhzdk:1\u0003 Keep-alive Port The next step is to connect and send a message to the **Keep-alive Port**. That message will grant us a response from the Data Update Port with the wake words that were understood. \u0002wzxhzdk:2\u0003 Error Port The **Error Port** connection is also taken care of by the `utils import`. Below we define a function to be called and given any error messages that occur within MATRIX CORE. > The Error Port is currently reporting false errors. \u0002wzxhzdk:3\u0003 Data Update Port A connection to the **Data Update Port** is then made to allow us to receive each custom phrase the Wakeword driver picks up. \u0002wzxhzdk:4\u0003","title":"Code Example"},{"location":"matrix-creator/device-setup/","text":"Hardware Prerequisites MATRIX Creator Compatible Raspberry Pi: 3 Model B+ 3 Model B 2 Model B 1 Model B+ Zero Zero W 5V 2.5A Micro USB Power Supply MicroSD Card With Raspbian Stretch Lite or Desktop Installed We recommend using Etcher.io for easy flashing Device Installation Steps Insert flashed microSD card into Raspberry Pi Attach MATRIX Creator onto Raspberry Pi GPIO pins Power Raspberry Pi with micro USB power supply Choosing A Programming Environment After your MATRIX Creator is setup, visit Ecosystem Overview for information about the three programming environments available to you in the MATRIX platform.","title":"Device Setup"},{"location":"matrix-creator/device-setup/#hardware-prerequisites","text":"MATRIX Creator Compatible Raspberry Pi: 3 Model B+ 3 Model B 2 Model B 1 Model B+ Zero Zero W 5V 2.5A Micro USB Power Supply MicroSD Card With Raspbian Stretch Lite or Desktop Installed We recommend using Etcher.io for easy flashing","title":"Hardware Prerequisites"},{"location":"matrix-creator/device-setup/#device-installation","text":"","title":"Device Installation"},{"location":"matrix-creator/device-setup/#choosing-a-programming-environment","text":"After your MATRIX Creator is setup, visit Ecosystem Overview for information about the three programming environments available to you in the MATRIX platform.","title":"Choosing A Programming Environment"},{"location":"matrix-creator/overview/","text":"MATRIX Creator The MATRIX Creator is a fully-featured development board, including sensors, wireless communications, and an FPGA. MATRIX Creator was built with a mission to give every maker, tinkerer, and developer around the world a complete, affordable, and user-friendly tool for simple to complex Internet of Things (IoT) app creation. Overview Device Setup How to get started with your MATRIX Creator Resources View and download helpful information about the MATRIX Creator Troubleshooting Look at common debugging solutions and test the hardware on your MATRIX Creator","title":"Overview"},{"location":"matrix-creator/overview/#matrix-creator","text":"The MATRIX Creator is a fully-featured development board, including sensors, wireless communications, and an FPGA. MATRIX Creator was built with a mission to give every maker, tinkerer, and developer around the world a complete, affordable, and user-friendly tool for simple to complex Internet of Things (IoT) app creation.","title":"MATRIX Creator"},{"location":"matrix-creator/overview/#overview","text":"","title":"Overview"},{"location":"matrix-creator/troubleshooting/","text":"Community Please visit our community support forums at community.matrix.one Reinstall MATRIX Init Package and Reflash FPGA and MCU If you experience strange behavior, reinstall the MATRIX init package and reflash FPGA and MCU. Uninstall the matrixio-creator-init package. sudo apt-get --purge remove matrixio-creator-init Reboot your device. sudo reboot Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the matrixio-creator-init package. sudo apt-get install matrixio-creator-init Reboot your device. sudo reboot FPGA will be reflashed with stock firmware. Now you can flash the FPGA. Reset the FPGA. echo 18 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio18/direction echo 1 /sys/class/gpio/gpio18/value echo 0 /sys/class/gpio/gpio18/value echo 1 /sys/class/gpio/gpio18/value Flash the FPGA. cd /usr/share/matrixlabs/matrixio-devices/ xc3sprog -c matrix_creator blob/system_creator.bit -p 1 You should receive the following. XC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux Free software: If you contribute nothing, expect nothing! Feedback on success/failure/enhancement requests: http://sourceforge.net/mail/?group_id=170565 Check Sourceforge for updates: http://sourceforge.net/projects/xc3sprog/develop DNA is 0x99a9bca3325faafd Reset the FPGA. echo 26 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio26/direction echo 1 /sys/class/gpio/gpio26/value echo 0 /sys/class/gpio/gpio26/value echo 1 /sys/class/gpio/gpio26/value MCU will be reflashed with stock firmware. Now you can flash the MCU. cd /usr/share/matrixlabs/matrixio-devices/ sudo openocd -f cfg/sam3s_rpi_sysfs.cfg The last part of the openocd flashing command output should be the following. flash 'at91sam3' found at 0x00400000 wrote 36636 bytes from file blob/ch.bin to flash bank 0 at offset 0x00000000 in 4.665386s (7.669 KiB/s) Info : JTAG tap: em358.cpu tap/device found: 0x3ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x3) Info : JTAG tap: em357.bs tap/device found: 0x069aa62b (mfg: 0x315 (Ember Corporation), part: 0x69aa, ver: 0x0)Info : JTAG tap: xc6sxl4.fpga.fpga tap/device found: 0x24000093 (mfg: 0x049 (Xilinx), part: 0x4000, ver: 0x2) Info : JTAG tap: sam3n.cpu.cpu tap/device found: 0x4ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x4) Warn : Only resetting the Cortex-M core, use a reset-init event handler to reset any peripherals or configure hardware srst support. shutdown command invoked Power off your device. sudo poweroff Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi. Plug the power cable back into your Raspberry Pi. Reinstall MATRIX Kernel Modules If you experience strange behavior, reinstall the MATRIX kernel modules. Uninstall the matrixio-kernel-modules package. sudo apt-get --purge remove matrixio-kernel-modules Reboot your device. sudo reboot Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the matrixio-kernel-modules package. sudo apt-get install matrixio-kernel-modules Reboot your device. sudo reboot Check Raspberry Pi GPIO If you experience strange behavior, check the Raspberry Pi GPIO. sudo cat /sys/kernel/debug/gpio You should receive the following. gpiochip0: GPIOs 0-53, parent: platform/3f200000.gpio, pinctrl-bcm2835: gpio-4 ( |sysfs ) in hi gpio-16 ( |sysfs ) out lo gpio-17 ( |sysfs ) in hi gpio-18 ( |sysfs ) out hi gpio-19 ( |sysfs ) out hi gpio-20 ( |sysfs ) out hi gpio-21 ( |sysfs ) out hi gpio-22 ( |sysfs ) in lo gpio-23 ( |sysfs ) out hi gpio-27 ( |sysfs ) in hi If sysfs above is replaced with w1 , use raspi-config to disable the 1-Wire interface. sudo raspi-config Inside raspi-config, navigate to Interfacing Options 1-Wire NO . Hardware Tests These tests will check if your MATRIX Creator is functioning properly. We first need to install matrixio-creator-init, which handles the flashing of FPGA. Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the MATRIX init package. sudo apt-get install matrixio-creator-init Reboot your device. sudo reboot Matrix Init Script After the reboot, run the matrix init script manually. sudo /usr/share/matrixlabs/matrixio-devices/matrix-init.bash You should receive the following. **** MATRIX Creator FPGA has been programmed! INFO: [/dev/spidev0.0] was opened FPGA IDENTIFY = 5c344e8 FPGA VERSION = 1000a *** MATRIX Creator initial process has been launched *** Running the program instead of the bootloader EM358 MCU was programmed before. Not programming it again. Running the program instead of the bootloader SAM3 MCU was programmed before. Not programming it again. If you have the matrixio-kernel-modules installed, you should receive this instead. **** MATRIX Creator FPGA has been programmed! INFO: [/dev/matrixio_regmap] was opened FPGA IDENTIFY = 5c344e8 FPGA VERSION = 1000a *** MATRIX Creator initial process has been launched *** Running the program instead of the bootloader EM358 MCU was programmed before. Not programming it again. Running the program instead of the bootloader SAM3 MCU was programmed before. Not programming it again. FPGA Info This program checks the fpga info. sudo /usr/share/matrixlabs/matrixio-devices/fpga_info You should receive the following. INFO: [/dev/spidev0.0] was opened FPGA IDENTIFY = 5c344e8 FPGA VERSION = 1000a If you have the matrixio-kernel-modules installed, you should receive this instead. INFO: [/dev/matrixio_regmap] was opened FPGA IDENTIFY = 5c344e8 FPGA VERSION = 1000a FPGA Flash If you don\u2019t get the proper FPGA info you will need to run the FPGA flashing process. cd /usr/share/matrixlabs/matrixio-devices/ sudo ./fpga-program.bash You should receive the following. **** MATRIX Creator FPGA has been programmed! INFO: [/dev/spidev0.0] was opened FPGA IDENTIFY = 5c344e8 FPGA VERSION = 1000a If you have the matrixio-kernel-modules installed, you should receive this instead. **** MATRIX Creator FPGA has been programmed! INFO: [/dev/matrixio_regmap] was opened FPGA IDENTIFY = 5c344e8 FPGA VERSION = 1000a If you get **** Could not program FPGA , please contact us . Test Other Components Install MATRIX HAL and test other components such as the microphone array using the MATRIX HAL examples .","title":"Troubleshooting"},{"location":"matrix-creator/troubleshooting/#community","text":"Please visit our community support forums at community.matrix.one","title":"Community"},{"location":"matrix-creator/troubleshooting/#reinstall-matrix-init-package-and-reflash-fpga-and-mcu","text":"If you experience strange behavior, reinstall the MATRIX init package and reflash FPGA and MCU. Uninstall the matrixio-creator-init package. sudo apt-get --purge remove matrixio-creator-init Reboot your device. sudo reboot Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the matrixio-creator-init package. sudo apt-get install matrixio-creator-init Reboot your device. sudo reboot FPGA will be reflashed with stock firmware. Now you can flash the FPGA. Reset the FPGA. echo 18 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio18/direction echo 1 /sys/class/gpio/gpio18/value echo 0 /sys/class/gpio/gpio18/value echo 1 /sys/class/gpio/gpio18/value Flash the FPGA. cd /usr/share/matrixlabs/matrixio-devices/ xc3sprog -c matrix_creator blob/system_creator.bit -p 1 You should receive the following. XC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux Free software: If you contribute nothing, expect nothing! Feedback on success/failure/enhancement requests: http://sourceforge.net/mail/?group_id=170565 Check Sourceforge for updates: http://sourceforge.net/projects/xc3sprog/develop DNA is 0x99a9bca3325faafd Reset the FPGA. echo 26 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio26/direction echo 1 /sys/class/gpio/gpio26/value echo 0 /sys/class/gpio/gpio26/value echo 1 /sys/class/gpio/gpio26/value MCU will be reflashed with stock firmware. Now you can flash the MCU. cd /usr/share/matrixlabs/matrixio-devices/ sudo openocd -f cfg/sam3s_rpi_sysfs.cfg The last part of the openocd flashing command output should be the following. flash 'at91sam3' found at 0x00400000 wrote 36636 bytes from file blob/ch.bin to flash bank 0 at offset 0x00000000 in 4.665386s (7.669 KiB/s) Info : JTAG tap: em358.cpu tap/device found: 0x3ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x3) Info : JTAG tap: em357.bs tap/device found: 0x069aa62b (mfg: 0x315 (Ember Corporation), part: 0x69aa, ver: 0x0)Info : JTAG tap: xc6sxl4.fpga.fpga tap/device found: 0x24000093 (mfg: 0x049 (Xilinx), part: 0x4000, ver: 0x2) Info : JTAG tap: sam3n.cpu.cpu tap/device found: 0x4ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x4) Warn : Only resetting the Cortex-M core, use a reset-init event handler to reset any peripherals or configure hardware srst support. shutdown command invoked Power off your device. sudo poweroff Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi. Plug the power cable back into your Raspberry Pi.","title":"Reinstall MATRIX Init Package and Reflash FPGA and MCU"},{"location":"matrix-creator/troubleshooting/#reinstall-matrix-kernel-modules","text":"If you experience strange behavior, reinstall the MATRIX kernel modules. Uninstall the matrixio-kernel-modules package. sudo apt-get --purge remove matrixio-kernel-modules Reboot your device. sudo reboot Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the matrixio-kernel-modules package. sudo apt-get install matrixio-kernel-modules Reboot your device. sudo reboot","title":"Reinstall MATRIX Kernel Modules"},{"location":"matrix-creator/troubleshooting/#check-raspberry-pi-gpio","text":"If you experience strange behavior, check the Raspberry Pi GPIO. sudo cat /sys/kernel/debug/gpio You should receive the following. gpiochip0: GPIOs 0-53, parent: platform/3f200000.gpio, pinctrl-bcm2835: gpio-4 ( |sysfs ) in hi gpio-16 ( |sysfs ) out lo gpio-17 ( |sysfs ) in hi gpio-18 ( |sysfs ) out hi gpio-19 ( |sysfs ) out hi gpio-20 ( |sysfs ) out hi gpio-21 ( |sysfs ) out hi gpio-22 ( |sysfs ) in lo gpio-23 ( |sysfs ) out hi gpio-27 ( |sysfs ) in hi If sysfs above is replaced with w1 , use raspi-config to disable the 1-Wire interface. sudo raspi-config Inside raspi-config, navigate to Interfacing Options 1-Wire NO .","title":"Check Raspberry Pi GPIO"},{"location":"matrix-creator/troubleshooting/#hardware-tests","text":"These tests will check if your MATRIX Creator is functioning properly. We first need to install matrixio-creator-init, which handles the flashing of FPGA. Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the MATRIX init package. sudo apt-get install matrixio-creator-init Reboot your device. sudo reboot","title":"Hardware Tests"},{"location":"matrix-creator/troubleshooting/#matrix-init-script","text":"After the reboot, run the matrix init script manually. sudo /usr/share/matrixlabs/matrixio-devices/matrix-init.bash You should receive the following. **** MATRIX Creator FPGA has been programmed! INFO: [/dev/spidev0.0] was opened FPGA IDENTIFY = 5c344e8 FPGA VERSION = 1000a *** MATRIX Creator initial process has been launched *** Running the program instead of the bootloader EM358 MCU was programmed before. Not programming it again. Running the program instead of the bootloader SAM3 MCU was programmed before. Not programming it again. If you have the matrixio-kernel-modules installed, you should receive this instead. **** MATRIX Creator FPGA has been programmed! INFO: [/dev/matrixio_regmap] was opened FPGA IDENTIFY = 5c344e8 FPGA VERSION = 1000a *** MATRIX Creator initial process has been launched *** Running the program instead of the bootloader EM358 MCU was programmed before. Not programming it again. Running the program instead of the bootloader SAM3 MCU was programmed before. Not programming it again.","title":"Matrix Init Script"},{"location":"matrix-creator/troubleshooting/#fpga-info","text":"This program checks the fpga info. sudo /usr/share/matrixlabs/matrixio-devices/fpga_info You should receive the following. INFO: [/dev/spidev0.0] was opened FPGA IDENTIFY = 5c344e8 FPGA VERSION = 1000a If you have the matrixio-kernel-modules installed, you should receive this instead. INFO: [/dev/matrixio_regmap] was opened FPGA IDENTIFY = 5c344e8 FPGA VERSION = 1000a","title":"FPGA Info"},{"location":"matrix-creator/troubleshooting/#fpga-flash","text":"If you don\u2019t get the proper FPGA info you will need to run the FPGA flashing process. cd /usr/share/matrixlabs/matrixio-devices/ sudo ./fpga-program.bash You should receive the following. **** MATRIX Creator FPGA has been programmed! INFO: [/dev/spidev0.0] was opened FPGA IDENTIFY = 5c344e8 FPGA VERSION = 1000a If you have the matrixio-kernel-modules installed, you should receive this instead. **** MATRIX Creator FPGA has been programmed! INFO: [/dev/matrixio_regmap] was opened FPGA IDENTIFY = 5c344e8 FPGA VERSION = 1000a If you get **** Could not program FPGA , please contact us .","title":"FPGA Flash"},{"location":"matrix-creator/troubleshooting/#test-other-components","text":"Install MATRIX HAL and test other components such as the microphone array using the MATRIX HAL examples .","title":"Test Other Components"},{"location":"matrix-creator/resources/fpga/","text":"FPGA Flashing Guide \u26a0\ufe0fModifying FPGA source may have unintended consequences\u26a0\ufe0f Device Compatibility Overview The FPGA handles: GPIO output UART for Zigbee and Z-Wave Connections between board components Microphone processing (not provided in source code) FPGA Source \u26a0\ufe0fFPGA source does not contain audio processing code\u26a0\ufe0f FPGA source code is located here . FPGA Flashing Below is a guide on how to flash a premade user-provided FPGA bitstream onto the Xilinx Spartan-6 FPGA for the MATRIX Creator. We first need to install a few prerequisites. Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the required packages. sudo apt-get install matrixio-creator-init Reboot your device. sudo reboot Backup the stock system_creator.bit file. sudo mv /usr/share/matrixlabs/matrixio-devices/blob/system_creator.bit /usr/share/matrixlabs/matrixio-devices/blob/system_creator_stock.bit Copy your built system_creator.bit FPGA bitstream file to the blob folder. sudo cp /path/to/your/file /usr/share/matrixlabs/matrixio-devices/blob/system_creator.bit Now you can flash the FPGA. Reset the FPGA. echo 18 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio18/direction echo 1 /sys/class/gpio/gpio18/value echo 0 /sys/class/gpio/gpio18/value echo 1 /sys/class/gpio/gpio18/value Flash the FPGA. cd /usr/share/matrixlabs/matrixio-devices/ xc3sprog -c matrix_creator blob/system_creator.bit -p 1 You should receive the following (may vary due to user-provided file). XC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux Free software: If you contribute nothing, expect nothing! Feedback on success/failure/enhancement requests: http://sourceforge.net/mail/?group_id=170565 Check Sourceforge for updates: http://sourceforge.net/projects/xc3sprog/develop DNA is 0x99a9bca3325faafd Reset the FPGA. echo 18 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio18/direction echo 1 /sys/class/gpio/gpio18/value echo 0 /sys/class/gpio/gpio18/value echo 1 /sys/class/gpio/gpio18/value Updating the matrixio-creator-init package will cause the stock FPGA bitstream to be flashed upon next boot. You can stop sudo apt-get upgrade from automatically updating the matrixio-creator-init package with the following command. sudo apt-mark hold matrixio-creator-init Power off your device. sudo poweroff Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi. Plug the power cable back into your Raspberry Pi. Restore Original Firmware To restore the original firmware, restore the stock system_creator.bit file in the blob folder. sudo rm /usr/share/matrixlabs/matrixio-devices/blob/system_creator.bit sudo cp /usr/share/matrixlabs/matrixio-devices/blob/system_creator_stock.bit /usr/share/matrixlabs/matrixio-devices/blob/system_creator.bit Now you can flash the FPGA. Reset the FPGA. echo 18 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio18/direction echo 1 /sys/class/gpio/gpio18/value echo 0 /sys/class/gpio/gpio18/value echo 1 /sys/class/gpio/gpio18/value Flash the FPGA. cd /usr/share/matrixlabs/matrixio-devices/ xc3sprog -c matrix_creator blob/system_creator.bit -p 1 You should receive the following. XC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux Free software: If you contribute nothing, expect nothing! Feedback on success/failure/enhancement requests: http://sourceforge.net/mail/?group_id=170565 Check Sourceforge for updates: http://sourceforge.net/projects/xc3sprog/develop DNA is 0x99a9bca3325faafd Reset the FPGA. echo 18 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio18/direction echo 1 /sys/class/gpio/gpio18/value echo 0 /sys/class/gpio/gpio18/value echo 1 /sys/class/gpio/gpio18/value Allow sudo apt-get upgrade to update the matrixio-creator-init package. sudo apt-mark unhold matrixio-creator-init Power off your device. sudo poweroff Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi. Plug the power cable back into your Raspberry Pi.","title":"FPGA"},{"location":"matrix-creator/resources/fpga/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-creator/resources/fpga/#overview","text":"The FPGA handles: GPIO output UART for Zigbee and Z-Wave Connections between board components Microphone processing (not provided in source code)","title":"Overview"},{"location":"matrix-creator/resources/fpga/#fpga-source","text":"\u26a0\ufe0fFPGA source does not contain audio processing code\u26a0\ufe0f FPGA source code is located here .","title":"FPGA Source"},{"location":"matrix-creator/resources/fpga/#fpga-flashing","text":"Below is a guide on how to flash a premade user-provided FPGA bitstream onto the Xilinx Spartan-6 FPGA for the MATRIX Creator. We first need to install a few prerequisites. Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the required packages. sudo apt-get install matrixio-creator-init Reboot your device. sudo reboot Backup the stock system_creator.bit file. sudo mv /usr/share/matrixlabs/matrixio-devices/blob/system_creator.bit /usr/share/matrixlabs/matrixio-devices/blob/system_creator_stock.bit Copy your built system_creator.bit FPGA bitstream file to the blob folder. sudo cp /path/to/your/file /usr/share/matrixlabs/matrixio-devices/blob/system_creator.bit Now you can flash the FPGA. Reset the FPGA. echo 18 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio18/direction echo 1 /sys/class/gpio/gpio18/value echo 0 /sys/class/gpio/gpio18/value echo 1 /sys/class/gpio/gpio18/value Flash the FPGA. cd /usr/share/matrixlabs/matrixio-devices/ xc3sprog -c matrix_creator blob/system_creator.bit -p 1 You should receive the following (may vary due to user-provided file). XC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux Free software: If you contribute nothing, expect nothing! Feedback on success/failure/enhancement requests: http://sourceforge.net/mail/?group_id=170565 Check Sourceforge for updates: http://sourceforge.net/projects/xc3sprog/develop DNA is 0x99a9bca3325faafd Reset the FPGA. echo 18 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio18/direction echo 1 /sys/class/gpio/gpio18/value echo 0 /sys/class/gpio/gpio18/value echo 1 /sys/class/gpio/gpio18/value Updating the matrixio-creator-init package will cause the stock FPGA bitstream to be flashed upon next boot. You can stop sudo apt-get upgrade from automatically updating the matrixio-creator-init package with the following command. sudo apt-mark hold matrixio-creator-init Power off your device. sudo poweroff Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi. Plug the power cable back into your Raspberry Pi.","title":"FPGA Flashing"},{"location":"matrix-creator/resources/fpga/#restore-original-firmware","text":"To restore the original firmware, restore the stock system_creator.bit file in the blob folder. sudo rm /usr/share/matrixlabs/matrixio-devices/blob/system_creator.bit sudo cp /usr/share/matrixlabs/matrixio-devices/blob/system_creator_stock.bit /usr/share/matrixlabs/matrixio-devices/blob/system_creator.bit Now you can flash the FPGA. Reset the FPGA. echo 18 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio18/direction echo 1 /sys/class/gpio/gpio18/value echo 0 /sys/class/gpio/gpio18/value echo 1 /sys/class/gpio/gpio18/value Flash the FPGA. cd /usr/share/matrixlabs/matrixio-devices/ xc3sprog -c matrix_creator blob/system_creator.bit -p 1 You should receive the following. XC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux Free software: If you contribute nothing, expect nothing! Feedback on success/failure/enhancement requests: http://sourceforge.net/mail/?group_id=170565 Check Sourceforge for updates: http://sourceforge.net/projects/xc3sprog/develop DNA is 0x99a9bca3325faafd Reset the FPGA. echo 18 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio18/direction echo 1 /sys/class/gpio/gpio18/value echo 0 /sys/class/gpio/gpio18/value echo 1 /sys/class/gpio/gpio18/value Allow sudo apt-get upgrade to update the matrixio-creator-init package. sudo apt-mark unhold matrixio-creator-init Power off your device. sudo poweroff Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi. Plug the power cable back into your Raspberry Pi.","title":"Restore Original Firmware"},{"location":"matrix-creator/resources/mcu/","text":"Microprocessor (MCU) Flashing Guide \u26a0\ufe0fModifying MCU source may have unintended consequences\u26a0\ufe0f Device Compatibility Overview The MCU handles: Interfacing with and processing sensor data Calculating Yaw, Pitch, Roll MCU Source MCU source code is located here . MCU Flashing Below is a guide on how to flash modified source onto the Atmel SAM3S MCU for the MATRIX Creator. For this guide, the source code will be modified to disable the blue blinking led (labeled D48 on board), which is controlled by the MCU. We first need to install a few prerequisites. Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the required packages. sudo apt-get install matrixio-creator-init git gcc-arm-none-eabi Reboot your device. sudo reboot Then, clone the MCU source repo. cd ~/ git clone https://github.com/matrix-io/matrix-creator-mcu.git Edit the file matrix-creator-mcu/creator/main.cpp , commenting out line 82. This change disables the blue blinking led. Then build the modified MCU source. cd ~/ cd matrix-creator-mcu/creator/ make Backup the stock ch.bin file. sudo mv /usr/share/matrixlabs/matrixio-devices/blob/ch.bin /usr/share/matrixlabs/matrixio-devices/blob/ch_stock.bin Copy your built ch.bin file to the blob folder. cd ~/ cd matrix-creator-mcu/creator/ sudo cp ./build/ch.bin /usr/share/matrixlabs/matrixio-devices/blob/ch.bin Now you can flash the MCU. cd /usr/share/matrixlabs/matrixio-devices/ sudo openocd -f cfg/sam3s_rpi_sysfs.cfg The last part of the openocd flashing command output should be the following (may vary due to user-provided file). flash 'at91sam3' found at 0x00400000 wrote 36636 bytes from file blob/ch.bin to flash bank 0 at offset 0x00000000 in 4.665386s (7.669 KiB/s) Info : JTAG tap: em358.cpu tap/device found: 0x3ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x3) Info : JTAG tap: em357.bs tap/device found: 0x069aa62b (mfg: 0x315 (Ember Corporation), part: 0x69aa, ver: 0x0)Info : JTAG tap: xc6sxl4.fpga.fpga tap/device found: 0x24000093 (mfg: 0x049 (Xilinx), part: 0x4000, ver: 0x2) Info : JTAG tap: sam3n.cpu.cpu tap/device found: 0x4ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x4) Warn : Only resetting the Cortex-M core, use a reset-init event handler to reset any peripherals or configure hardware srst support. shutdown command invoked In order to maintain compatibility with the matrixio-creator-init package, you'll need to backup the original mcu_firmware.version file, and create your own. cd /usr/share/matrixlabs/matrixio-devices/ sudo mv /usr/share/matrixlabs/matrixio-devices/mcu_firmware.version /usr/share/matrixlabs/matrixio-devices/mcu_firmware_stock.version (./firmware_info | grep MCU) | sudo tee mcu_firmware.version Updating the matrixio-creator-init package will cause the stock FPGA bitstream to be flashed upon next boot. You can stop sudo apt-get upgrade from automatically updating the matrixio-creator-init package with the following command. sudo apt-mark hold matrixio-creator-init Power off your device. sudo poweroff Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi. Plug the power cable back into your Raspberry Pi. Restore Original Firmware To restore the original firmware, restore the stock ch.bin file in the blob folder. sudo rm /usr/share/matrixlabs/matrixio-devices/blob/ch.bin sudo cp /usr/share/matrixlabs/matrixio-devices/blob/ch_stock.bin /usr/share/matrixlabs/matrixio-devices/blob/ch.bin Now you can flash the MCU. cd /usr/share/matrixlabs/matrixio-devices/ sudo openocd -f cfg/sam3s_rpi_sysfs.cfg The last part of the openocd flashing command output should be the following. flash 'at91sam3' found at 0x00400000 wrote 36636 bytes from file blob/ch.bin to flash bank 0 at offset 0x00000000 in 4.665386s (7.669 KiB/s) Info : JTAG tap: em358.cpu tap/device found: 0x3ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x3) Info : JTAG tap: em357.bs tap/device found: 0x069aa62b (mfg: 0x315 (Ember Corporation), part: 0x69aa, ver: 0x0)Info : JTAG tap: xc6sxl4.fpga.fpga tap/device found: 0x24000093 (mfg: 0x049 (Xilinx), part: 0x4000, ver: 0x2) Info : JTAG tap: sam3n.cpu.cpu tap/device found: 0x4ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x4) Warn : Only resetting the Cortex-M core, use a reset-init event handler to reset any peripherals or configure hardware srst support. shutdown command invoked Restore the stock mcu_firmware.version file. sudo rm /usr/share/matrixlabs/matrixio-devices/mcu_firmware.version sudo cp /usr/share/matrixlabs/matrixio-devices/mcu_firmware_stock.version /usr/share/matrixlabs/matrixio-devices/mcu_firmware.version Allow sudo apt-get upgrade to update the matrixio-creator-init package. sudo apt-mark unhold matrixio-creator-init Power off your device. sudo poweroff Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi. Plug the power cable back into your Raspberry Pi.","title":"MCU"},{"location":"matrix-creator/resources/mcu/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-creator/resources/mcu/#overview","text":"The MCU handles: Interfacing with and processing sensor data Calculating Yaw, Pitch, Roll","title":"Overview"},{"location":"matrix-creator/resources/mcu/#mcu-source","text":"MCU source code is located here .","title":"MCU Source"},{"location":"matrix-creator/resources/mcu/#mcu-flashing","text":"Below is a guide on how to flash modified source onto the Atmel SAM3S MCU for the MATRIX Creator. For this guide, the source code will be modified to disable the blue blinking led (labeled D48 on board), which is controlled by the MCU. We first need to install a few prerequisites. Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the required packages. sudo apt-get install matrixio-creator-init git gcc-arm-none-eabi Reboot your device. sudo reboot Then, clone the MCU source repo. cd ~/ git clone https://github.com/matrix-io/matrix-creator-mcu.git Edit the file matrix-creator-mcu/creator/main.cpp , commenting out line 82. This change disables the blue blinking led. Then build the modified MCU source. cd ~/ cd matrix-creator-mcu/creator/ make Backup the stock ch.bin file. sudo mv /usr/share/matrixlabs/matrixio-devices/blob/ch.bin /usr/share/matrixlabs/matrixio-devices/blob/ch_stock.bin Copy your built ch.bin file to the blob folder. cd ~/ cd matrix-creator-mcu/creator/ sudo cp ./build/ch.bin /usr/share/matrixlabs/matrixio-devices/blob/ch.bin Now you can flash the MCU. cd /usr/share/matrixlabs/matrixio-devices/ sudo openocd -f cfg/sam3s_rpi_sysfs.cfg The last part of the openocd flashing command output should be the following (may vary due to user-provided file). flash 'at91sam3' found at 0x00400000 wrote 36636 bytes from file blob/ch.bin to flash bank 0 at offset 0x00000000 in 4.665386s (7.669 KiB/s) Info : JTAG tap: em358.cpu tap/device found: 0x3ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x3) Info : JTAG tap: em357.bs tap/device found: 0x069aa62b (mfg: 0x315 (Ember Corporation), part: 0x69aa, ver: 0x0)Info : JTAG tap: xc6sxl4.fpga.fpga tap/device found: 0x24000093 (mfg: 0x049 (Xilinx), part: 0x4000, ver: 0x2) Info : JTAG tap: sam3n.cpu.cpu tap/device found: 0x4ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x4) Warn : Only resetting the Cortex-M core, use a reset-init event handler to reset any peripherals or configure hardware srst support. shutdown command invoked In order to maintain compatibility with the matrixio-creator-init package, you'll need to backup the original mcu_firmware.version file, and create your own. cd /usr/share/matrixlabs/matrixio-devices/ sudo mv /usr/share/matrixlabs/matrixio-devices/mcu_firmware.version /usr/share/matrixlabs/matrixio-devices/mcu_firmware_stock.version (./firmware_info | grep MCU) | sudo tee mcu_firmware.version Updating the matrixio-creator-init package will cause the stock FPGA bitstream to be flashed upon next boot. You can stop sudo apt-get upgrade from automatically updating the matrixio-creator-init package with the following command. sudo apt-mark hold matrixio-creator-init Power off your device. sudo poweroff Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi. Plug the power cable back into your Raspberry Pi.","title":"MCU Flashing"},{"location":"matrix-creator/resources/mcu/#restore-original-firmware","text":"To restore the original firmware, restore the stock ch.bin file in the blob folder. sudo rm /usr/share/matrixlabs/matrixio-devices/blob/ch.bin sudo cp /usr/share/matrixlabs/matrixio-devices/blob/ch_stock.bin /usr/share/matrixlabs/matrixio-devices/blob/ch.bin Now you can flash the MCU. cd /usr/share/matrixlabs/matrixio-devices/ sudo openocd -f cfg/sam3s_rpi_sysfs.cfg The last part of the openocd flashing command output should be the following. flash 'at91sam3' found at 0x00400000 wrote 36636 bytes from file blob/ch.bin to flash bank 0 at offset 0x00000000 in 4.665386s (7.669 KiB/s) Info : JTAG tap: em358.cpu tap/device found: 0x3ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x3) Info : JTAG tap: em357.bs tap/device found: 0x069aa62b (mfg: 0x315 (Ember Corporation), part: 0x69aa, ver: 0x0)Info : JTAG tap: xc6sxl4.fpga.fpga tap/device found: 0x24000093 (mfg: 0x049 (Xilinx), part: 0x4000, ver: 0x2) Info : JTAG tap: sam3n.cpu.cpu tap/device found: 0x4ba00477 (mfg: 0x23b (ARM Ltd.), part: 0xba00, ver: 0x4) Warn : Only resetting the Cortex-M core, use a reset-init event handler to reset any peripherals or configure hardware srst support. shutdown command invoked Restore the stock mcu_firmware.version file. sudo rm /usr/share/matrixlabs/matrixio-devices/mcu_firmware.version sudo cp /usr/share/matrixlabs/matrixio-devices/mcu_firmware_stock.version /usr/share/matrixlabs/matrixio-devices/mcu_firmware.version Allow sudo apt-get upgrade to update the matrixio-creator-init package. sudo apt-mark unhold matrixio-creator-init Power off your device. sudo poweroff Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi. Plug the power cable back into your Raspberry Pi.","title":"Restore Original Firmware"},{"location":"matrix-creator/resources/microphone/","text":"Microphone Array on MATRIX Creator Usage Driver installation Follow the instructions below for allowing your MATRIX Creator to register as a microphone for your Raspberry Pi. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list sudo apt-get update sudo apt-get upgrade A reboot will be required after following the steps above. sudo reboot The next commands will install the MATRIX kernel modules, overriding the stock Raspbian kernel. sudo apt install matrixio-kernel-modules A second reboot will be required. sudo reboot Check If Everything Works Your Raspberry Pi should now treat your MATRIX Creator as a regular microphone. You can test this by using the following commands to record and play a 5 second long audio file on your Raspberry Pi. Be sure to have something connected to the Raspberry Pi's audio output. arecord recording.wav -f S16_LE -r 16000 -d 5 aplay recording.wav ALSA Configuration The microphones can be grabbed using ALSA. Multiple libraries that support ALSA use these configurations to read microphone data with ALSA. Device name - hw:2,0 Rates(Hz) - 8000 12000 16000 22050 24000 32000 44100 48000 96000 Channels for each microphone - 1 2 3 4 5 6 7 8 Audio Specifications Sample Rate: 8 to 96 kHz Bit Depth: Signed 16 bit Position [x,y] of each mic in the array (mm) Mic X Y M1 20.0908795 -48.5036755 M2 -20.0908795 -48.5036755 M3 -48.5036755 -20.0908795 M4 -48.5036755 20.0908795 M5 -20.0908795 48.5036755 M6 20.0908795 48.5036755 M7 48.5036755 20.0908795 M8 48.5036755 -20.0908795 Connection to the FPGA You can check the physical connection between the FPGA and other components in creator.ucf Mic FPGA pin PDM_Data M1 P45 pdm_data 0 M2 P46 pdm_data 1 M3 P47 pdm_data 2 M4 P58 pdm_data 3 M5 P59 pdm_data 4 M6 P64 pdm_data 5 M7 P65 pdm_data 6 M8 P44 pdm_data 7 CLK P47 pdm_clk","title":"Microphones"},{"location":"matrix-creator/resources/microphone/#microphone-array-on-matrix-creator","text":"","title":"Microphone Array on MATRIX Creator"},{"location":"matrix-creator/resources/microphone/#usage","text":"","title":"Usage"},{"location":"matrix-creator/resources/microphone/#audio-specifications","text":"Sample Rate: 8 to 96 kHz Bit Depth: Signed 16 bit","title":"Audio Specifications"},{"location":"matrix-creator/resources/overview/","text":"Resources Pinout Lists and labels of the MATRIX Creator's Pinouts Microphones Microphone drivers, sample rate, and board position Reference Models Download or view the Matrix Creator's 3D models and case System Architecture View a technical diagram of the MATRIX Creator architecture. Technical Datasheets PDFs of MATRIX Creator Components MCU Microcontroller source and flashing guide FPGA FPGA source and flashing guide","title":"Overview"},{"location":"matrix-creator/resources/overview/#resources","text":"","title":"Resources"},{"location":"matrix-creator/resources/pinout/","text":"Expansion GPIO Rev 1 Boards do not include pin 25 26. Rev 2 boards can be identified if there is a QR code sticker on the MATRIX Creator's face. Raspberry Pi GPIO GPIO Locations","title":"Pinout"},{"location":"matrix-creator/resources/pinout/#expansion-gpio","text":"Rev 1 Boards do not include pin 25 26. Rev 2 boards can be identified if there is a QR code sticker on the MATRIX Creator's face.","title":"Expansion GPIO"},{"location":"matrix-creator/resources/pinout/#raspberry-pi-gpio","text":"","title":"Raspberry Pi GPIO"},{"location":"matrix-creator/resources/pinout/#gpio-locations","text":"","title":"GPIO Locations"},{"location":"matrix-creator/resources/reference-models/","text":"Board Model Top View Bottom View Model Download Access to 3D models here . Also, you can take a look online here . Case Model Printed Case Model Download Access to 3D case models here .","title":"Reference Models"},{"location":"matrix-creator/resources/reference-models/#board-model","text":"","title":"Board Model"},{"location":"matrix-creator/resources/reference-models/#case-model","text":"","title":"Case Model"},{"location":"matrix-creator/resources/system-architecture/","text":"System Architecture","title":"System Architecture"},{"location":"matrix-creator/resources/system-architecture/#system-architecture","text":"","title":"System Architecture"},{"location":"matrix-creator/resources/technical-datasheets/","text":"Datasheets: Atmel 32 bits Cortex M3 SAM3S2 Xilinx Spartan 6S XC6SLX4 FPGA 8 MEMS audio sensor digital microphones ST LSM9DS1 3D accelerometer, 3D gyroscope, 3D magnetometer ST HTS221 digital sensor for relative humidity and temperature NXP PN512 NFC reader NXP MPL3115A2 Altimeter Vishay VEML6070 UV Light Sensor Vishay INFRARED Receptor RGBW everloop LED","title":"Technical Datasheets"},{"location":"matrix-creator/resources/technical-datasheets/#datasheets","text":"Atmel 32 bits Cortex M3 SAM3S2 Xilinx Spartan 6S XC6SLX4 FPGA 8 MEMS audio sensor digital microphones ST LSM9DS1 3D accelerometer, 3D gyroscope, 3D magnetometer ST HTS221 digital sensor for relative humidity and temperature NXP PN512 NFC reader NXP MPL3115A2 Altimeter Vishay VEML6070 UV Light Sensor Vishay INFRARED Receptor RGBW everloop LED","title":"Datasheets:"},{"location":"matrix-hal/overview/","text":"MATRIX Hardware Abstraction Layer MATRIX Hardware Abstraction Layer (HAL) is an open source library for directly interfacing with the MATRIX device. MATRIX HAL consists of driver files written in C++ which enable the user to write low level programs in C++. Getting Started Learn how to install MATRIX HAL and create programs on your MATRIX device. Reference Look over the MATRIX HAL functions for interacting with your MATRIX device. Examples View our MATRIX HAL code examples. Troubleshooting Look at common debugging solutions for any issues you encounter.","title":"Overview"},{"location":"matrix-hal/overview/#getting-started","text":"Learn how to install MATRIX HAL and create programs on your MATRIX device.","title":"Getting Started"},{"location":"matrix-hal/overview/#reference","text":"Look over the MATRIX HAL functions for interacting with your MATRIX device.","title":"Reference"},{"location":"matrix-hal/overview/#examples","text":"View our MATRIX HAL code examples.","title":"Examples"},{"location":"matrix-hal/overview/#troubleshooting","text":"Look at common debugging solutions for any issues you encounter.","title":"Troubleshooting"},{"location":"matrix-hal/troubleshooting/","text":"Community Please visit our community support forums at community.matrix.one Check Installed MATRIX Packages Run the following command on your Raspberry Pi's terminal to see the currently installed MATRIX packages. dpkg -l | grep matrix Reinstall MATRIX HAL If you experience strange behavior, reinstall MATRIX HAL. Uninstall the libmatrixio-creator-hal and libmatrixio-creator-hal-dev package. sudo apt-get --purge remove libmatrixio-creator-hal libmatrixio-creator-hal-dev Uninstall HAL built from source. sudo rm -rf /usr/local/include/matrix_hal sudo rm -rf /usr/local/lib/libmatrix_creator_hal.so Reboot your device. sudo reboot Install MATRIX HAL from package or from source .","title":"Troubleshooting"},{"location":"matrix-hal/troubleshooting/#community","text":"Please visit our community support forums at community.matrix.one","title":"Community"},{"location":"matrix-hal/troubleshooting/#check-installed-matrix-packages","text":"Run the following command on your Raspberry Pi's terminal to see the currently installed MATRIX packages. dpkg -l | grep matrix","title":"Check Installed MATRIX Packages"},{"location":"matrix-hal/troubleshooting/#reinstall-matrix-hal","text":"If you experience strange behavior, reinstall MATRIX HAL. Uninstall the libmatrixio-creator-hal and libmatrixio-creator-hal-dev package. sudo apt-get --purge remove libmatrixio-creator-hal libmatrixio-creator-hal-dev Uninstall HAL built from source. sudo rm -rf /usr/local/include/matrix_hal sudo rm -rf /usr/local/lib/libmatrix_creator_hal.so Reboot your device. sudo reboot Install MATRIX HAL from package or from source .","title":"Reinstall MATRIX HAL"},{"location":"matrix-hal/examples/","text":"MATRIX HAL Examples Download Examples The following commands download and compile all the examples. sudo apt-get install cmake g++ git cd ~/ git clone https://github.com/matrix-io/matrix-hal-examples.git cd matrix-hal-examples mkdir build cd build cmake .. make -j4 Everloop LED interface. Humidity Humidity and temperature measurement. IMU Inertial Measurement Unit. Pressure Pressure, altitude and temperature measurement. UV Ultraviolet light sensor. GPIO General Purpose Input/Output. Microphone Microphone Array.","title":"Index"},{"location":"matrix-hal/examples/#matrix-hal-examples","text":"","title":"MATRIX HAL Examples"},{"location":"matrix-hal/examples/#download-examples","text":"The following commands download and compile all the examples. sudo apt-get install cmake g++ git cd ~/ git clone https://github.com/matrix-io/matrix-hal-examples.git cd matrix-hal-examples mkdir build cd build cmake .. make -j4","title":"Download Examples"},{"location":"matrix-hal/examples/everloop/","text":"Everloop HAL Example Device Compatibility Overview The Everloop interface supports: Setting the RGBW colors for each individual LED. Code Examples Below are examples of how to interface with the Everloop in MATRIX HAL. Everloop function references can be found here . The command below will compile each example. Be sure to pass in your C++ file and desired output file. g++ -o YOUR_OUTPUT_FILE YOUR_CPP_FILE -std=c++11 -lmatrix_creator_hal Everloop Green The following section shows how to set the Everloop to green. You can download this example here . Result ![](/matrix-hal/img/everloop_green.jpg) Include Statements To begin working with the Everloop you need to include these header files. \u0002wzxhzdk:1\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. \u0002wzxhzdk:2\u0003 Main Setup Now we will create our `EverloopImage` and `Everloop` object and use it to set the Everloop to green for 10 seconds. \u0002wzxhzdk:3\u0003 Everloop Yellow/Purple The following section shows how to set the Everloop to yellow and purple (with color blending). You can download this example here . Result ![](/matrix-hal/img/everloop_yellow_purple.jpg) Include Statements To begin working with the Everloop you need to include these header files. \u0002wzxhzdk:4\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. \u0002wzxhzdk:5\u0003 Main Setup Now we will create our `EverloopImage` and `Everloop` object and use it to set the Everloop to yellow and purple for 10 seconds. \u0002wzxhzdk:6\u0003 Everloop Rainbow The following section shows how to set the Everloop to rainbow. You can download this example here . Result ![](/matrix-hal/img/everloop_rainbow.gif) Include Statements To begin working with the Everloop you need to include these header files. \u0002wzxhzdk:7\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. \u0002wzxhzdk:8\u0003 Main Setup Now we will create our `EverloopImage` and `Everloop` object and use it to set the Everloop to rainbow for 10 seconds. \u0002wzxhzdk:9\u0003 Everloop Moving Dots The following section shows how to set the Everloop to moving dots. You can download this example here . Result ![](/matrix-hal/img/everloop_moving_dots.gif) Include Statements To begin working with the Everloop you need to include these header files. \u0002wzxhzdk:10\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. \u0002wzxhzdk:11\u0003 Main Setup Now we will create our `EverloopImage` and `Everloop` object and use it to set the Everloop to moving dots for 10 seconds. \u0002wzxhzdk:12\u0003","title":"Everloop"},{"location":"matrix-hal/examples/everloop/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-hal/examples/everloop/#overview","text":"The Everloop interface supports: Setting the RGBW colors for each individual LED.","title":"Overview"},{"location":"matrix-hal/examples/everloop/#code-examples","text":"Below are examples of how to interface with the Everloop in MATRIX HAL. Everloop function references can be found here . The command below will compile each example. Be sure to pass in your C++ file and desired output file. g++ -o YOUR_OUTPUT_FILE YOUR_CPP_FILE -std=c++11 -lmatrix_creator_hal Everloop Green The following section shows how to set the Everloop to green. You can download this example here .","title":"Code Examples"},{"location":"matrix-hal/examples/gpio/","text":"General Purpose Input Output (GPIO) HAL Example Device Compatibility Overview The GPIO interface supports: Pin I/O input Pin I/O output Pin PWM output Device Pinouts : MATRIX Creator MATRIX Voice Code Examples Below are examples of how to interface with the GPIO in MATRIX HAL. GPIO function references can be found here . The command below will compile each example. Be sure to pass in your C++ file and desired output file. g++ -o YOUR_OUTPUT_FILE YOUR_CPP_FILE -std=c++11 -lmatrix_creator_hal GPIO I/O The following section shows how to use GPIO in digital I/O mode for output and input. You can download this example here . Include Statements To begin working with the GPIO you need to include these header files. \u0002wzxhzdk:1\u0003 Initial Variables These initial variables are used in the example. \u0002wzxhzdk:2\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. \u0002wzxhzdk:3\u0003 Main Setup Now we will create our `GPIOControl` object and use it to output and input a digital GPIO signal. \u0002wzxhzdk:4\u0003 GPIO PWM The following section shows how to use GPIO in PWM mode for PWM output. You can download this example here . Include Statements To begin working with the GPIO you need to include these header files. \u0002wzxhzdk:5\u0003 Initial Variables These initial variables are used in the example. \u0002wzxhzdk:6\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. \u0002wzxhzdk:7\u0003 Main Setup Now we will create our `GPIOControl` object and use it to output and input a digital GPIO signal. \u0002wzxhzdk:8\u0003 GPIO Servo The following section shows how to use GPIO in PWM mode for controlling a servo. You can download this example here . Include Statements To begin working with the GPIO you need to include these header files. \u0002wzxhzdk:9\u0003 Initial Variables These initial variables are used in the example. \u0002wzxhzdk:10\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. \u0002wzxhzdk:11\u0003 Main Setup Now we will create our `GPIOControl` object and use it to output and input a digital GPIO signal. Servo neutral position is achieved with a 1.5 milliseconds pulse, so by taking the minimum servo pulse (in milliseconds) the SetServoAngle function calibrates servo angle. If unsure of min_pulse_ms enter `0.8`. \u0002wzxhzdk:12\u0003","title":"GPIO"},{"location":"matrix-hal/examples/gpio/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-hal/examples/gpio/#overview","text":"The GPIO interface supports: Pin I/O input Pin I/O output Pin PWM output Device Pinouts : MATRIX Creator MATRIX Voice","title":"Overview"},{"location":"matrix-hal/examples/gpio/#code-examples","text":"Below are examples of how to interface with the GPIO in MATRIX HAL. GPIO function references can be found here . The command below will compile each example. Be sure to pass in your C++ file and desired output file. g++ -o YOUR_OUTPUT_FILE YOUR_CPP_FILE -std=c++11 -lmatrix_creator_hal GPIO I/O The following section shows how to use GPIO in digital I/O mode for output and input. You can download this example here . Include Statements To begin working with the GPIO you need to include these header files. \u0002wzxhzdk:1\u0003 Initial Variables These initial variables are used in the example. \u0002wzxhzdk:2\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. \u0002wzxhzdk:3\u0003 Main Setup Now we will create our `GPIOControl` object and use it to output and input a digital GPIO signal. \u0002wzxhzdk:4\u0003 GPIO PWM The following section shows how to use GPIO in PWM mode for PWM output. You can download this example here . Include Statements To begin working with the GPIO you need to include these header files. \u0002wzxhzdk:5\u0003 Initial Variables These initial variables are used in the example. \u0002wzxhzdk:6\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. \u0002wzxhzdk:7\u0003 Main Setup Now we will create our `GPIOControl` object and use it to output and input a digital GPIO signal. \u0002wzxhzdk:8\u0003 GPIO Servo The following section shows how to use GPIO in PWM mode for controlling a servo. You can download this example here . Include Statements To begin working with the GPIO you need to include these header files. \u0002wzxhzdk:9\u0003 Initial Variables These initial variables are used in the example. \u0002wzxhzdk:10\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. \u0002wzxhzdk:11\u0003 Main Setup Now we will create our `GPIOControl` object and use it to output and input a digital GPIO signal. Servo neutral position is achieved with a 1.5 milliseconds pulse, so by taking the minimum servo pulse (in milliseconds) the SetServoAngle function calibrates servo angle. If unsure of min_pulse_ms enter `0.8`. \u0002wzxhzdk:12\u0003","title":"Code Examples"},{"location":"matrix-hal/examples/humidity/","text":"Humidity HAL Example Device Compatibility Overview The humidity sensor reports values for: Humidity Temperature Code Example Below is an example of how to interface with the humidity sensor in MATRIX HAL. Humidity sensor function references can be found here . The following section shows how to receive data from the humidity sensor. You can download this example here . The command below will compile the example. Be sure to pass in your C++ file and desired output file. g++ -o YOUR_OUTPUT_FILE YOUR_CPP_FILE -std=c++11 -lmatrix_creator_hal Include Statements To begin working with the humidity sensor you need to include these header files. \u0002wzxhzdk:1\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. \u0002wzxhzdk:2\u0003 Main Setup Now we will create our `HumidityData` and `HumiditySensor` object and use it to receive data from the humidity sensor. \u0002wzxhzdk:3\u0003","title":"Humidity"},{"location":"matrix-hal/examples/humidity/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-hal/examples/humidity/#overview","text":"The humidity sensor reports values for: Humidity Temperature","title":"Overview"},{"location":"matrix-hal/examples/humidity/#code-example","text":"Below is an example of how to interface with the humidity sensor in MATRIX HAL. Humidity sensor function references can be found here . The following section shows how to receive data from the humidity sensor. You can download this example here . The command below will compile the example. Be sure to pass in your C++ file and desired output file. g++ -o YOUR_OUTPUT_FILE YOUR_CPP_FILE -std=c++11 -lmatrix_creator_hal Include Statements To begin working with the humidity sensor you need to include these header files. \u0002wzxhzdk:1\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. \u0002wzxhzdk:2\u0003 Main Setup Now we will create our `HumidityData` and `HumiditySensor` object and use it to receive data from the humidity sensor. \u0002wzxhzdk:3\u0003","title":"Code Example"},{"location":"matrix-hal/examples/imu/","text":"Inertial Measurement Unit (IMU) HAL Example Device Compatibility Overview The IMU sensor reports values for: Yaw, Pitch, and Roll Acceleration for x , y , z axes Gyroscope for x , y , z axes Magnetometer for x , y , z axes Code Example Below is an example of how to interface with the IMU sensor in MATRIX HAL. IMU sensor function references can be found here . The following section shows how to receive data from the IMU sensor. You can download this example here . The command below will compile the example. Be sure to pass in your C++ file and desired output file. g++ -o YOUR_OUTPUT_FILE YOUR_CPP_FILE -std=c++11 -lmatrix_creator_hal Include Statements To begin working with the IMU sensor you need to include these header files. \u0002wzxhzdk:1\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. \u0002wzxhzdk:2\u0003 Main Setup Now we will create our `IMUData` and `IMUSensor` object and use it to receive data from the IMU sensor. \u0002wzxhzdk:3\u0003","title":"IMU"},{"location":"matrix-hal/examples/imu/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-hal/examples/imu/#overview","text":"The IMU sensor reports values for: Yaw, Pitch, and Roll Acceleration for x , y , z axes Gyroscope for x , y , z axes Magnetometer for x , y , z axes","title":"Overview"},{"location":"matrix-hal/examples/imu/#code-example","text":"Below is an example of how to interface with the IMU sensor in MATRIX HAL. IMU sensor function references can be found here . The following section shows how to receive data from the IMU sensor. You can download this example here . The command below will compile the example. Be sure to pass in your C++ file and desired output file. g++ -o YOUR_OUTPUT_FILE YOUR_CPP_FILE -std=c++11 -lmatrix_creator_hal Include Statements To begin working with the IMU sensor you need to include these header files. \u0002wzxhzdk:1\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. \u0002wzxhzdk:2\u0003 Main Setup Now we will create our `IMUData` and `IMUSensor` object and use it to receive data from the IMU sensor. \u0002wzxhzdk:3\u0003","title":"Code Example"},{"location":"matrix-hal/examples/microphone/","text":"Microphone Array HAL Example Device Compatibility Overview The microphone array interface supports: Accepting input from individual microphones Accepting input from beamformed microphone Device Pinouts : MATRIX Creator MATRIX Voice Code Examples Below are examples of how to interface with the microphone array in MATRIX HAL. Microphone array function references can be found here . The command below will compile each example. Be sure to pass in your C++ file and desired output file. g++ -o YOUR_OUTPUT_FILE YOUR_CPP_FILE -std=c++11 -lmatrix_creator_hal -lgflags Microphone Array Record to File The following section shows how to record data from the microphone array to a file. You can download this example here . > Beamformed microphone is channel 8 To convert the `.raw` files outputted by this example to playable `.wav` files run these commands, replacing `16000` with selected sampling rate. \u0002wzxhzdk:1\u0003 Include Statements To begin working with the Microphone Array you need to include these header files. \u0002wzxhzdk:2\u0003 Initial Variables These initial variables are used in the example. \u0002wzxhzdk:3\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. Also, parse command line flags and set user flags as variables. \u0002wzxhzdk:4\u0003 Main Setup Now we will create our `MicrophoneArray` object and use it to interface with the microphone array. \u0002wzxhzdk:5\u0003 Fir Filter Setup Now we will create our `MicrophoneCore` object and use it to enable the FIR filter. \u0002wzxhzdk:6\u0003 Microphone Input Now we will read microphone array data, send to a buffer, and write to file. \u0002wzxhzdk:7\u0003 Microphone Array Record to Pipe The following section shows how to record data from the microphone array to a linux FIFO pipe. You can download this example here . > When beamformed microphone (channel 8) is read from a FIFO pipe distortion may occur. The following commands copy a modified `asound.conf` file into `/etc/`, which allows `arecord` to record from the pipe. \u0002wzxhzdk:8\u0003 To record from microphone channel 0 for 5 seconds at 16KHz using `arecord`, run these commands. \u0002wzxhzdk:9\u0003 To stop the example from running, run this command. \u0002wzxhzdk:10\u0003 Include Statements To begin working with the Microphone Array you need to include these header files. \u0002wzxhzdk:11\u0003 Initial Variables These initial variables are used in the example. \u0002wzxhzdk:12\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. Also, parse command line flags and set user flags as variables. \u0002wzxhzdk:13\u0003 Main Setup Now we will create our `MicrophoneArray` object and use it to interface with the microphone array. \u0002wzxhzdk:14\u0003 Fir Filter Setup Now we will create our `MicrophoneCore` object and use it to enable the FIR filter. \u0002wzxhzdk:15\u0003 Microphone Input Now we will read microphone array data, send to a buffer, and write to a FIFO pipe. \u0002wzxhzdk:16\u0003","title":"Microphone"},{"location":"matrix-hal/examples/microphone/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-hal/examples/microphone/#overview","text":"The microphone array interface supports: Accepting input from individual microphones Accepting input from beamformed microphone Device Pinouts : MATRIX Creator MATRIX Voice","title":"Overview"},{"location":"matrix-hal/examples/microphone/#code-examples","text":"Below are examples of how to interface with the microphone array in MATRIX HAL. Microphone array function references can be found here . The command below will compile each example. Be sure to pass in your C++ file and desired output file. g++ -o YOUR_OUTPUT_FILE YOUR_CPP_FILE -std=c++11 -lmatrix_creator_hal -lgflags Microphone Array Record to File The following section shows how to record data from the microphone array to a file. You can download this example here . > Beamformed microphone is channel 8 To convert the `.raw` files outputted by this example to playable `.wav` files run these commands, replacing `16000` with selected sampling rate. \u0002wzxhzdk:1\u0003 Include Statements To begin working with the Microphone Array you need to include these header files. \u0002wzxhzdk:2\u0003 Initial Variables These initial variables are used in the example. \u0002wzxhzdk:3\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. Also, parse command line flags and set user flags as variables. \u0002wzxhzdk:4\u0003 Main Setup Now we will create our `MicrophoneArray` object and use it to interface with the microphone array. \u0002wzxhzdk:5\u0003 Fir Filter Setup Now we will create our `MicrophoneCore` object and use it to enable the FIR filter. \u0002wzxhzdk:6\u0003 Microphone Input Now we will read microphone array data, send to a buffer, and write to file. \u0002wzxhzdk:7\u0003 Microphone Array Record to Pipe The following section shows how to record data from the microphone array to a linux FIFO pipe. You can download this example here . > When beamformed microphone (channel 8) is read from a FIFO pipe distortion may occur. The following commands copy a modified `asound.conf` file into `/etc/`, which allows `arecord` to record from the pipe. \u0002wzxhzdk:8\u0003 To record from microphone channel 0 for 5 seconds at 16KHz using `arecord`, run these commands. \u0002wzxhzdk:9\u0003 To stop the example from running, run this command. \u0002wzxhzdk:10\u0003 Include Statements To begin working with the Microphone Array you need to include these header files. \u0002wzxhzdk:11\u0003 Initial Variables These initial variables are used in the example. \u0002wzxhzdk:12\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. Also, parse command line flags and set user flags as variables. \u0002wzxhzdk:13\u0003 Main Setup Now we will create our `MicrophoneArray` object and use it to interface with the microphone array. \u0002wzxhzdk:14\u0003 Fir Filter Setup Now we will create our `MicrophoneCore` object and use it to enable the FIR filter. \u0002wzxhzdk:15\u0003 Microphone Input Now we will read microphone array data, send to a buffer, and write to a FIFO pipe. \u0002wzxhzdk:16\u0003","title":"Code Examples"},{"location":"matrix-hal/examples/pressure/","text":"Pressure HAL Example Device Compatibility Overview The pressure sensor reports values for: Pressure Altitude Temperature Code Example Below is an example of how to interface with the pressure sensor in MATRIX HAL. Pressure sensor function references can be found here . The following section shows how to receive data from the pressure sensor. You can download this example here . The command below will compile the example. Be sure to pass in your C++ file and desired output file. g++ -o YOUR_OUTPUT_FILE YOUR_CPP_FILE -std=c++11 -lmatrix_creator_hal Include Statements To begin working with the pressure sensor you need to include these header files. \u0002wzxhzdk:1\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. \u0002wzxhzdk:2\u0003 Main Setup Now we will create our `PressureData` and `PressureSensor` object and use it to receive data from the pressure sensor. \u0002wzxhzdk:3\u0003","title":"Pressure"},{"location":"matrix-hal/examples/pressure/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-hal/examples/pressure/#overview","text":"The pressure sensor reports values for: Pressure Altitude Temperature","title":"Overview"},{"location":"matrix-hal/examples/pressure/#code-example","text":"Below is an example of how to interface with the pressure sensor in MATRIX HAL. Pressure sensor function references can be found here . The following section shows how to receive data from the pressure sensor. You can download this example here . The command below will compile the example. Be sure to pass in your C++ file and desired output file. g++ -o YOUR_OUTPUT_FILE YOUR_CPP_FILE -std=c++11 -lmatrix_creator_hal Include Statements To begin working with the pressure sensor you need to include these header files. \u0002wzxhzdk:1\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. \u0002wzxhzdk:2\u0003 Main Setup Now we will create our `PressureData` and `PressureSensor` object and use it to receive data from the pressure sensor. \u0002wzxhzdk:3\u0003","title":"Code Example"},{"location":"matrix-hal/examples/uv/","text":"UV HAL Example Device Compatibility Overview The UV sensor reports values for: UV Index scale used in the United States, conforms with international guidelines for UVI reporting established by the World Health Organization. From UV Index Scale Code Example Below is an example of how to interface with the UV sensor in MATRIX HAL. UV sensor function references can be found here . The following section shows how to receive data from the UV sensor. You can download this example here . The command below will compile the example. Be sure to pass in your C++ file and desired output file. g++ -o YOUR_OUTPUT_FILE YOUR_CPP_FILE -std=c++11 -lmatrix_creator_hal Include Statements To begin working with the UV sensor you need to include these header files. \u0002wzxhzdk:1\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. \u0002wzxhzdk:2\u0003 Main Setup Now we will create our `UVData` and `UVSensor` object and use it to receive data from the UV sensor. \u0002wzxhzdk:3\u0003","title":"UV"},{"location":"matrix-hal/examples/uv/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-hal/examples/uv/#overview","text":"The UV sensor reports values for: UV Index scale used in the United States, conforms with international guidelines for UVI reporting established by the World Health Organization. From UV Index Scale","title":"Overview"},{"location":"matrix-hal/examples/uv/#code-example","text":"Below is an example of how to interface with the UV sensor in MATRIX HAL. UV sensor function references can be found here . The following section shows how to receive data from the UV sensor. You can download this example here . The command below will compile the example. Be sure to pass in your C++ file and desired output file. g++ -o YOUR_OUTPUT_FILE YOUR_CPP_FILE -std=c++11 -lmatrix_creator_hal Include Statements To begin working with the UV sensor you need to include these header files. \u0002wzxhzdk:1\u0003 Initial Setup You'll then need to setup `MatrixIOBus` in order to communicate with the hardware on your MATRIX device. \u0002wzxhzdk:2\u0003 Main Setup Now we will create our `UVData` and `UVSensor` object and use it to receive data from the UV sensor. \u0002wzxhzdk:3\u0003","title":"Code Example"},{"location":"matrix-hal/getting-started/","text":"Getting Started We recommend beginners install MATRIX HAL from package. Installation From Package Learn how to install MATRIX HAL from package. Installation From Source Learn how to install MATRIX HAL from source. Compiling Your Program Create and compile a sample program for your MATRIX device.","title":"Index"},{"location":"matrix-hal/getting-started/#getting-started","text":"","title":"Getting Started"},{"location":"matrix-hal/getting-started/installation-package/","text":"Installing MATRIX HAL From Package Make sure you have setup your MATRIX Creator or MATRIX Voice before continuing. Before starting, ensure you have access to the terminal of your Raspberry Pi via an SSH-session or connect a screen, mouse, and keyboard. Once you've opened the terminal, insert and run the following commands. Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the the MATRIX HAL packages. sudo apt-get install matrixio-creator-init libmatrixio-creator-hal libmatrixio-creator-hal-dev Reboot your device. sudo reboot Helpful Information MATRIX HAL header files are installed in /usr/include/matrix_hal . The compiled MATRIX HAL library file is installed in /usr/lib/libmatrix_creator_hal.so . Next Steps Now that MATRIX HAL is properly installed, learn how to create and compile your own MATRIX programs here .","title":"Installation From Package"},{"location":"matrix-hal/getting-started/installation-package/#installing-matrix-hal-from-package","text":"Make sure you have setup your MATRIX Creator or MATRIX Voice before continuing. Before starting, ensure you have access to the terminal of your Raspberry Pi via an SSH-session or connect a screen, mouse, and keyboard. Once you've opened the terminal, insert and run the following commands. Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the the MATRIX HAL packages. sudo apt-get install matrixio-creator-init libmatrixio-creator-hal libmatrixio-creator-hal-dev Reboot your device. sudo reboot","title":"Installing MATRIX HAL From Package"},{"location":"matrix-hal/getting-started/installation-package/#helpful-information","text":"MATRIX HAL header files are installed in /usr/include/matrix_hal . The compiled MATRIX HAL library file is installed in /usr/lib/libmatrix_creator_hal.so .","title":"Helpful Information"},{"location":"matrix-hal/getting-started/installation-package/#next-steps","text":"Now that MATRIX HAL is properly installed, learn how to create and compile your own MATRIX programs here .","title":"Next Steps"},{"location":"matrix-hal/getting-started/installation-source/","text":"Installing MATRIX HAL From Source Make sure you have setup your MATRIX Creator or MATRIX Voice before continuing. Before starting, ensure you have access to the terminal of your Raspberry Pi via an SSH-session or connect a screen, mouse, and keyboard. Once you've opened the terminal, insert and run the following commands. Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the MATRIX init package and tools needed to build MATRIX HAL. sudo apt-get install cmake g++ git libfftw3-dev wiringpi libgflags-dev matrixio-creator-init Clone, build, and install MATRIX HAL. cd ~/ git clone https://github.com/matrix-io/matrix-creator-hal.git cd matrix-creator-hal mkdir build cd build cmake .. make -j4 sudo make install Reboot your device. sudo reboot Helpful Information MATRIX HAL header files are installed in /usr/local/include/matrix_hal . The compiled MATRIX HAL library file is installed in /usr/local/lib/libmatrix_creator_hal.so . Next Steps Now that MATRIX HAL is properly installed, learn how to create and compile your own MATRIX programs here .","title":"Installation From Source"},{"location":"matrix-hal/getting-started/installation-source/#installing-matrix-hal-from-source","text":"Make sure you have setup your MATRIX Creator or MATRIX Voice before continuing. Before starting, ensure you have access to the terminal of your Raspberry Pi via an SSH-session or connect a screen, mouse, and keyboard. Once you've opened the terminal, insert and run the following commands. Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the MATRIX init package and tools needed to build MATRIX HAL. sudo apt-get install cmake g++ git libfftw3-dev wiringpi libgflags-dev matrixio-creator-init Clone, build, and install MATRIX HAL. cd ~/ git clone https://github.com/matrix-io/matrix-creator-hal.git cd matrix-creator-hal mkdir build cd build cmake .. make -j4 sudo make install Reboot your device. sudo reboot","title":"Installing MATRIX HAL From Source"},{"location":"matrix-hal/getting-started/installation-source/#helpful-information","text":"MATRIX HAL header files are installed in /usr/local/include/matrix_hal . The compiled MATRIX HAL library file is installed in /usr/local/lib/libmatrix_creator_hal.so .","title":"Helpful Information"},{"location":"matrix-hal/getting-started/installation-source/#next-steps","text":"Now that MATRIX HAL is properly installed, learn how to create and compile your own MATRIX programs here .","title":"Next Steps"},{"location":"matrix-hal/getting-started/programs/","text":"Introduction Programs created with MATRIX HAL allow you to directly access sensors and components on the MATRIX device through C++. This guide will show you how to create and run an LED demo in MATRIX HAL. The final result being a rainbow LED sequence. Creating A Program Making Your Project Directory Use the following commands to create a folder to hold your MATRIX HAL projects, in the home directory ~/ of your MATRIX device. cd ~/ mkdir matrix-hal-project cd matrix-hal-project Create a file called app.cpp in your project folder, and paste the code below. The following code turns the Everloop rainbow for 10 seconds. /* * Everloop rainbow example */ ///////////////////////// // INCLUDE STATEMENTS // /////////////////////// // System calls #include unistd.h // Input/output streams and functions #include iostream // Included for sin() function. #include cmath // Interfaces with Everloop #include matrix_hal/everloop.h // Holds data for Everloop #include matrix_hal/everloop_image.h // Communicates with MATRIX device #include matrix_hal/matrixio_bus.h int main() { //////////////////// // INITIAL SETUP // ////////////////// // Create MatrixIOBus object for hardware communication matrix_hal::MatrixIOBus bus; // Initialize bus and exit program if error occurs if (!bus.Init()) return false; ///////////////// // MAIN SETUP // /////////////// // Holds the number of LEDs on MATRIX device int ledCount = bus.MatrixLeds(); // Create EverloopImage object, with size of ledCount matrix_hal::EverloopImage everloop_image(ledCount); // Create Everloop object matrix_hal::Everloop everloop; // Set everloop to use MatrixIOBus bus everloop.Setup( bus); // Variables used for sine wave rainbow logic float counter = 0; const float freq = 0.375; // 10 sec loop for rainbow effect 250*40000 microsec = 10 sec for (int i = 0; i = 250; i++) { // For each led in everloop_image.leds, set led value for (matrix_hal::LedValue led : everloop_image.leds) { // Sine waves 120 degrees out of phase for rainbow led.red = (std::sin(freq * counter + (M_PI / 180 * 240)) * 155 + 100) / 10; led.green = (std::sin(freq * counter + (M_PI / 180 * 120)) * 155 + 100) / 10; led.blue = (std::sin(freq * counter + 0) * 155 + 100) / 10; // If MATRIX Creator, increment by 0.51 if (ledCount == 35) { counter = counter + 0.51; } // If MATRIX Voice, increment by 1.01 if (ledCount == 18) { counter = counter + 1.01; } } // Updates the LEDs everloop.Write( everloop_image); // If i is 0 (first run) if (i == 0) { // Output everloop status to console std::cout Everloop set to rainbow for 10 seconds. std::endl; } // If i is cleanly divisible by 25 if ((i % 25) == 0) { std::cout Time remaining (s) : 10 - (i / 25) std::endl; } // Sleep for 40000 microseconds usleep(40000); } // Updates the Everloop on the MATRIX device everloop.Write( everloop_image); // For each led in everloop_image.leds, set led value to 0 for (matrix_hal::LedValue led : everloop_image.leds) { // Turn off Everloop led.red = 0; led.green = 0; led.blue = 0; led.white = 0; } // Updates the Everloop on the MATRIX device everloop.Write( everloop_image); return 0; } Compiling your Program The command below will use g++ to link the libmatrix_creator_hal.so library file when compiling your program. g++ -o app app.cpp -std=c++11 -lmatrix_creator_hal Running your Program Run the following command to start the demo program. cd ~/matrix-hal-project ./app Result Next Steps Now that everything is properly installed, view our function references to see what you can do with MATRIX HAL, or view the code examples .","title":"Compiling Programs"},{"location":"matrix-hal/getting-started/programs/#creating-a-program","text":"","title":"Creating A Program"},{"location":"matrix-hal/getting-started/programs/#compiling-your-program","text":"The command below will use g++ to link the libmatrix_creator_hal.so library file when compiling your program. g++ -o app app.cpp -std=c++11 -lmatrix_creator_hal","title":"Compiling your Program"},{"location":"matrix-hal/getting-started/programs/#running-your-program","text":"Run the following command to start the demo program. cd ~/matrix-hal-project ./app","title":"Running your Program"},{"location":"matrix-hal/getting-started/programs/#next-steps","text":"Now that everything is properly installed, view our function references to see what you can do with MATRIX HAL, or view the code examples .","title":"Next Steps"},{"location":"matrix-hal/reference/","text":"MATRIX HAL References Everloop LED interface. Humidity Humidity and temperature measurement. IMU Inertial Measurement Unit. Pressure Pressure, altitude and temperature measurement. UV Ultraviolet light sensor. GPIO General Purpose Input/Output. Microphone Microphone Array.","title":"Index"},{"location":"matrix-hal/reference/#matrix-hal-references","text":"","title":"MATRIX HAL References"},{"location":"matrix-hal/reference/everloop/","text":"Everloop Device Compatibility Overview The Everloop interface supports: Setting the RGBW colors for each individual LED. References Below is the overview of the Everloop implementation. Code examples can be found here . These header files are required to use the Everloop. // Interfaces with Everloop #include matrix_hal/everloop.h // Holds data for Everloop #include matrix_hal/everloop_image.h // Communicates with MATRIX device #include matrix_hal/matrixio_bus.h EverloopImage `EverloopImage` is a required **object** that contains an array of `LedValue` objects. The `EverloopImage` constructor takes in an integer representing the amount of RGBW leds your MATRIX device has. The MatrixIOBus function `bus.MatrixLeds` outputs the number of leds on your creator. \u0002wzxhzdk:1\u0003 `EverloopImage` holds an array full of `LedValue` objects. The `LedValue` object contains the properties `red`, `green`, `blue`, `white`. These color properties accept an RGBW integer between 0-255. The following code shows how to set each led in everloop_image to green. \u0002wzxhzdk:2\u0003 Everloop `Everloop` is a required **object** that contains functions to interface with the Everloop on the MATRIX device. \u0002wzxhzdk:3\u0003 The functions below are part of `Everloop`. .Setup `Setup` is a **function** that takes `MatrixIOBus` object as parameter and sets that object as the bus to use for communicating with MATRIX device. \u0002wzxhzdk:4\u0003 \u0002wzxhzdk:5\u0003 .Write `Write` is a **function** that takes an `EverloopImage` object as a parameter and updates the Everloop on the MATRIX device. \u0002wzxhzdk:6\u0003 \u0002wzxhzdk:7\u0003","title":"Everloop"},{"location":"matrix-hal/reference/everloop/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-hal/reference/everloop/#overview","text":"The Everloop interface supports: Setting the RGBW colors for each individual LED.","title":"Overview"},{"location":"matrix-hal/reference/everloop/#references","text":"Below is the overview of the Everloop implementation. Code examples can be found here . These header files are required to use the Everloop. // Interfaces with Everloop #include matrix_hal/everloop.h // Holds data for Everloop #include matrix_hal/everloop_image.h // Communicates with MATRIX device #include matrix_hal/matrixio_bus.h EverloopImage `EverloopImage` is a required **object** that contains an array of `LedValue` objects. The `EverloopImage` constructor takes in an integer representing the amount of RGBW leds your MATRIX device has. The MatrixIOBus function `bus.MatrixLeds` outputs the number of leds on your creator. \u0002wzxhzdk:1\u0003 `EverloopImage` holds an array full of `LedValue` objects. The `LedValue` object contains the properties `red`, `green`, `blue`, `white`. These color properties accept an RGBW integer between 0-255. The following code shows how to set each led in everloop_image to green. \u0002wzxhzdk:2\u0003 Everloop `Everloop` is a required **object** that contains functions to interface with the Everloop on the MATRIX device. \u0002wzxhzdk:3\u0003 The functions below are part of `Everloop`. .Setup `Setup` is a **function** that takes `MatrixIOBus` object as parameter and sets that object as the bus to use for communicating with MATRIX device. \u0002wzxhzdk:4\u0003 \u0002wzxhzdk:5\u0003 .Write `Write` is a **function** that takes an `EverloopImage` object as a parameter and updates the Everloop on the MATRIX device. \u0002wzxhzdk:6\u0003 \u0002wzxhzdk:7\u0003","title":"References"},{"location":"matrix-hal/reference/gpio/","text":"General Purpose Input Output (GPIO) Device Compatibility Overview The GPIO interface supports: Pin I/O input Pin I/O output Pin PWM output Device Pinouts : MATRIX Creator MATRIX Voice References Below is the overview of the GPIO implementation. Code examples can be found here . These header files are required to use GPIO. // Interfaces with GPIO #include matrix_hal/gpio_control.h // Communicates with MATRIX device #include matrix_hal/matrixio_bus.h GPIOControl `GPIOControl` is a required **object** that contains functions to interface with GPIO. \u0002wzxhzdk:1\u0003 The functions below are part of `GPIOControl`. .Setup `Setup` is a **function** that takes a `MatrixIOBus` object as a parameter and sets that object as the bus to use for communicating with MATRIX device. \u0002wzxhzdk:2\u0003 \u0002wzxhzdk:3\u0003 .Banks `Banks` is a **function** that returns a `banks_` array of `GPIOBank` objects. \u0002wzxhzdk:4\u0003 \u0002wzxhzdk:5\u0003 .SetMode `SetMode` is a **function** that sets GPIO pin(s) to output or input. `SetMode` is overloaded, and there are two definitions for the function. For setting single GPIO pin. \u0002wzxhzdk:6\u0003 \u0002wzxhzdk:7\u0003 For setting multiple GPIO pins. \u0002wzxhzdk:8\u0003 \u0002wzxhzdk:9\u0003 .SetFunction `SetFunction` is a **function** that sets a single GPIO pin to I/O or PWM mode. \u0002wzxhzdk:10\u0003 \u0002wzxhzdk:11\u0003 .GetGPIOValue `GetGPIOValue` is a **function** that returns a GPIO value. \u0002wzxhzdk:12\u0003 \u0002wzxhzdk:13\u0003 .GetGPIOValues `GetGPIOValues` is a **function** that returns all GPIO values, each bit of the returned 16bit integer represents a pin. \u0002wzxhzdk:14\u0003 \u0002wzxhzdk:15\u0003 .SetGPIOValue `SetGPIOValue` is a **function** that sets a GPIO value. \u0002wzxhzdk:16\u0003 \u0002wzxhzdk:17\u0003 .SetGPIOValues `SetGPIOValues` is a **function** that sets multiple GPIO values. \u0002wzxhzdk:18\u0003 \u0002wzxhzdk:19\u0003 .SetPrescaler `SetPrescaler` is a **function** that sets the prescaler for the FPGA clock. \u0002wzxhzdk:20\u0003 \u0002wzxhzdk:21\u0003 .Set9GServoAngle `Set9GServoAngle` is a **function** that sets a servo angle. It is based on SG90 servo calibration. \u0002wzxhzdk:22\u0003 \u0002wzxhzdk:23\u0003 .SetServoAngle `SetServoAngle` is a **function** that sets a servo angle. It is based on the min_pulse_ms entered. \u0002wzxhzdk:24\u0003 \u0002wzxhzdk:25\u0003 .SetPWM `SetPWM` is a **function** that sets a PWM output. \u0002wzxhzdk:26\u0003 \u0002wzxhzdk:27\u0003 GPIOBank `GPIOBank` is an **object** that contains functions to interface with GPIO PWM. `GPIOControl` contains an array of `GPIOBank` objects, called `banks`_ PWM Frequency is set by bank. A bank is a set of 4 pins, starting from pin 0 and going in order. Bank 0 is pin 0-3, Bank 1 is pin 4-7 etc. The functions below are part of `GPIOBank`. .SetPeriod `SetPeriod` is a **function** that sets the PWM period. \u0002wzxhzdk:28\u0003 \u0002wzxhzdk:29\u0003 .SetDuty `SetDuty` is a **function** that sets the PWM duty. \u0002wzxhzdk:30\u0003 \u0002wzxhzdk:31\u0003 .SetupTimer >Under Maintenance `SetupTimer` is a **function** that sets up the timer. \u0002wzxhzdk:32\u0003 .GetTimerCounter >Under Maintenance `GetTimerCounter` is a **function** that returns the timer counter. \u0002wzxhzdk:33\u0003","title":"GPIO"},{"location":"matrix-hal/reference/gpio/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-hal/reference/gpio/#overview","text":"The GPIO interface supports: Pin I/O input Pin I/O output Pin PWM output Device Pinouts : MATRIX Creator MATRIX Voice","title":"Overview"},{"location":"matrix-hal/reference/gpio/#references","text":"Below is the overview of the GPIO implementation. Code examples can be found here . These header files are required to use GPIO. // Interfaces with GPIO #include matrix_hal/gpio_control.h // Communicates with MATRIX device #include matrix_hal/matrixio_bus.h GPIOControl `GPIOControl` is a required **object** that contains functions to interface with GPIO. \u0002wzxhzdk:1\u0003 The functions below are part of `GPIOControl`. .Setup `Setup` is a **function** that takes a `MatrixIOBus` object as a parameter and sets that object as the bus to use for communicating with MATRIX device. \u0002wzxhzdk:2\u0003 \u0002wzxhzdk:3\u0003 .Banks `Banks` is a **function** that returns a `banks_` array of `GPIOBank` objects. \u0002wzxhzdk:4\u0003 \u0002wzxhzdk:5\u0003 .SetMode `SetMode` is a **function** that sets GPIO pin(s) to output or input. `SetMode` is overloaded, and there are two definitions for the function. For setting single GPIO pin. \u0002wzxhzdk:6\u0003 \u0002wzxhzdk:7\u0003 For setting multiple GPIO pins. \u0002wzxhzdk:8\u0003 \u0002wzxhzdk:9\u0003 .SetFunction `SetFunction` is a **function** that sets a single GPIO pin to I/O or PWM mode. \u0002wzxhzdk:10\u0003 \u0002wzxhzdk:11\u0003 .GetGPIOValue `GetGPIOValue` is a **function** that returns a GPIO value. \u0002wzxhzdk:12\u0003 \u0002wzxhzdk:13\u0003 .GetGPIOValues `GetGPIOValues` is a **function** that returns all GPIO values, each bit of the returned 16bit integer represents a pin. \u0002wzxhzdk:14\u0003 \u0002wzxhzdk:15\u0003 .SetGPIOValue `SetGPIOValue` is a **function** that sets a GPIO value. \u0002wzxhzdk:16\u0003 \u0002wzxhzdk:17\u0003 .SetGPIOValues `SetGPIOValues` is a **function** that sets multiple GPIO values. \u0002wzxhzdk:18\u0003 \u0002wzxhzdk:19\u0003 .SetPrescaler `SetPrescaler` is a **function** that sets the prescaler for the FPGA clock. \u0002wzxhzdk:20\u0003 \u0002wzxhzdk:21\u0003 .Set9GServoAngle `Set9GServoAngle` is a **function** that sets a servo angle. It is based on SG90 servo calibration. \u0002wzxhzdk:22\u0003 \u0002wzxhzdk:23\u0003 .SetServoAngle `SetServoAngle` is a **function** that sets a servo angle. It is based on the min_pulse_ms entered. \u0002wzxhzdk:24\u0003 \u0002wzxhzdk:25\u0003 .SetPWM `SetPWM` is a **function** that sets a PWM output. \u0002wzxhzdk:26\u0003 \u0002wzxhzdk:27\u0003 GPIOBank `GPIOBank` is an **object** that contains functions to interface with GPIO PWM. `GPIOControl` contains an array of `GPIOBank` objects, called `banks`_ PWM Frequency is set by bank. A bank is a set of 4 pins, starting from pin 0 and going in order. Bank 0 is pin 0-3, Bank 1 is pin 4-7 etc. The functions below are part of `GPIOBank`. .SetPeriod `SetPeriod` is a **function** that sets the PWM period. \u0002wzxhzdk:28\u0003 \u0002wzxhzdk:29\u0003 .SetDuty `SetDuty` is a **function** that sets the PWM duty. \u0002wzxhzdk:30\u0003 \u0002wzxhzdk:31\u0003 .SetupTimer >Under Maintenance `SetupTimer` is a **function** that sets up the timer. \u0002wzxhzdk:32\u0003 .GetTimerCounter >Under Maintenance `GetTimerCounter` is a **function** that returns the timer counter. \u0002wzxhzdk:33\u0003","title":"References"},{"location":"matrix-hal/reference/humidity/","text":"Humidity Device Compatibility Overview The humidity sensor reports values for: Humidity Temperature References Below is the overview of the humidity sensor implementation. Code example can be found here . These header files are required to use the humidity sensor. // Interfaces with humidity sensor #include matrix_hal/humidity_sensor.h // Holds data from humidity sensor #include matrix_hal/humidity_data.h // Communicates with MATRIX device #include matrix_hal/matrixio_bus.h HumidityData `HumidityData` is a required **object** that contains the humidity sensor's supported data parameters. \u0002wzxhzdk:1\u0003 The following code accesses the parameters of `HumidityData`. \u0002wzxhzdk:2\u0003 HumiditySensor `HumiditySensor` is a required **object** that contains functions to interface with the humidity sensor. \u0002wzxhzdk:3\u0003 The functions below are part of `HumiditySensor`. .Setup `Setup` is a **function** that takes a `MatrixIOBus` object as a parameter and sets that object as the bus to use for communicating with MATRIX device. \u0002wzxhzdk:4\u0003 \u0002wzxhzdk:5\u0003 .Read `Read` is a **function** that takes a `HumidityData` object as a parameter and writes the current humidity sensor data into the `HumidityData` object. \u0002wzxhzdk:6\u0003 \u0002wzxhzdk:7\u0003","title":"Humidity"},{"location":"matrix-hal/reference/humidity/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-hal/reference/humidity/#overview","text":"The humidity sensor reports values for: Humidity Temperature","title":"Overview"},{"location":"matrix-hal/reference/humidity/#references","text":"Below is the overview of the humidity sensor implementation. Code example can be found here . These header files are required to use the humidity sensor. // Interfaces with humidity sensor #include matrix_hal/humidity_sensor.h // Holds data from humidity sensor #include matrix_hal/humidity_data.h // Communicates with MATRIX device #include matrix_hal/matrixio_bus.h HumidityData `HumidityData` is a required **object** that contains the humidity sensor's supported data parameters. \u0002wzxhzdk:1\u0003 The following code accesses the parameters of `HumidityData`. \u0002wzxhzdk:2\u0003 HumiditySensor `HumiditySensor` is a required **object** that contains functions to interface with the humidity sensor. \u0002wzxhzdk:3\u0003 The functions below are part of `HumiditySensor`. .Setup `Setup` is a **function** that takes a `MatrixIOBus` object as a parameter and sets that object as the bus to use for communicating with MATRIX device. \u0002wzxhzdk:4\u0003 \u0002wzxhzdk:5\u0003 .Read `Read` is a **function** that takes a `HumidityData` object as a parameter and writes the current humidity sensor data into the `HumidityData` object. \u0002wzxhzdk:6\u0003 \u0002wzxhzdk:7\u0003","title":"References"},{"location":"matrix-hal/reference/imu/","text":"Inertial Measurement Unit (IMU) Device Compatibility Overview The IMU sensor reports values for: Yaw, Pitch, and Roll Acceleration for x , y , z axes Gyroscope for x , y , z axes Magnetometer for x , y , z axes References Below is the overview of the IMU sensor implementation. Code example can be found here . These header files are required to use the IMU sensor. // Interfaces with IMU sensor #include matrix_hal/imu_sensor.h // Holds data from IMU sensor #include matrix_hal/imu_data.h // Communicates with MATRIX device #include matrix_hal/matrixio_bus.h IMUData `IMUData` is a required **object** that contains the IMU sensor's supported data parameters. \u0002wzxhzdk:1\u0003 The following code accesses the parameters of `IMUData`. \u0002wzxhzdk:2\u0003 IMUSensor `IMUSensor` is a required **object** that contains functions to interface with the IMU sensor. \u0002wzxhzdk:3\u0003 The functions below are part of `IMUSensor`. .Setup `Setup` is a **function** that takes a `MatrixIOBus` object as a parameter and sets that object as the bus to use for communicating with MATRIX device. \u0002wzxhzdk:4\u0003 \u0002wzxhzdk:5\u0003 .Read `Read` is a **function** that takes an `IMUData` object as a parameter and writes the current IMU sensor data into the `IMUData` object. \u0002wzxhzdk:6\u0003 \u0002wzxhzdk:7\u0003","title":"IMU"},{"location":"matrix-hal/reference/imu/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-hal/reference/imu/#overview","text":"The IMU sensor reports values for: Yaw, Pitch, and Roll Acceleration for x , y , z axes Gyroscope for x , y , z axes Magnetometer for x , y , z axes","title":"Overview"},{"location":"matrix-hal/reference/imu/#references","text":"Below is the overview of the IMU sensor implementation. Code example can be found here . These header files are required to use the IMU sensor. // Interfaces with IMU sensor #include matrix_hal/imu_sensor.h // Holds data from IMU sensor #include matrix_hal/imu_data.h // Communicates with MATRIX device #include matrix_hal/matrixio_bus.h IMUData `IMUData` is a required **object** that contains the IMU sensor's supported data parameters. \u0002wzxhzdk:1\u0003 The following code accesses the parameters of `IMUData`. \u0002wzxhzdk:2\u0003 IMUSensor `IMUSensor` is a required **object** that contains functions to interface with the IMU sensor. \u0002wzxhzdk:3\u0003 The functions below are part of `IMUSensor`. .Setup `Setup` is a **function** that takes a `MatrixIOBus` object as a parameter and sets that object as the bus to use for communicating with MATRIX device. \u0002wzxhzdk:4\u0003 \u0002wzxhzdk:5\u0003 .Read `Read` is a **function** that takes an `IMUData` object as a parameter and writes the current IMU sensor data into the `IMUData` object. \u0002wzxhzdk:6\u0003 \u0002wzxhzdk:7\u0003","title":"References"},{"location":"matrix-hal/reference/microphone/","text":"Microphone Array Device Compatibility Overview The microphone array interface supports: Accepting input from individual microphones Accepting input from beamformed microphone References Below is the overview of the microphone array implementation. Code examples can be found here . These header files are required to use the microphone array. // Interfaces with microphone array #include matrix_hal/microphone_array.h // Enables using FIR filter with microphone array #include matrix_hal/microphone_core.h // Communicates with MATRIX device #include matrix_hal/matrixio_bus.h MicrophoneArray `MicrophoneArray` is a required **object** that contains functions to interface with the microphone array . \u0002wzxhzdk:1\u0003 The functions below are part of `MicrophoneArray`. .Setup `Setup` is a **function** that takes a `MatrixIOBus` object as a parameter and sets that object as the bus to use for communicating with MATRIX device. \u0002wzxhzdk:2\u0003 \u0002wzxhzdk:3\u0003 .Read `Read` is a **function** that outputs microphone array data to the `delayed_data_` array and the `beamformed_` array in the `MicrophoneArray` object. \u0002wzxhzdk:4\u0003 \u0002wzxhzdk:5\u0003 .SamplingRate `SamplingRate` is a **function** that returns the `sampling_frequency_` value in the `MicrophoneArray` object. \u0002wzxhzdk:6\u0003 \u0002wzxhzdk:7\u0003 .Gain `Gain` is a **function** that returns the `gain_` value in the `MicrophoneArray` object. \u0002wzxhzdk:8\u0003 \u0002wzxhzdk:9\u0003 .SetSamplingRate `SetSamplingRate` is a **function** that sets the `sampling_frequency_` value in the `MicrophoneArray` object and sends it to the microphone array. \u0002wzxhzdk:10\u0003 \u0002wzxhzdk:11\u0003 .SetGain `SetGain` is a **function** that sets the `gain_` value in the `MicrophoneArray` object and sends it to the microphone array. \u0002wzxhzdk:12\u0003 \u0002wzxhzdk:13\u0003 .GetSamplingRate `GetSamplingRate` is a **function** that gets the sampling rate value from the microphone array and saves it in the `MicrophoneArray` object as value `sampling_frequency_`. \u0002wzxhzdk:14\u0003 \u0002wzxhzdk:15\u0003 .GetGain `GetGain` is a **function** that gets the gain value from the microphone array and saves it in the `MicrophoneArray` object as value `gain_`. \u0002wzxhzdk:16\u0003 \u0002wzxhzdk:17\u0003 .ReadConfValues `ReadConfValues` is a **function** that runs both the `GetGain` and `GetSamplingRate` functions. This updates the `gain_` and the `sampling_frequency_` values in the `MicrophoneArray' object with values from the microphone array. \u0002wzxhzdk:18\u0003 \u0002wzxhzdk:19\u0003 .ShowConfiguration `ShowConfiguration` is a **function** that outputs the `gain_` and `sampling_frequency_` values in the `MicrophoneArray' object. \u0002wzxhzdk:20\u0003 \u0002wzxhzdk:21\u0003 \u0002wzxhzdk:22\u0003 .Channels `Channels` is a **function** that returns the number of microphone channels. \u0002wzxhzdk:23\u0003 \u0002wzxhzdk:24\u0003 .NumberOfSamples `NumberOfSamples` is a **function** that returns the number of samples. \u0002wzxhzdk:25\u0003 \u0002wzxhzdk:26\u0003 .At `At` is a **function** that returns microphone data from the `delayed_data_` array. The `Read` function populates the `delayed_data_` array. \u0002wzxhzdk:27\u0003 \u0002wzxhzdk:28\u0003 .Beam `Beam` is a **function** that returns beamformed microphone data from the `beamformed_` array. The `Read` function populates the `beamformed_` array. \u0002wzxhzdk:29\u0003 \u0002wzxhzdk:30\u0003 .CalculateDelays `CalculateDelays` is a **function** that calculates and sets up delays for beamforming. \u0002wzxhzdk:31\u0003 \u0002wzxhzdk:32\u0003 MicrophoneCore `MicrophoneCore` is an optional **object** that contains functions to enable using a FIR filter with microphone array. It accepts a `MicrophoneArray` object in it's constructor. \u0002wzxhzdk:33\u0003 \u0002wzxhzdk:34\u0003 The functions below are part of `MicrophoneCore`. .Setup `Setup` is a **function** that takes a `MatrixIOBus` object as a parameter and sets that object as the bus to use for communicating with MATRIX device. It also sets up the FIR filter by calling `SelectFIRCoeff( _default[0])`. \u0002wzxhzdk:35\u0003 \u0002wzxhzdk:36\u0003 .SetFIRCoeff `SetFIRCoeff` is a **function** that sends the `fir_coeff_` array in the `MicrophoneCore` object to the FPGA. \u0002wzxhzdk:37\u0003 \u0002wzxhzdk:38\u0003 .SetCustomFIRCoeff `SetCustomFIRCoeff` is a **function** that sets the `fir_coeff_` array in the `MicrophoneCore` object. If input is valid then the function also calls `SetFIRCoeff` to send the `fir_coeff_` array in the `MicrophoneCore` object to the FPGA. \u0002wzxhzdk:39\u0003 \u0002wzxhzdk:40\u0003 .SelectFIRCoeff `SelectFIRCoeff` is a **function** that sets the `fir_coeff_` array in the `MicrophoneCore` object. If input is valid then the function also calls `SetFIRCoeff` to send the `fir_coeff_` array in the `MicrophoneCore` object to the FPGA. This function accepts a FIRCoeff struct, which is defined below. \u0002wzxhzdk:41\u0003 \u0002wzxhzdk:42\u0003 \u0002wzxhzdk:43\u0003 Provided FIR Filters A FIR filter is provided in `matrix_hal/microphone_core_fir.h`. This filter provided is in the form of a FIRCoeff struct, which is defined below. \u0002wzxhzdk:44\u0003 To use the provided FIR filter the `SelectFIRCoeff` function is used to set it, then the `SetFIRCoeff` function is used to send it to the FPGA. \u0002wzxhzdk:45\u0003","title":"Microphone"},{"location":"matrix-hal/reference/microphone/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-hal/reference/microphone/#overview","text":"The microphone array interface supports: Accepting input from individual microphones Accepting input from beamformed microphone","title":"Overview"},{"location":"matrix-hal/reference/microphone/#references","text":"Below is the overview of the microphone array implementation. Code examples can be found here . These header files are required to use the microphone array. // Interfaces with microphone array #include matrix_hal/microphone_array.h // Enables using FIR filter with microphone array #include matrix_hal/microphone_core.h // Communicates with MATRIX device #include matrix_hal/matrixio_bus.h MicrophoneArray `MicrophoneArray` is a required **object** that contains functions to interface with the microphone array . \u0002wzxhzdk:1\u0003 The functions below are part of `MicrophoneArray`. .Setup `Setup` is a **function** that takes a `MatrixIOBus` object as a parameter and sets that object as the bus to use for communicating with MATRIX device. \u0002wzxhzdk:2\u0003 \u0002wzxhzdk:3\u0003 .Read `Read` is a **function** that outputs microphone array data to the `delayed_data_` array and the `beamformed_` array in the `MicrophoneArray` object. \u0002wzxhzdk:4\u0003 \u0002wzxhzdk:5\u0003 .SamplingRate `SamplingRate` is a **function** that returns the `sampling_frequency_` value in the `MicrophoneArray` object. \u0002wzxhzdk:6\u0003 \u0002wzxhzdk:7\u0003 .Gain `Gain` is a **function** that returns the `gain_` value in the `MicrophoneArray` object. \u0002wzxhzdk:8\u0003 \u0002wzxhzdk:9\u0003 .SetSamplingRate `SetSamplingRate` is a **function** that sets the `sampling_frequency_` value in the `MicrophoneArray` object and sends it to the microphone array. \u0002wzxhzdk:10\u0003 \u0002wzxhzdk:11\u0003 .SetGain `SetGain` is a **function** that sets the `gain_` value in the `MicrophoneArray` object and sends it to the microphone array. \u0002wzxhzdk:12\u0003 \u0002wzxhzdk:13\u0003 .GetSamplingRate `GetSamplingRate` is a **function** that gets the sampling rate value from the microphone array and saves it in the `MicrophoneArray` object as value `sampling_frequency_`. \u0002wzxhzdk:14\u0003 \u0002wzxhzdk:15\u0003 .GetGain `GetGain` is a **function** that gets the gain value from the microphone array and saves it in the `MicrophoneArray` object as value `gain_`. \u0002wzxhzdk:16\u0003 \u0002wzxhzdk:17\u0003 .ReadConfValues `ReadConfValues` is a **function** that runs both the `GetGain` and `GetSamplingRate` functions. This updates the `gain_` and the `sampling_frequency_` values in the `MicrophoneArray' object with values from the microphone array. \u0002wzxhzdk:18\u0003 \u0002wzxhzdk:19\u0003 .ShowConfiguration `ShowConfiguration` is a **function** that outputs the `gain_` and `sampling_frequency_` values in the `MicrophoneArray' object. \u0002wzxhzdk:20\u0003 \u0002wzxhzdk:21\u0003 \u0002wzxhzdk:22\u0003 .Channels `Channels` is a **function** that returns the number of microphone channels. \u0002wzxhzdk:23\u0003 \u0002wzxhzdk:24\u0003 .NumberOfSamples `NumberOfSamples` is a **function** that returns the number of samples. \u0002wzxhzdk:25\u0003 \u0002wzxhzdk:26\u0003 .At `At` is a **function** that returns microphone data from the `delayed_data_` array. The `Read` function populates the `delayed_data_` array. \u0002wzxhzdk:27\u0003 \u0002wzxhzdk:28\u0003 .Beam `Beam` is a **function** that returns beamformed microphone data from the `beamformed_` array. The `Read` function populates the `beamformed_` array. \u0002wzxhzdk:29\u0003 \u0002wzxhzdk:30\u0003 .CalculateDelays `CalculateDelays` is a **function** that calculates and sets up delays for beamforming. \u0002wzxhzdk:31\u0003 \u0002wzxhzdk:32\u0003 MicrophoneCore `MicrophoneCore` is an optional **object** that contains functions to enable using a FIR filter with microphone array. It accepts a `MicrophoneArray` object in it's constructor. \u0002wzxhzdk:33\u0003 \u0002wzxhzdk:34\u0003 The functions below are part of `MicrophoneCore`. .Setup `Setup` is a **function** that takes a `MatrixIOBus` object as a parameter and sets that object as the bus to use for communicating with MATRIX device. It also sets up the FIR filter by calling `SelectFIRCoeff( _default[0])`. \u0002wzxhzdk:35\u0003 \u0002wzxhzdk:36\u0003 .SetFIRCoeff `SetFIRCoeff` is a **function** that sends the `fir_coeff_` array in the `MicrophoneCore` object to the FPGA. \u0002wzxhzdk:37\u0003 \u0002wzxhzdk:38\u0003 .SetCustomFIRCoeff `SetCustomFIRCoeff` is a **function** that sets the `fir_coeff_` array in the `MicrophoneCore` object. If input is valid then the function also calls `SetFIRCoeff` to send the `fir_coeff_` array in the `MicrophoneCore` object to the FPGA. \u0002wzxhzdk:39\u0003 \u0002wzxhzdk:40\u0003 .SelectFIRCoeff `SelectFIRCoeff` is a **function** that sets the `fir_coeff_` array in the `MicrophoneCore` object. If input is valid then the function also calls `SetFIRCoeff` to send the `fir_coeff_` array in the `MicrophoneCore` object to the FPGA. This function accepts a FIRCoeff struct, which is defined below. \u0002wzxhzdk:41\u0003 \u0002wzxhzdk:42\u0003 \u0002wzxhzdk:43\u0003 Provided FIR Filters A FIR filter is provided in `matrix_hal/microphone_core_fir.h`. This filter provided is in the form of a FIRCoeff struct, which is defined below. \u0002wzxhzdk:44\u0003 To use the provided FIR filter the `SelectFIRCoeff` function is used to set it, then the `SetFIRCoeff` function is used to send it to the FPGA. \u0002wzxhzdk:45\u0003","title":"References"},{"location":"matrix-hal/reference/pressure/","text":"Pressure Device Compatibility Overview The pressure sensor reports values for: Pressure Altitude Temperature Based on component location, the temperature values from the humidity sensor are recommended over the pressure sensor. References Below is the overview of the pressure sensor implementation. Code example can be found here . These header files are required to use the pressure sensor. // Interfaces with pressure sensor #include matrix_hal/pressure_sensor.h // Holds data from pressure sensor #include matrix_hal/pressure_data.h // Communicates with MATRIX device #include matrix_hal/matrixio_bus.h PressureData `PressureData` is a required **object** that contains the pressure sensor's supported data parameters. \u0002wzxhzdk:1\u0003 The following code accesses the parameters of `PressureData`. \u0002wzxhzdk:2\u0003 PressureSensor `PressureSensor` is a required **object** that contains functions to interface with the pressure sensor. \u0002wzxhzdk:3\u0003 The functions below are part of `PressureSensor`. .Setup `Setup` is a **function** that takes a `MatrixIOBus` object as a parameter and sets that object as the bus to use for communicating with MATRIX device. \u0002wzxhzdk:4\u0003 \u0002wzxhzdk:5\u0003 .Read `Read` is a **function** that takes a `PressureData` object as a parameter and writes the current pressure sensor data into the `PressureData` object. \u0002wzxhzdk:6\u0003 \u0002wzxhzdk:7\u0003","title":"Pressure"},{"location":"matrix-hal/reference/pressure/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-hal/reference/pressure/#overview","text":"The pressure sensor reports values for: Pressure Altitude Temperature Based on component location, the temperature values from the humidity sensor are recommended over the pressure sensor.","title":"Overview"},{"location":"matrix-hal/reference/pressure/#references","text":"Below is the overview of the pressure sensor implementation. Code example can be found here . These header files are required to use the pressure sensor. // Interfaces with pressure sensor #include matrix_hal/pressure_sensor.h // Holds data from pressure sensor #include matrix_hal/pressure_data.h // Communicates with MATRIX device #include matrix_hal/matrixio_bus.h PressureData `PressureData` is a required **object** that contains the pressure sensor's supported data parameters. \u0002wzxhzdk:1\u0003 The following code accesses the parameters of `PressureData`. \u0002wzxhzdk:2\u0003 PressureSensor `PressureSensor` is a required **object** that contains functions to interface with the pressure sensor. \u0002wzxhzdk:3\u0003 The functions below are part of `PressureSensor`. .Setup `Setup` is a **function** that takes a `MatrixIOBus` object as a parameter and sets that object as the bus to use for communicating with MATRIX device. \u0002wzxhzdk:4\u0003 \u0002wzxhzdk:5\u0003 .Read `Read` is a **function** that takes a `PressureData` object as a parameter and writes the current pressure sensor data into the `PressureData` object. \u0002wzxhzdk:6\u0003 \u0002wzxhzdk:7\u0003","title":"References"},{"location":"matrix-hal/reference/uv/","text":"UV Device Compatibility Overview The UV sensor reports values for: UV Index scale used in the United States, conforms with international guidelines for UVI reporting established by the World Health Organization. From UV Index Scale References Below is the overview of the UV sensor implementation. Code example can be found here . These header files are required to use the UV sensor. // Interfaces with UV sensor #include matrix_hal/uv_sensor.h // Holds data from UV sensor #include matrix_hal/uv_data.h // Communicates with MATRIX device #include matrix_hal/matrixio_bus.h UVData `UVData` is a required **object** that contains the UV sensor's supported data parameters. \u0002wzxhzdk:1\u0003 The following code accesses the parameters of `UVData`. \u0002wzxhzdk:2\u0003 UVSensor `UVSensor` is a required **object** that contains functions to interface with the UV sensor. \u0002wzxhzdk:3\u0003 The functions below are part of `UVSensor`. .Setup `Setup` is a **function** that takes a `MatrixIOBus` object as a parameter and sets that object as the bus to use for communicating with MATRIX device. \u0002wzxhzdk:4\u0003 \u0002wzxhzdk:5\u0003 .Read `Read` is a **function** that takes a `UVData` object as a parameter and writes the current humidity sensor data into the `UVData` object. \u0002wzxhzdk:6\u0003 \u0002wzxhzdk:7\u0003","title":"UV"},{"location":"matrix-hal/reference/uv/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-hal/reference/uv/#overview","text":"The UV sensor reports values for: UV Index scale used in the United States, conforms with international guidelines for UVI reporting established by the World Health Organization. From UV Index Scale","title":"Overview"},{"location":"matrix-hal/reference/uv/#references","text":"Below is the overview of the UV sensor implementation. Code example can be found here . These header files are required to use the UV sensor. // Interfaces with UV sensor #include matrix_hal/uv_sensor.h // Holds data from UV sensor #include matrix_hal/uv_data.h // Communicates with MATRIX device #include matrix_hal/matrixio_bus.h UVData `UVData` is a required **object** that contains the UV sensor's supported data parameters. \u0002wzxhzdk:1\u0003 The following code accesses the parameters of `UVData`. \u0002wzxhzdk:2\u0003 UVSensor `UVSensor` is a required **object** that contains functions to interface with the UV sensor. \u0002wzxhzdk:3\u0003 The functions below are part of `UVSensor`. .Setup `Setup` is a **function** that takes a `MatrixIOBus` object as a parameter and sets that object as the bus to use for communicating with MATRIX device. \u0002wzxhzdk:4\u0003 \u0002wzxhzdk:5\u0003 .Read `Read` is a **function** that takes a `UVData` object as a parameter and writes the current humidity sensor data into the `UVData` object. \u0002wzxhzdk:6\u0003 \u0002wzxhzdk:7\u0003","title":"References"},{"location":"matrix-os/overview/","text":"MATRIX Open System \u26a0\ufe0f CURRENTLY UNDER MAINTENANCE \u26a0\ufe0f During this maintenance we strongly suggest that you use MATRIX CORE or MATRIX HAL as an alternative. MATRIX Open System (MOS) is open source software for hosting IoT applications. MATRIX Open System runs on node.js, and initially, applications will be written in JavaScript. The current workflow of this platform it to deploy and install apps into your MATRIX device, from a separate computer, anywhere in the world. Getting Started Learn how to install MOS and create applications for your MATRIX device. Reference Look over the MATRIX Open System SDK to see the current libraries and features we have to offer. This includes CLI tool commands, sensors/component references, dashboard, and many other vital configurations needed to take full advantage of MOS. Examples Take a look at the example to show you how you can create a simple dashboard setup for your MOS application. Mobile Applications Access and manage your MATRIX devices with the mobile apps Apple Store Play Store Troubleshooting Look at common debugging solutions for any issues you encounter.","title":"Overview"},{"location":"matrix-os/overview/#getting-started","text":"Learn how to install MOS and create applications for your MATRIX device.","title":"Getting Started"},{"location":"matrix-os/overview/#reference","text":"Look over the MATRIX Open System SDK to see the current libraries and features we have to offer. This includes CLI tool commands, sensors/component references, dashboard, and many other vital configurations needed to take full advantage of MOS.","title":"Reference"},{"location":"matrix-os/overview/#examples","text":"Take a look at the example to show you how you can create a simple dashboard setup for your MOS application.","title":"Examples"},{"location":"matrix-os/overview/#mobile-applications","text":"Access and manage your MATRIX devices with the mobile apps Apple Store Play Store","title":"Mobile Applications"},{"location":"matrix-os/overview/#troubleshooting","text":"Look at common debugging solutions for any issues you encounter.","title":"Troubleshooting"},{"location":"matrix-os/troubleshooting/","text":"Community Please visit our community support forums at community.matrix.one MOS DEBUG Mode Run MOS, with the following command, in order to enable debug mode. DEBUG=*,-engine*,-Component* node index","title":"Troubleshooting"},{"location":"matrix-os/troubleshooting/#community","text":"Please visit our community support forums at community.matrix.one","title":"Community"},{"location":"matrix-os/troubleshooting/#mos-debug-mode","text":"Run MOS, with the following command, in order to enable debug mode. DEBUG=*,-engine*,-Component* node index","title":"MOS DEBUG Mode"},{"location":"matrix-os/examples/","text":"Examples Dashboard Create a Dashboard for exploring data.","title":"Examples"},{"location":"matrix-os/examples/#examples","text":"","title":"Examples"},{"location":"matrix-os/examples/dash-create/","text":"Creating a Dashboard In this example we will demonstrate how to make a MATRIX Dashboard that can read and send data from your MATRIX device. The final result will your MATRIX device flickering its LEDs green and sending a random number to the dashboard, once the user presses a button. You should have familiarity with Data Types , Cross Talk , Dashboard , and the Getting Started section before exploring further. Setting Up Your Application Create Your App With the, MATRIX CLI tool installed, go to the terminal on your personal computer and insert the following command. matrix create exampleDashboard Config.yaml We will be setting up the app's config.yaml page in order to define the layout of our dashboard, dataTypes, and events. datatypes - Will define the variable that will save the random number we create. screens - Determines the placement of widgets. widgets - Our two dashboard components to visualize the random number we generate and command our MATRIX device to make that number. Events - Events doesn't have to be specified here because we are not sending one from our app, but receiving it from the startButton widget we made. View Cross Talk to learn more. configVersion: 2 description: 'Example dashboard to learn from.' keywords: dashboard example name: exampleDashboard shortName: exampleDashboard displayName: Example Dashboard dataTypes: #Holds the value shown on the dashboard randomNumber: number: integer screens: #This will show both widgets in the same Row - - numberGenerator - startButton widgets: #Displays a randomly generated number numberGenerator: display: digit type: randomNumber key: number label: Random Number #Calls number generator startButton: control: button event: generateNumber value: Get Random Number label: Start Number Generator Writing Your Application The following code below goes into your application's app.js file. The code can be split into two parts. The first is a simple function to turn on and off your MATRIX device's LEDs. The second part waits for the dashboard generateNumber event from the startButton widget. Once the event goes off, the previous function is called and a random number is created and sent to the dashboard's numberGenerator widget. // - Turn LEDs on and then off function flickerLights(color){ matrix.led(color).render();// Turn LEDs green // Wait 1 second setTimeout(function(){ matrix.led('black').render();// Turn LEDs off },500); } // - On Dashboard Button Press matrix.on('generateNumber', function(){ flickerLights('green');// Flicker MATRIX Device LEDs var randomNumber = Math.floor(Math.random()*100);// Generate a random number between 0 and 99 // Send Number To Dashboard matrix.type('randomNumber').send({ 'number': randomNumber }); }); Deploying Your Application You application should now be ready to deploy. Use the following command, with the location of your app folder, to send the app to your MATRIX device. matrix deploy PATH_TO_YOUR_APP_HERE After it's deployed, you can start the app with the final command below. matrix start exampleDashboard Final Result Visit the MATRIX Dashboard to see the example you've deployed. Use the \"Get Random Number Button\" to test the number generator and LEDs flashing. Alternatively, you can use the following command if you want to test sending a Cross Talk command through the MATRIX CLI tool. matrix trigger generateNumber","title":"Dashboard"},{"location":"matrix-os/examples/dash-create/#setting-up-your-application","text":"","title":"Setting Up Your Application"},{"location":"matrix-os/examples/dash-create/#writing-your-application","text":"The following code below goes into your application's app.js file. The code can be split into two parts. The first is a simple function to turn on and off your MATRIX device's LEDs. The second part waits for the dashboard generateNumber event from the startButton widget. Once the event goes off, the previous function is called and a random number is created and sent to the dashboard's numberGenerator widget. // - Turn LEDs on and then off function flickerLights(color){ matrix.led(color).render();// Turn LEDs green // Wait 1 second setTimeout(function(){ matrix.led('black').render();// Turn LEDs off },500); } // - On Dashboard Button Press matrix.on('generateNumber', function(){ flickerLights('green');// Flicker MATRIX Device LEDs var randomNumber = Math.floor(Math.random()*100);// Generate a random number between 0 and 99 // Send Number To Dashboard matrix.type('randomNumber').send({ 'number': randomNumber }); });","title":"Writing Your Application"},{"location":"matrix-os/examples/dash-create/#deploying-your-application","text":"You application should now be ready to deploy. Use the following command, with the location of your app folder, to send the app to your MATRIX device. matrix deploy PATH_TO_YOUR_APP_HERE After it's deployed, you can start the app with the final command below. matrix start exampleDashboard","title":"Deploying Your Application"},{"location":"matrix-os/examples/ifttt/","text":"IFTTT Integration Here we will demonstrate a simple IFTTT integration to alert you to weather outside. You should know the basics of application creation and deployment. See Getting Started - Application for more information. IFTTT Setup First, get an account at http://ifttt.com . Click on the profile menu on the right and select New Applet and click on this Select the Weather Underground Icon Select Current Condition Changes To Select Rain from the Dropdown Select that Type in and select matrix-io Connect with matrix-os Login with your MATRIX Credentials Allow IFTTT access to your MATRIX account Choose Send a MATRIX Event action Fill out details for your event. We are selecting to use an event named weather-change and passing the Condition (which should be \"Rain\"). Finish making your applet. MOS Application Code Create the application $ matrix create rain-oracle $ cd rain-oracle # first we setup the config $ vi config.yaml Add to the config.yaml integrations: - ifttt events: - weather-change Create app.js matrix.on('weather-change', (condition) = { if ( condition === 'Rain'){ matrix.led('blue').render(); } }) Deploy to device and start (ensure device is selected with matrix use ) $ matrix deploy # start application $ matrix start rain-oracle","title":"Ifttt"},{"location":"matrix-os/examples/ifttt/#ifttt-integration","text":"Here we will demonstrate a simple IFTTT integration to alert you to weather outside. You should know the basics of application creation and deployment. See Getting Started - Application for more information.","title":"IFTTT Integration"},{"location":"matrix-os/examples/ifttt/#ifttt-setup","text":"First, get an account at http://ifttt.com . Click on the profile menu on the right and select New Applet and click on this Select the Weather Underground Icon Select Current Condition Changes To Select Rain from the Dropdown Select that Type in and select matrix-io Connect with matrix-os Login with your MATRIX Credentials Allow IFTTT access to your MATRIX account Choose Send a MATRIX Event action Fill out details for your event. We are selecting to use an event named weather-change and passing the Condition (which should be \"Rain\"). Finish making your applet.","title":"IFTTT Setup"},{"location":"matrix-os/examples/ifttt/#mos-application-code","text":"Create the application $ matrix create rain-oracle $ cd rain-oracle # first we setup the config $ vi config.yaml Add to the config.yaml integrations: - ifttt events: - weather-change Create app.js matrix.on('weather-change', (condition) = { if ( condition === 'Rain'){ matrix.led('blue').render(); } }) Deploy to device and start (ensure device is selected with matrix use ) $ matrix deploy # start application $ matrix start rain-oracle","title":"MOS Application Code"},{"location":"matrix-os/getting-started/","text":"Getting Started \u26a0\ufe0f CURRENTLY UNDER MAINTENANCE \u26a0\ufe0f During this maintenance we strongly suggest that you use MATRIX CORE or MATRIX HAL as an alternative. Installation Learn how to install MOS and the MATRIX CLI tool. Applications Create and deploy a sample app for your MATRIX device. Publishing Apps Freely publish MATRIX applications to the MATRIX App store.","title":"Index"},{"location":"matrix-os/getting-started/#getting-started","text":"\u26a0\ufe0f CURRENTLY UNDER MAINTENANCE \u26a0\ufe0f During this maintenance we strongly suggest that you use MATRIX CORE or MATRIX HAL as an alternative.","title":"Getting Started"},{"location":"matrix-os/getting-started/applications/","text":"Creating An Application Introduction MOS applications allow you to easily utilize the components and sensors of your MATRIX device through Javascript. This IoT platform enables you to create applications and integrate them with any third party API to expand the functionality of your MATRIX device. Initial Setup MOS apps are designed to be developed outside your MATRIX device and deployed when you want to run your app. All that's required from your Raspberry Pi is to have MOS running. The following commands will be entered in the terminal that you installed the MATRIX CLI tool in. Use the command below to create a MOS app which will generate a folder with the necessary files. You will be prompted to enter a quick description and optional keywords to describe this app. matrix create YOUR_APP_NAME_HERE The file structure will look like this: YOUR_APP_FOLDER * app.js (Where you write your code) * config.yaml (Configuration file for application) * index.js (Imports MATRIX libraries for use in app.js) * package.json (Defines npm modules to install on your MATRIX Device) * README.MD (Readme file for MATRIX App Store) Open the app.js file and paste the code below with any text editor. matrix.led('green').render();//turn all LEDs green Deploying Your App With your MOS app completed, all that's left to do is run the following commands to deploy and then start the app on your MATRIX device. matrix deploy PATH_TO_YOUR_APP_HERE matrix start YOUR_APP_NAME_HERE Preview The interactive video below will show you the terminal outputs to expect from following this guide. Results When the MOS app runs, your MATRIX device should look like the image below. Next Steps View our reference page to see what you can with the MATRIX OS SDK or learn how to publish a MATRIX app here .","title":"Applications"},{"location":"matrix-os/getting-started/applications/#introduction","text":"MOS applications allow you to easily utilize the components and sensors of your MATRIX device through Javascript. This IoT platform enables you to create applications and integrate them with any third party API to expand the functionality of your MATRIX device.","title":"Introduction"},{"location":"matrix-os/getting-started/applications/#initial-setup","text":"MOS apps are designed to be developed outside your MATRIX device and deployed when you want to run your app. All that's required from your Raspberry Pi is to have MOS running. The following commands will be entered in the terminal that you installed the MATRIX CLI tool in. Use the command below to create a MOS app which will generate a folder with the necessary files. You will be prompted to enter a quick description and optional keywords to describe this app. matrix create YOUR_APP_NAME_HERE The file structure will look like this: YOUR_APP_FOLDER * app.js (Where you write your code) * config.yaml (Configuration file for application) * index.js (Imports MATRIX libraries for use in app.js) * package.json (Defines npm modules to install on your MATRIX Device) * README.MD (Readme file for MATRIX App Store) Open the app.js file and paste the code below with any text editor. matrix.led('green').render();//turn all LEDs green","title":"Initial Setup"},{"location":"matrix-os/getting-started/applications/#deploying-your-app","text":"With your MOS app completed, all that's left to do is run the following commands to deploy and then start the app on your MATRIX device. matrix deploy PATH_TO_YOUR_APP_HERE matrix start YOUR_APP_NAME_HERE","title":"Deploying Your App"},{"location":"matrix-os/getting-started/applications/#next-steps","text":"View our reference page to see what you can with the MATRIX OS SDK or learn how to publish a MATRIX app here .","title":"Next Steps"},{"location":"matrix-os/getting-started/installation/","text":"Installing MOS Prerequisites Make sure you have setup your MATRIX Creator or MATRIX Voice before continuing. Software Node.js Command Line Interface: macOS: Terminal Windows: PuTTY Linux: Terminal Computer Installation Account Registration We recommend running the following commands on your Desktop/Laptop and not on your Raspberry Pi. MOS contains a CLI (Command Line Interface) tool for controlling and managing your MATRIX devices. To install the tool, execute the following command in your personal computer's terminal. npm install -g matrix-cli Once installed, the CLI tool needs to be configured by registering and then logging into a MATRIX Labs account. matrix register matrix login With an account logged into the CLI tool, you can now register your MATRIX device. This will prompt you to enter a name and description for the device. matrix register device After the device is created, a set of unique login credentials will be generated for you. Save these credentials because they are necessary to link your MATRIX Labs account to your MATRIX device. Below is an example of the generated credentials. export MATRIX_DEVICE_ID=dc7a1a71be2d export MATRIX_DEVICE_SECRET=08629018e9d77h15i5n0t4r3alz0f06cd4f7e5544272b Raspberry Pi Setup Access the terminal of your Raspberry Pi via an SSH-session or connect a screen, mouse, and keyboard. Then run the following commands to go into your home directory and install MOS on the Raspberry Pi. A reboot will occur when the installation is finished. cd ~/ curl https://raw.githubusercontent.com/matrix-io/matrix-creator-quickstart/master/install.sh | sh Linking Device To MATRIX Labs Account To properly link your MATRIX device to your MATRIX Labs account, you need to create a file named .envrc in the home directory of the Raspberry Pi and then populate it with the device credentials you saved earlier. To create the .envrc file and add the device credentials, use the nano command below and paste your device credentials within the terminal editor. When you\u2019re done, press Ctrl+X . nano ~/.envrc With the .envrc file created, you need to make the credentials within visible to the shell by running the command below. MOS will then be able to read it and properly register your MATRIX device. source ~/.envrc Start MOS with the following command! node ~/matrix-os/index.js Starting MOS on boot is not yet implemented. Check If Everything Works Open the terminal on your Desktop/Laptop and type the following command with the device name or ID. This selects the MATRIX device you want to interact with. matrix use YOUR_DEVICE_NAME_OR_ID Once your device is selected, run these commands to verify that everything has installed properly. This installs and runs the HelloWorld app from the MATRIX App Store . matrix install HelloWorld matrix start HelloWorld You should now see a rainbow LED sequence, like the one above, on your MATRIX Device. Use the following command to stop the app. matrix stop HelloWorld When an app is stopped, the LEDs will keep the last color they were set to until set to a different color. Next Steps Now that everything is properly installed, learn how to create your own MATRIX app here .","title":"Installation"},{"location":"matrix-os/getting-started/installation/#prerequisites","text":"Make sure you have setup your MATRIX Creator or MATRIX Voice before continuing.","title":"Prerequisites"},{"location":"matrix-os/getting-started/installation/#computer-installation-account-registration","text":"We recommend running the following commands on your Desktop/Laptop and not on your Raspberry Pi. MOS contains a CLI (Command Line Interface) tool for controlling and managing your MATRIX devices. To install the tool, execute the following command in your personal computer's terminal. npm install -g matrix-cli Once installed, the CLI tool needs to be configured by registering and then logging into a MATRIX Labs account. matrix register matrix login With an account logged into the CLI tool, you can now register your MATRIX device. This will prompt you to enter a name and description for the device. matrix register device After the device is created, a set of unique login credentials will be generated for you. Save these credentials because they are necessary to link your MATRIX Labs account to your MATRIX device. Below is an example of the generated credentials. export MATRIX_DEVICE_ID=dc7a1a71be2d export MATRIX_DEVICE_SECRET=08629018e9d77h15i5n0t4r3alz0f06cd4f7e5544272b","title":"Computer Installation &amp; Account Registration"},{"location":"matrix-os/getting-started/installation/#raspberry-pi-setup","text":"Access the terminal of your Raspberry Pi via an SSH-session or connect a screen, mouse, and keyboard. Then run the following commands to go into your home directory and install MOS on the Raspberry Pi. A reboot will occur when the installation is finished. cd ~/ curl https://raw.githubusercontent.com/matrix-io/matrix-creator-quickstart/master/install.sh | sh","title":"Raspberry Pi Setup"},{"location":"matrix-os/getting-started/installation/#check-if-everything-works","text":"Open the terminal on your Desktop/Laptop and type the following command with the device name or ID. This selects the MATRIX device you want to interact with. matrix use YOUR_DEVICE_NAME_OR_ID Once your device is selected, run these commands to verify that everything has installed properly. This installs and runs the HelloWorld app from the MATRIX App Store . matrix install HelloWorld matrix start HelloWorld You should now see a rainbow LED sequence, like the one above, on your MATRIX Device. Use the following command to stop the app. matrix stop HelloWorld When an app is stopped, the LEDs will keep the last color they were set to until set to a different color.","title":"Check If Everything Works"},{"location":"matrix-os/getting-started/installation/#next-steps","text":"Now that everything is properly installed, learn how to create your own MATRIX app here .","title":"Next Steps"},{"location":"matrix-os/getting-started/publishing/","text":"Publishing your Application MATRIX App Store is in early development . All applications may be reviewed and are subject to removal at any time. MATRIX applications can be published to the MATRIX App Store for users to share their IoT creations with the community. Before publishing an application. Ensure Meta Information is Accurate The following information goes into your MATRIX application's config.yaml . The contents of your app's README.md will be shown on its detail page, along with any images provided. Required Meta Information name - The CLI command matrix install will use this to find your app. description - Mini description shown in app preview. displayName - Name shown on the app store. Optional Meta Information: imageUrls - will be used on the detail page galleryUrl - will be used on the main App Store page, or the first item in imageUrls will be used keywords - are used to tag your application and will be used to return your application on searches for these keywords. categories - are not yet formalized, but will divide the store listings. Submitting proposed app categories will inform this process. #example config.yaml name: example-app displayName: The Example App description: An example application config.yaml. imageUrls: - http://image.com/1 - http://image.com/2 galleryUrl: http://image.com/3 keywords: - example - configuration categories: - entertainment - development Ensure Components are Setup All applications, which use events and sensors, must register these in the config file.. Events events: - face-recognized - locked-door Sensors sensors: - temperature - uv A user will be required to grant an application permissions before installing. A user may install an app with any or all permissions enabled. Uploading An Application Your application must do only what it claims to do with the name, description and README.md. All sensors, integrations, and services must be registered in the config.yaml . User's will give consent for each after installing your app. To upload the your application, use the following MATRIX CLI command and point it to your app folder. matrix publish YOUR_APP_FOLDER","title":"Publishing Apps"},{"location":"matrix-os/getting-started/publishing/#before-publishing-an-application","text":"","title":"Before publishing an application."},{"location":"matrix-os/getting-started/publishing/#uploading-an-application","text":"Your application must do only what it claims to do with the name, description and README.md. All sensors, integrations, and services must be registered in the config.yaml . User's will give consent for each after installing your app. To upload the your application, use the following MATRIX CLI command and point it to your app folder. matrix publish YOUR_APP_FOLDER","title":"Uploading An Application"},{"location":"matrix-os/reference/","text":"MATRIX OS SDK Sensors Sensor interfaces and data structures Everloop LED interface Configuration Config.yaml Overview of the MOS app config.yaml file. CLI Tool MOS command-line interface. Dashboard Explore data representation and input with a live dashboard. Widgets Reference for all dashboard widgets. Cross Talk Exchange information between apps and devices. Data Types config.yaml data types overview. System Methods For application defaults or end-user configurable variables.","title":"Index"},{"location":"matrix-os/reference/#matrix-os-sdk","text":"","title":"MATRIX OS SDK"},{"location":"matrix-os/reference/#configuration","text":"","title":"Configuration"},{"location":"matrix-os/reference/cli-tool/","text":"Command Line Interface (CLI) The MATRIX CLI tool is a terminal interface for managing your MATRIX devices and applications. This includes deploying, downloading, and publishing applications. MATRIX CLI requires Node.js on your personal computer. Installation To install the MATRIX CLI, execute the following command in your personal computer's terminal. npm install -g matrix-cli Command list Typing matrix lists all the available MATRIX CLI commands. Each command for the CLI tool must begin with matrix . Setup matrix register - Register for a MATRIX Labs account. \u21b3 matrix register device - Registers a MATRIX device to your account. matrix account - View MATRIX Labs account details. \u21b3 matrix account profile - Edit account details. matrix remove YOUR_DEVICE_NAME_OR_ID - Removes a MATRIX device from your account. matrix login - Sign into MATRIX Labs account. matrix logout - Sign out of MATRIX Labs account. matrix upgrade - Update current MATRIX CLI tool version. matrix use YOUR_DEVICE_NAME_OR_ID - Select MATRIX device to use. matrix set - Set environment or locale. \u21b3 matrix set env DESIRED_ENV - Switch between dev , rc , and production environments. Recommended to stay in rc . \u21b3 matrix set locale DESIRED_LOCALE - Switch between es (spanish) and en (english) locale for the MATRIX CLI tool. Management matrix list - Lists all MATRIX devices or apps. \u21b3 matrix list devices - Lists all registered devices. \u21b3 matrix list apps - Lists all installed MATRIX apps for the current device. Apps matrix search APP_NAME - Check if a MATRIX app is listed in the app store matrix install APP_NAME - Install MATRIX app to your MATRIX device. matrix uninstall APP_NAME - Uninstall MATRIX app from your MATRIX device. matrix config APP_NAME - Check configuration of an installed MATRIX app. matrix start APP_NAME - Starts an installed MATRIX app. matrix stop APP_NAME - Stops an installed MATRIX app. matrix restarts APP_NAME - Restarts an installed MATRIX app. Development matrix create APP_NAME - Creates folder with the necessary files for a MATRIX app. matrix deploy APP_FOLDER - Installs MATRIX app to your MATRIX device. matrix publish APP_FOLDER - Upload MATRIX app to the app store. matrix unPublish APP_NAME - Remove MATRIX app from the app store. matrix trigger EVENT_TO_EMIT - Emits a Cross-talk event to each MATRIX device. matrix ping - Flashes the lights on MATRIX device currently selected. matrix log - Shows all console.log() outputs from your MATRIX device. matrix ping has a known issue where it will output an error, but still ping the device.","title":"CLI Tool"},{"location":"matrix-os/reference/cli-tool/#installation","text":"To install the MATRIX CLI, execute the following command in your personal computer's terminal. npm install -g matrix-cli","title":"Installation"},{"location":"matrix-os/reference/cli-tool/#command-list","text":"Typing matrix lists all the available MATRIX CLI commands. Each command for the CLI tool must begin with matrix .","title":"Command list"},{"location":"matrix-os/reference/cli-tool/#setup","text":"matrix register - Register for a MATRIX Labs account. \u21b3 matrix register device - Registers a MATRIX device to your account. matrix account - View MATRIX Labs account details. \u21b3 matrix account profile - Edit account details. matrix remove YOUR_DEVICE_NAME_OR_ID - Removes a MATRIX device from your account. matrix login - Sign into MATRIX Labs account. matrix logout - Sign out of MATRIX Labs account. matrix upgrade - Update current MATRIX CLI tool version. matrix use YOUR_DEVICE_NAME_OR_ID - Select MATRIX device to use. matrix set - Set environment or locale. \u21b3 matrix set env DESIRED_ENV - Switch between dev , rc , and production environments. Recommended to stay in rc . \u21b3 matrix set locale DESIRED_LOCALE - Switch between es (spanish) and en (english) locale for the MATRIX CLI tool.","title":"Setup"},{"location":"matrix-os/reference/cli-tool/#management","text":"matrix list - Lists all MATRIX devices or apps. \u21b3 matrix list devices - Lists all registered devices. \u21b3 matrix list apps - Lists all installed MATRIX apps for the current device.","title":"Management"},{"location":"matrix-os/reference/cli-tool/#apps","text":"matrix search APP_NAME - Check if a MATRIX app is listed in the app store matrix install APP_NAME - Install MATRIX app to your MATRIX device. matrix uninstall APP_NAME - Uninstall MATRIX app from your MATRIX device. matrix config APP_NAME - Check configuration of an installed MATRIX app. matrix start APP_NAME - Starts an installed MATRIX app. matrix stop APP_NAME - Stops an installed MATRIX app. matrix restarts APP_NAME - Restarts an installed MATRIX app.","title":"Apps"},{"location":"matrix-os/reference/cli-tool/#development","text":"matrix create APP_NAME - Creates folder with the necessary files for a MATRIX app. matrix deploy APP_FOLDER - Installs MATRIX app to your MATRIX device. matrix publish APP_FOLDER - Upload MATRIX app to the app store. matrix unPublish APP_NAME - Remove MATRIX app from the app store. matrix trigger EVENT_TO_EMIT - Emits a Cross-talk event to each MATRIX device. matrix ping - Flashes the lights on MATRIX device currently selected. matrix log - Shows all console.log() outputs from your MATRIX device. matrix ping has a known issue where it will output an error, but still ping the device.","title":"Development"},{"location":"matrix-os/reference/computer-vision/","text":"Computer Vision Device Compatibility MATRIX OS is designed to integrate with computer vision(CV) in a powerful and robust way. You can use computer vision output to drive behavior, capture data for further analysis or anything you want! Requires Raspberry Pi Camera Configuration You should have familiarity with Configuration Files before exploring further. To allow for communication with the hardware, CV services must be defined in config.yaml before they will be available to your application. services: matrix.led(['darkturquoise','deepskyblue','darkgreen','darkkhaki']).render(); matrix.service('face').start().then(function(data){ console.log(' ', data); matrix.led('green').render(); setTimeout(function() { matrix.led('black').render(); },2000); }); matrix.service The base matrix.service command is how you access computer vision services. matrix.service( algorithm, options ) basic algorithms face - triggers when it sees a face shape options refresh - how many seconds before restarting the detection, default: 3 timeout - if there is no detection, stop after this many seconds, default: none start() Starts a given CV algorithm with provided options. matrix.service( algorithm, options ).start() stop() Stops running a CV algorithm. var s = matrix.service( algorithm, options ).start(); s.stop(); //or matrix.service(algorithm).stop(); .then() Returns the data, Promise style. palm , face and fist have associated tags Returns tag : HAND_PALM , HAND_FIST , or FACE Example { location: { x: 333, y: 237, width: 55, height: 55 }, tag: 'HAND_PALM' } Complete Example # app.js var algorithm = 'face'; var options = {}; matrix.service( algorithm, options ).start().then(function( data ){ // your CV detection data will be available here console.log( data ); }); Advanced Algorithms demographics - age, gender and emotion detection recognition - facial recognition Extended Face Analytics Use demographics for the service call and in config services name engine Example Config.yaml services: facelytics: engine: detection type: demographics Example app.js matrix.service('demographics').start().then(function(output){ // see output below }); Demographics Output { location: { x: 213, y: 221, width: 55, height: 55 }, tag: 'FACE', trackId: 2, demographics: { gender: 'MALE', emotion: 'CALM', age: 25, pose: { yaw: -0.24303536117076874, roll: 0.04344254732131958, pitch: -0.10279278457164764 }, face_id: '4' } } Tracking trackId assigns a unique index-based identifier to each face detected. This number resets when the application or service is restarted, so do not rely on it for persistance. If you need persistant facial detection, try the recognition service. available emotions HAPPY SAD CONFUSED ANGRY CALM SURPRISED DISGUST Recognition recognition - matrix.service('recognition') MATRIX OS includes face recognition which turns a face into a series of numbers which can be used to identify the face when it is seen later. We do not store face images, just the numbers. Recognition only works from ~4 ft away. Removing hats and glasses will result in more accurate results. Example Config.yaml services: faceRecog: engine: recognition type: face Example app.js matrix.service('recognition').start() By default, recognition works in RECOGNITION mode. Recognition requires training first. train() matrix.service('recognition').train('test').then(data = { ... }); This will associate a face with a particular tag. Training Data Response { // number of trains performed count: 2, // number of trains desired target: 7, uuids: [...] } Training Data Example This will render a progress arc as training is completed. matrix.service('recognition').train('test').then(function(d) { matrix.led({ arc: Math.round(360 * (d.count / d.target)), color: 'blue', start: 0 }).render(); }); start() After training, you can enable normal recognition as follows. matrix.service('recognition').start().then(data = {...}) Recognition Training Response Outputs a collection of tags and scores. [{ tags : ['tagName'], score: 0.8 }, {...}] tags are the tags matched with each recognition. score is the measure of a match, lower numbers are better. 0.8 is a good metric to use for recognition. Recognition Example matrix.service('recognition').start().then(data = {...}) // select the best match out of all the responses var faces = _.values(d.matches); faces = _.sortBy(faces, ['score'])[0]; // if it passes a threshold, show green, otherwise show red if (MinDistanceFace.score 0.85) { matrix.led('green').render(); } else { matrix.led('red').render(); } }); Stop() If you need to explicitly stop a service, simply pass a stop() chained method. matrix.service('recognition').stop() Please note, that while this will tell the service to stop working, data may still trigger callbacks for a few seconds more.","title":"Computer vision"},{"location":"matrix-os/reference/computer-vision/#computer-vision","text":"","title":"Computer Vision"},{"location":"matrix-os/reference/computer-vision/#device-compatibility","text":"MATRIX OS is designed to integrate with computer vision(CV) in a powerful and robust way. You can use computer vision output to drive behavior, capture data for further analysis or anything you want! Requires Raspberry Pi Camera","title":"Device Compatibility"},{"location":"matrix-os/reference/computer-vision/#configuration","text":"You should have familiarity with Configuration Files before exploring further. To allow for communication with the hardware, CV services must be defined in config.yaml before they will be available to your application. services: matrix.led(['darkturquoise','deepskyblue','darkgreen','darkkhaki']).render(); matrix.service('face').start().then(function(data){ console.log(' ', data); matrix.led('green').render(); setTimeout(function() { matrix.led('black').render(); },2000); });","title":"Configuration"},{"location":"matrix-os/reference/computer-vision/#matrixservice","text":"The base matrix.service command is how you access computer vision services. matrix.service( algorithm, options )","title":"matrix.service"},{"location":"matrix-os/reference/computer-vision/#basic-algorithms","text":"face - triggers when it sees a face shape","title":"basic algorithms"},{"location":"matrix-os/reference/computer-vision/#options","text":"refresh - how many seconds before restarting the detection, default: 3 timeout - if there is no detection, stop after this many seconds, default: none","title":"options"},{"location":"matrix-os/reference/computer-vision/#start","text":"Starts a given CV algorithm with provided options. matrix.service( algorithm, options ).start()","title":"start()"},{"location":"matrix-os/reference/computer-vision/#stop","text":"Stops running a CV algorithm. var s = matrix.service( algorithm, options ).start(); s.stop(); //or matrix.service(algorithm).stop();","title":"stop()"},{"location":"matrix-os/reference/computer-vision/#then","text":"Returns the data, Promise style. palm , face and fist have associated tags Returns tag : HAND_PALM , HAND_FIST , or FACE","title":".then()"},{"location":"matrix-os/reference/computer-vision/#example","text":"{ location: { x: 333, y: 237, width: 55, height: 55 }, tag: 'HAND_PALM' }","title":"Example"},{"location":"matrix-os/reference/computer-vision/#complete-example","text":"# app.js var algorithm = 'face'; var options = {}; matrix.service( algorithm, options ).start().then(function( data ){ // your CV detection data will be available here console.log( data ); });","title":"Complete Example"},{"location":"matrix-os/reference/computer-vision/#advanced-algorithms","text":"demographics - age, gender and emotion detection recognition - facial recognition","title":"Advanced Algorithms"},{"location":"matrix-os/reference/computer-vision/#extended-face-analytics","text":"Use demographics for the service call and in config services name engine","title":"Extended Face Analytics"},{"location":"matrix-os/reference/computer-vision/#example-configyaml","text":"services: facelytics: engine: detection type: demographics","title":"Example Config.yaml"},{"location":"matrix-os/reference/computer-vision/#example-appjs","text":"matrix.service('demographics').start().then(function(output){ // see output below });","title":"Example app.js"},{"location":"matrix-os/reference/computer-vision/#demographics-output","text":"{ location: { x: 213, y: 221, width: 55, height: 55 }, tag: 'FACE', trackId: 2, demographics: { gender: 'MALE', emotion: 'CALM', age: 25, pose: { yaw: -0.24303536117076874, roll: 0.04344254732131958, pitch: -0.10279278457164764 }, face_id: '4' } }","title":"Demographics Output"},{"location":"matrix-os/reference/computer-vision/#tracking","text":"trackId assigns a unique index-based identifier to each face detected. This number resets when the application or service is restarted, so do not rely on it for persistance. If you need persistant facial detection, try the recognition service.","title":"Tracking"},{"location":"matrix-os/reference/computer-vision/#available-emotions","text":"HAPPY SAD CONFUSED ANGRY CALM SURPRISED DISGUST","title":"available emotions"},{"location":"matrix-os/reference/computer-vision/#recognition","text":"recognition - matrix.service('recognition') MATRIX OS includes face recognition which turns a face into a series of numbers which can be used to identify the face when it is seen later. We do not store face images, just the numbers. Recognition only works from ~4 ft away. Removing hats and glasses will result in more accurate results.","title":"Recognition"},{"location":"matrix-os/reference/computer-vision/#example-configyaml_1","text":"services: faceRecog: engine: recognition type: face","title":"Example Config.yaml"},{"location":"matrix-os/reference/computer-vision/#example-appjs_1","text":"matrix.service('recognition').start() By default, recognition works in RECOGNITION mode. Recognition requires training first.","title":"Example app.js"},{"location":"matrix-os/reference/computer-vision/#train","text":"matrix.service('recognition').train('test').then(data = { ... }); This will associate a face with a particular tag.","title":"train()"},{"location":"matrix-os/reference/computer-vision/#training-data-response","text":"{ // number of trains performed count: 2, // number of trains desired target: 7, uuids: [...] }","title":"Training Data Response"},{"location":"matrix-os/reference/computer-vision/#training-data-example","text":"This will render a progress arc as training is completed. matrix.service('recognition').train('test').then(function(d) { matrix.led({ arc: Math.round(360 * (d.count / d.target)), color: 'blue', start: 0 }).render(); });","title":"Training Data Example"},{"location":"matrix-os/reference/computer-vision/#start_1","text":"After training, you can enable normal recognition as follows. matrix.service('recognition').start().then(data = {...})","title":"start()"},{"location":"matrix-os/reference/computer-vision/#recognition-training-response","text":"Outputs a collection of tags and scores. [{ tags : ['tagName'], score: 0.8 }, {...}] tags are the tags matched with each recognition. score is the measure of a match, lower numbers are better. 0.8 is a good metric to use for recognition.","title":"Recognition Training Response"},{"location":"matrix-os/reference/computer-vision/#recognition-example","text":"matrix.service('recognition').start().then(data = {...}) // select the best match out of all the responses var faces = _.values(d.matches); faces = _.sortBy(faces, ['score'])[0]; // if it passes a threshold, show green, otherwise show red if (MinDistanceFace.score 0.85) { matrix.led('green').render(); } else { matrix.led('red').render(); } });","title":"Recognition Example"},{"location":"matrix-os/reference/computer-vision/#stop_1","text":"If you need to explicitly stop a service, simply pass a stop() chained method. matrix.service('recognition').stop() Please note, that while this will tell the service to stop working, data may still trigger callbacks for a few seconds more.","title":"Stop()"},{"location":"matrix-os/reference/configuration/","text":"Configuration Each MOS application has a configuration file config.yaml that's required to have, in order to run. What this file does: Sets meta information for the application, which is used in the MATRIX App Store . Defines a schema for sending data from the device. Identifies which sensors , services , events and integrations an application utilizes. Defines dynamic settings variables, which are available to the application and end-user modifiable. Defines the widgets and their layout in the dashboard Generates a policy on install, asking the user for specific access to their device. Configuration Options name - Name of the application that appears as part of the application store when viewing it. description - Short description that appears as part of the application when deploying or pushing to App Store. keywords - a few values about the application. ex: face, door, unlock version - this field will be updated by the CLI on publish. configVersion - This field defines what version is the configuration. don't touch this. settings - runtime variables for MOS applications dataTypes - schema for structured data from an application sensors - which sensors to activate for this application integrations - which external integrations does this application support ie. ifttt events - which events this application has listeners for screens - layout for widgets. see Layout widgets - widget definitions. see Widgets services - service definitions. #example config.yaml name: example-app displayName: The Example App description: An example application config.yaml. imageUrls: - http://image.com/1 keywords: - example - configuration categories: - entertainment sensors: - temperature - gyroscope Usage Notes The config.yaml is standardized before installation, which will modify it somewhat, especially in the widget definations. Do not be alarmed if your installed config.yaml does not match the original, this is normal. More info See the helper library with examples at: https://github.com/matrix-io/matrix-app-config-helper","title":"Config.yaml"},{"location":"matrix-os/reference/configuration/#configuration-options","text":"name - Name of the application that appears as part of the application store when viewing it. description - Short description that appears as part of the application when deploying or pushing to App Store. keywords - a few values about the application. ex: face, door, unlock version - this field will be updated by the CLI on publish. configVersion - This field defines what version is the configuration. don't touch this. settings - runtime variables for MOS applications dataTypes - schema for structured data from an application sensors - which sensors to activate for this application integrations - which external integrations does this application support ie. ifttt events - which events this application has listeners for screens - layout for widgets. see Layout widgets - widget definitions. see Widgets services - service definitions. #example config.yaml name: example-app displayName: The Example App description: An example application config.yaml. imageUrls: - http://image.com/1 keywords: - example - configuration categories: - entertainment sensors: - temperature - gyroscope","title":"Configuration Options"},{"location":"matrix-os/reference/configuration/#usage-notes","text":"The config.yaml is standardized before installation, which will modify it somewhat, especially in the widget definations. Do not be alarmed if your installed config.yaml does not match the original, this is normal.","title":"Usage Notes"},{"location":"matrix-os/reference/configuration/#more-info","text":"See the helper library with examples at: https://github.com/matrix-io/matrix-app-config-helper","title":"More info"},{"location":"matrix-os/reference/crosstalk/","text":"Cross-Talk Cross-Talk events allow MATRIX applications to exchange information between different devices, or on the same device. For example, a temperature monitor app can output an event to an alarm app to notify you when the current temperature is too high or low. Cross-Talk events will only be sent to MATRIX devices tied to the same MATRIX Labs account. Config Setup You should have familiarity with Configuration Files before exploring further. CrossTalk requires each event, that will be emitted, in your app's configuration file to execute successfully. This information is also used in the app store to determine which applications can communicate via events. Defining An Event Add the events: configuration to your app's config.yaml and give each event your app will emit. Do not add this to an app's configuration if they are only going to listen for events. events: - flashGreen - highTemperature Event Emitters Listeners Once your app has its events properly defined, you can use matrix.emit to broadcast the event to other MATRIX apps and matrix.on to receive them. .emit(app, event, payload) Use this function in the application that has the events defined in the config.yaml file. Events can also be emitted through the MATRIX CLI matrix trigger command here . app MATRIX app you're sending the event to. event Event being sent to MATRIX app. payload Optional object or string to attach to event being sent. // Trigger an event in a specific application matrix.emit('app', 'event', payload); // Example 1 matrix.emit('ledControl', 'flashGreen'); // Example 2 matrix.emit('alarm', 'highTemperature', {temperature: 80.95899963378906}'); .on(event, callback) Use this function in the application that will receive the events. Applications that receive events do not need to specify the events in its config.yaml. event Event to listen on. callback Callback method with payload returned. // Listen for CrossTalk events sent to this application matrix.on('event', function(payload) { //... }); // Example 1 matrix.on('flashGreen', function(){ //... }); // Example 2 matrix.on('highTemperature', function(payload){ //... }); Dashboard Receive events from the MATRIX Dashboard by binding them to widget controls. // Interface elements from Dashboards can also trigger CrossTalk events. matrix.on('buttonClick', function(payload) { ... }); See Configuration Widgets for the entire list.","title":"Cross Talk"},{"location":"matrix-os/reference/crosstalk/#config-setup","text":"You should have familiarity with Configuration Files before exploring further. CrossTalk requires each event, that will be emitted, in your app's configuration file to execute successfully. This information is also used in the app store to determine which applications can communicate via events.","title":"Config Setup"},{"location":"matrix-os/reference/crosstalk/#event-emitters-listeners","text":"Once your app has its events properly defined, you can use matrix.emit to broadcast the event to other MATRIX apps and matrix.on to receive them.","title":"Event Emitters &amp; Listeners"},{"location":"matrix-os/reference/crosstalk/#dashboard","text":"Receive events from the MATRIX Dashboard by binding them to widget controls. // Interface elements from Dashboards can also trigger CrossTalk events. matrix.on('buttonClick', function(payload) { ... }); See Configuration Widgets for the entire list.","title":"Dashboard"},{"location":"matrix-os/reference/dashboard/","text":"Dashboard You should have familiarity with Configuration Files before exploring further. The MATRIX Dashboard is an online interface that can manage each of your MATRIX devices and applications. The dashboard itself consists of widgets which are defined in the configuration file , config.yaml . Widgets provide representation for data coming from a MATRIX application and they can provide controls for users to modify how a MATRIX application operates. Each application can have its own dashboard view. View your Dashboard here . Screens Screens are where we define the placement of widgets on the dashboard (consists of rows and columns). Adding screens to your config.yaml file will require you to specify your widget names and dashboard placements. Below are some examples of how to defines your screens. -- New row. - New column. screens: #Row 1 has 2 Columns - - myTopLeftWidget - myTopRightWidget screens: #Row 1 has 2 Columns - - myTopLeftWidget - myTopRightWidget #Row 2 has 3 Columns - - myBottomLeftWidget - myBottomMiddleWidget - myBottomRightWidget Each screens item looks for a widgets item with the same name to show on the dashboard. The following example shows how to properly define these. screens: - - startButton - readDeviceSensors widgets: startButton: control: button event: buttonInfo value: START label: Turn LEDs On readDeviceSensors: control: switch event: sensorsEnabled value: Sensors Enabled label: Send Sensor Data Widgets Now that you know how to display widgets, learn which widgets are available in the dashboard and how to configure them here .","title":"Dashboard"},{"location":"matrix-os/reference/dashboard/#screens","text":"Screens are where we define the placement of widgets on the dashboard (consists of rows and columns). Adding screens to your config.yaml file will require you to specify your widget names and dashboard placements. Below are some examples of how to defines your screens. -- New row. - New column. screens: #Row 1 has 2 Columns - - myTopLeftWidget - myTopRightWidget screens: #Row 1 has 2 Columns - - myTopLeftWidget - myTopRightWidget #Row 2 has 3 Columns - - myBottomLeftWidget - myBottomMiddleWidget - myBottomRightWidget Each screens item looks for a widgets item with the same name to show on the dashboard. The following example shows how to properly define these. screens: - - startButton - readDeviceSensors widgets: startButton: control: button event: buttonInfo value: START label: Turn LEDs On readDeviceSensors: control: switch event: sensorsEnabled value: Sensors Enabled label: Send Sensor Data","title":"Screens"},{"location":"matrix-os/reference/dashboard/#widgets","text":"Now that you know how to display widgets, learn which widgets are available in the dashboard and how to configure them here .","title":"Widgets"},{"location":"matrix-os/reference/data-types/","text":"Sending Data From MATRIX Devices You should have familiarity with Configuration Files and Widgets before exploring further. The MATRIX Dashboard's display widgets all require you to define dataTypes in your config.yaml file. widgets can only ready values from defined dataTypes . Your MATRIX app can push to these values with the matrix.send method. Data Types dataTypes can be thought of as javascript objects. Each data type can contain multiple values known as keys . These keys can hold the following values. string - can be defined as: string or str or s integer - can be defined as: integer or int or i float - can be defined as: float or fl or f boolean - can be defined as: b or bool or boolean ; Creating Datatypes In order to create your dataTypes , a type needs to be specified. Once created, your type needs at least one key to be able to hold data. # How to structure dataTypes: type1: key1: string or integer or float or boolean key2: string or integer or float or boolean type2: key1: string or integer or float or boolean # Example dataTypes: location: latitude: float longitude: float statusAlert: currentStatus: string We do not currently support changing dataTypes for newer versions of an application. If you need to change dataTypes after an application is published on the MATRIX App Store, please release a new application until we can address this issue. Sending Data Once your dataTypes are defined, you can begin to send data to the MATRIX Dashboard in real-time. The code below shows an example of how to have your app.js and config.yaml configured for updating dataTypes by using matrix.send() . # config.yaml dataTypes: location: latitude: float longitude: float // app.js matrix.type('location').send({ 'latitude': 40.285519, 'longitude': -76.650589 }) Widgets Learn how to use widgets to see how you can use dataTypes to display real-time information on your MATRIX Dashboard.","title":"Data Types"},{"location":"matrix-os/reference/data-types/#data-types","text":"dataTypes can be thought of as javascript objects. Each data type can contain multiple values known as keys . These keys can hold the following values. string - can be defined as: string or str or s integer - can be defined as: integer or int or i float - can be defined as: float or fl or f boolean - can be defined as: b or bool or boolean ;","title":"Data Types"},{"location":"matrix-os/reference/data-types/#sending-data","text":"Once your dataTypes are defined, you can begin to send data to the MATRIX Dashboard in real-time. The code below shows an example of how to have your app.js and config.yaml configured for updating dataTypes by using matrix.send() . # config.yaml dataTypes: location: latitude: float longitude: float // app.js matrix.type('location').send({ 'latitude': 40.285519, 'longitude': -76.650589 })","title":"Sending Data"},{"location":"matrix-os/reference/data-types/#widgets","text":"Learn how to use widgets to see how you can use dataTypes to display real-time information on your MATRIX Dashboard.","title":"Widgets"},{"location":"matrix-os/reference/filters/","text":"Filters Device Compatibility MatrixOS sensors and computer vision algorithms provide data which can be filtered between the sensor , which can be regarded as the data source, and the then , which can be regarded as the data receiver. Between the two, we can use chaining methods to easily filter what data is received. // filtering in a simple application matrix.sensor('temperature') .above(80) .then(data = { // see CrossTalk documentation for more information about matrix.emit matrix.emit('ac-control', 'turnOn'); }); Filtering decides whether or not a data point is passed to the then() , it does not change the data in any way. Simple Filtering methods equality Numeric is() like() matrix.sensor('temperature').is(72) negation not() matrix.sensor('temperature').not(72) has has() is used to refine a data source by additional criteria and keys. // for simple sensors matrix.sensor('temperature').has('value') // equivalent to matrix.sensor('temperature').has() // for complex sensors matrix.sensor('gyroscope').has('x') bounds greater then above , over , after matrix.sensor('temperature').has().above(72) less then below , under , before matrix.sensor('temperature').has().below(32) between matrix.service('face').start().has('happy').between(50,100)","title":"Filters"},{"location":"matrix-os/reference/filters/#filters","text":"","title":"Filters"},{"location":"matrix-os/reference/filters/#device-compatibility","text":"MatrixOS sensors and computer vision algorithms provide data which can be filtered between the sensor , which can be regarded as the data source, and the then , which can be regarded as the data receiver. Between the two, we can use chaining methods to easily filter what data is received. // filtering in a simple application matrix.sensor('temperature') .above(80) .then(data = { // see CrossTalk documentation for more information about matrix.emit matrix.emit('ac-control', 'turnOn'); }); Filtering decides whether or not a data point is passed to the then() , it does not change the data in any way.","title":"Device Compatibility"},{"location":"matrix-os/reference/filters/#simple-filtering-methods","text":"","title":"Simple Filtering methods"},{"location":"matrix-os/reference/filters/#equality","text":"","title":"equality"},{"location":"matrix-os/reference/filters/#numeric","text":"is() like() matrix.sensor('temperature').is(72)","title":"Numeric"},{"location":"matrix-os/reference/filters/#negation","text":"not() matrix.sensor('temperature').not(72)","title":"negation"},{"location":"matrix-os/reference/filters/#has","text":"has() is used to refine a data source by additional criteria and keys. // for simple sensors matrix.sensor('temperature').has('value') // equivalent to matrix.sensor('temperature').has() // for complex sensors matrix.sensor('gyroscope').has('x')","title":"has"},{"location":"matrix-os/reference/filters/#bounds","text":"","title":"bounds"},{"location":"matrix-os/reference/filters/#greater-then","text":"above , over , after matrix.sensor('temperature').has().above(72)","title":"&gt; greater then"},{"location":"matrix-os/reference/filters/#less-then","text":"below , under , before matrix.sensor('temperature').has().below(32)","title":"&lt; less then"},{"location":"matrix-os/reference/filters/#between","text":"matrix.service('face').start().has('happy').between(50,100)","title":"between"},{"location":"matrix-os/reference/gpio/","text":"GPIO Device Compatibility GPIO can be used to communicate or receive input from analog and digital components through the MATRIX Creator, or any other sensor leveraging Raspberry Pi's GPIOs. Configuration Make sure to add the following to your config.yaml to enable GPIO's/ integrations: - gpio matrix.gpio.read pinNumber : The GPIO you are reading from. callback : Returns err , value . matrix.gpio.read(16, function(err, value) { if(err) throw err; console.log(value); // The current state of the pin }); matrix.gpio.write pinNumber : The GPIO you are reading from. value : The value you would like to update the GPIO with. callback : Returns err , value . matrix.gpio.write(16, 1, function(err) { if(err) throw err; }); Servo Configuration Make sure to add the following to your config.yaml to enable Servos/ integrations: - gpio matrix.servo pin : The GPIO pin the servo is connected to. angle : Integer specifying the specific angle to set the servo to. matrix.servo(pin, angle);","title":"Gpio"},{"location":"matrix-os/reference/gpio/#gpio","text":"","title":"GPIO"},{"location":"matrix-os/reference/gpio/#device-compatibility","text":"GPIO can be used to communicate or receive input from analog and digital components through the MATRIX Creator, or any other sensor leveraging Raspberry Pi's GPIOs.","title":"Device Compatibility"},{"location":"matrix-os/reference/gpio/#configuration","text":"Make sure to add the following to your config.yaml to enable GPIO's/ integrations: - gpio","title":"Configuration"},{"location":"matrix-os/reference/gpio/#matrixgpioread","text":"pinNumber : The GPIO you are reading from. callback : Returns err , value . matrix.gpio.read(16, function(err, value) { if(err) throw err; console.log(value); // The current state of the pin });","title":"matrix.gpio.read"},{"location":"matrix-os/reference/gpio/#matrixgpiowrite","text":"pinNumber : The GPIO you are reading from. value : The value you would like to update the GPIO with. callback : Returns err , value . matrix.gpio.write(16, 1, function(err) { if(err) throw err; });","title":"matrix.gpio.write"},{"location":"matrix-os/reference/gpio/#servo","text":"","title":"Servo"},{"location":"matrix-os/reference/gpio/#configuration_1","text":"Make sure to add the following to your config.yaml to enable Servos/ integrations: - gpio","title":"Configuration"},{"location":"matrix-os/reference/gpio/#matrixservo","text":"pin : The GPIO pin the servo is connected to. angle : Integer specifying the specific angle to set the servo to. matrix.servo(pin, angle);","title":"matrix.servo"},{"location":"matrix-os/reference/integrations/","text":"Integrations External integrations must be enabled via configuration. Configuration # in config.yaml integrations - ifttt IFTTT If This Then That enables a MATRIX device to trigger actions or react to external events. By piggybacking onto the existing event system , MOS can seamlessly integrates with thousands of platforms available on IFTTT.","title":"Integrations"},{"location":"matrix-os/reference/integrations/#integrations","text":"External integrations must be enabled via configuration.","title":"Integrations"},{"location":"matrix-os/reference/integrations/#configuration","text":"# in config.yaml integrations - ifttt","title":"Configuration"},{"location":"matrix-os/reference/integrations/#ifttt","text":"If This Then That enables a MATRIX device to trigger actions or react to external events. By piggybacking onto the existing event system , MOS can seamlessly integrates with thousands of platforms available on IFTTT.","title":"IFTTT"},{"location":"matrix-os/reference/leds/","text":"Everloop Device Compatibility MATRIX Voice is currently experiencing issues with LEDs in the MATRIX Open System. The Everloop is a powerful tool for visually communicating through LEDs. Click the video below to learn more. matrix.darken() and matrix.brighten() have not been implemented. String Notation Render You can use any CSS color property (color-name, rgb, and hex). Darker colors on the Everloop generally display with more precision then lighter colors, which tend to get washed out. The code below shows how to set the entire Everloop to green with each CSS property. The .render() method must be included at the end of the matrix.led() method to update your MATRIX device's LEDs. // String matrix.led('green').render(); // Hexadecimal matrix.led('#00ff00').render(); // RGB matrix.led('rgb(0,255,0)').render(); Please avoid using rgba . Alpha values do not render correctly. Creating Shapes Currently, shape manipulation on the MATRIX Voice does not render properly. Fix in progress! Shape objects are methods of manipulating multiple LEDs in the Everloop at once. Shape creation is simple, you define the shape you want to make as an object and pass it into matrix.led() like the example below matrix.led({ arc: 90, //arc shape that takes up 90\u00b0 of Everloop color: green, //turn shape green start: 0 //start shape at 0\u00b0 of Everloop }).render(); Available Shapes Include one of these shape properties in your shape. arc: 90 //number of degrees to draw an arc, supports negative values angle: 45 //degree number to draw a single point Shape Properties Every Shape object must include the color property to render. color: 'red' //color strings, as specified above spin: 230 //rotate color hue ( 0 - 360 ) start: 0 //degree at which shape begins, arc shape only Rotation Operation These operate on the shapes and colors defined in the led object. .rotate(angle); //rotates whole shape by number of degrees matrix.led({ arc: 45, color: 'blue', start: 50 }).rotate(90).render(); Multiple Shapes Use an array in the matrix.led() method to include multiple shapes. // make a smiley face matrix.led([ //left eye angle { angle: 45, color: 'yellow' }, //right eye angle { angle: 135, color: 'yellow' }, //smile arc { arc: 90, color: 'yellow', start: 225 } ]).render(); Direct LED Manipulation Array index indicates the LED to change. The index of an LED is labeled directly above the LED on your MATRIX device (D1, D2, D3, D4, etc..). Use 0 to turn off the LED. matrix.led([0, 0, 0, 0, 'yellow', 0, 0, 0, 0, 0, 0, 0, 0, 'yellow', 0, 0, 0, 0, 0, 0, 0, 0, 'yellow', 'yellow', 'yellow', 'yellow', 'yellow', 'yellow', 'yellow', 'yellow', 'yellow']).render(); LED Animation By using a setInterval() method, you can animate the LEDs on the Everloop. Below is an example of an active clock that demonstrates this. setInterval(function(){ var time = new Date(); var h = time.getHours(); var m = time.getMinutes(); var s = time.getSeconds(); var hourLED = { // translate hours (12) to angle (360) arc: h * 3, color: 'blue' }; var minuteLED = { // translate minutes ( 60 ) to angle ( 360 ) angle: m * 6, color: 'green' }; var secondLED = { // translate seconds (60) to angle (360) angle: s * 6, color: 'yellow', }; // will draw all three matrix.led([hourLED, minuteLED, secondLED]).render(); }, 1000); Advanced Use Enable SUN_MODE=true as a flag, when launching MATRIX OS, to turn on the white LEDs (and the luminence calculations). Wear sunglasses or use another mode of protecting your eyes when using this while developing. It is intended for use behind coverings. SUN_MODE=true node index","title":"Everloop"},{"location":"matrix-os/reference/leds/#device-compatibility","text":"MATRIX Voice is currently experiencing issues with LEDs in the MATRIX Open System. The Everloop is a powerful tool for visually communicating through LEDs. Click the video below to learn more. matrix.darken() and matrix.brighten() have not been implemented.","title":"Device Compatibility"},{"location":"matrix-os/reference/leds/#string-notation-render","text":"You can use any CSS color property (color-name, rgb, and hex). Darker colors on the Everloop generally display with more precision then lighter colors, which tend to get washed out. The code below shows how to set the entire Everloop to green with each CSS property. The .render() method must be included at the end of the matrix.led() method to update your MATRIX device's LEDs. // String matrix.led('green').render(); // Hexadecimal matrix.led('#00ff00').render(); // RGB matrix.led('rgb(0,255,0)').render(); Please avoid using rgba . Alpha values do not render correctly.","title":"String Notation &amp; Render"},{"location":"matrix-os/reference/leds/#creating-shapes","text":"Currently, shape manipulation on the MATRIX Voice does not render properly. Fix in progress! Shape objects are methods of manipulating multiple LEDs in the Everloop at once. Shape creation is simple, you define the shape you want to make as an object and pass it into matrix.led() like the example below matrix.led({ arc: 90, //arc shape that takes up 90\u00b0 of Everloop color: green, //turn shape green start: 0 //start shape at 0\u00b0 of Everloop }).render();","title":"Creating Shapes"},{"location":"matrix-os/reference/leds/#led-animation","text":"By using a setInterval() method, you can animate the LEDs on the Everloop. Below is an example of an active clock that demonstrates this. setInterval(function(){ var time = new Date(); var h = time.getHours(); var m = time.getMinutes(); var s = time.getSeconds(); var hourLED = { // translate hours (12) to angle (360) arc: h * 3, color: 'blue' }; var minuteLED = { // translate minutes ( 60 ) to angle ( 360 ) angle: m * 6, color: 'green' }; var secondLED = { // translate seconds (60) to angle (360) angle: s * 6, color: 'yellow', }; // will draw all three matrix.led([hourLED, minuteLED, secondLED]).render(); }, 1000);","title":"LED Animation"},{"location":"matrix-os/reference/leds/#advanced-use","text":"Enable SUN_MODE=true as a flag, when launching MATRIX OS, to turn on the white LEDs (and the luminence calculations). Wear sunglasses or use another mode of protecting your eyes when using this while developing. It is intended for use behind coverings. SUN_MODE=true node index","title":"Advanced Use"},{"location":"matrix-os/reference/sensors/","text":"Sensors Device Compatibility Available Sensors temperature , humidity , pressure , uv , gyroscope , accelerometer Configuration You should have familiarity with Configuration Files before exploring further. When downloading an app from the MATRIX App Store , End users must explicitly authorize MOS applications to utilize hardware sensors. This requires that each application to identify the sensors it requires in config.yaml . Sensors will not work unless this is specified. Below is an example for an app that requires the temperature and humidity sensor. sensors: - temperature - humidity Reading Sensors All sensors are initialized using the sensor method. This method should only be used once per sensor. Once called, your can use a .then promise to initiate a callback. matrix.sensor(sensorType, options); sensorType : Type of sensor you are initializing options : The options for that sensor. All sensors support a refresh and timeout property. // Example var temperatureValue = 0; // global variable to hold sensor value var humidityValue = 0; // global variable to hold humidity value // Sensor options var options = { refresh: 1000, // milliseconds between data points timeout: 10000 // how long before stopping this sensor }; // Begin calling temperature sensor matrix.sensor('temperature', options).then(data = { temperatureValue = data.value; // update global variable console.log(temperatureValue); // print new temperature value }); // Begin calling humidity sensor matrix.sensor('humidity', options).then(data = { humidityValue = data.value; // update global variable console.log(humidityValue); // print new humidity value }); Outputs Below are all the possible data formats for each sensor. Temperature Output for temperature (in ). { value: 36.95899963378906, type: 'temperature' } Humidity Output for humidity . { value: 30.409704208374023, type: 'humidity' } Pressure Output for pressure (in mbars). { value: 101692, type: 'pressure' } UV Output for UV . { value: 0.0053547522984445095, risk: 'Low' } Gyroscope Output for gyroscope . { yaw: 144.78964233398438, pitch: 2.112252950668335, roll: -92.0414810180664, x: -10.78155517578125, y: 1.8841552734375, z: 0.441131591796875, type: 'gyroscope' } Accelerometer Output for accelerometer { x: 0.1, y: 0.23, z: 0.224, type: 'accelerometer' } Magnetometer Output for magnetometer { x: 0.51, y: 0.53, z: -0.124, type: 'magnetometer' }","title":"Sensors"},{"location":"matrix-os/reference/sensors/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-os/reference/sensors/#available-sensors","text":"temperature , humidity , pressure , uv , gyroscope , accelerometer","title":"Available Sensors"},{"location":"matrix-os/reference/sensors/#configuration","text":"You should have familiarity with Configuration Files before exploring further. When downloading an app from the MATRIX App Store , End users must explicitly authorize MOS applications to utilize hardware sensors. This requires that each application to identify the sensors it requires in config.yaml . Sensors will not work unless this is specified. Below is an example for an app that requires the temperature and humidity sensor. sensors: - temperature - humidity","title":"Configuration"},{"location":"matrix-os/reference/sensors/#reading-sensors","text":"All sensors are initialized using the sensor method. This method should only be used once per sensor. Once called, your can use a .then promise to initiate a callback. matrix.sensor(sensorType, options); sensorType : Type of sensor you are initializing options : The options for that sensor. All sensors support a refresh and timeout property. // Example var temperatureValue = 0; // global variable to hold sensor value var humidityValue = 0; // global variable to hold humidity value // Sensor options var options = { refresh: 1000, // milliseconds between data points timeout: 10000 // how long before stopping this sensor }; // Begin calling temperature sensor matrix.sensor('temperature', options).then(data = { temperatureValue = data.value; // update global variable console.log(temperatureValue); // print new temperature value }); // Begin calling humidity sensor matrix.sensor('humidity', options).then(data = { humidityValue = data.value; // update global variable console.log(humidityValue); // print new humidity value });","title":"Reading Sensors"},{"location":"matrix-os/reference/sensors/#outputs","text":"Below are all the possible data formats for each sensor.","title":"Outputs"},{"location":"matrix-os/reference/system/","text":"System Methods Several methods are available for common computing use cases, like saving application variables, storing files or local database. These will be localized to the device and are not available across all instances of the application. Settings When an application requires a variable which should be user provided or will change between different instances, settings is a way to approach this problem. Config Setup You should have familiarity with Configuration Files before exploring further. Add the settings: configuration to your app's config.yaml and specify each setting your app will save. settings: apiKey: 'dfe972dc' secretKey: 'ea9e2dab' Every key in settings is exposed on the root matrix object. For example, settings.apiKey is accessible in your MATRIX app as matrix.apiKey . console.log(matrix.apiKey);// prints your apiKey setting Dynamically Changing Settings from an application Currently, the setting will only be overwritten after the MATRIX app restarts. matrix.set({ apiKey: '3c3cce95' });// Overrides matrix.apiKey matrix.set({ secretKey: '08937cef' });// Overrides matrix.apiKey Local Database MATRIX OS provides a local, file-based key-value store for app usage. This storage is globally accessible to any application installed on the same device. It is not recommended to set end user specific configurations here. use settings instead. Set Defines the name of the a key and the value it'll hold in the local database. matrix.store.set(key, value, function(){ //... }); Get Obtains the value of a stored key in the local database. The value is passed to the callback . matrix.store.get(key, function(error, value){ console.log(value);// prints key value }); Delete Remove a stored key from the local database. matrix.store.delete(key, function(){ //... }); File Storage MATRIX applications utilize a local file storage for storing files. This enables MATRIX applications to dynamically download content that was not initially packaged with the app. Save Downloads and stores a file specified through a URL. url publicly accessible url. filename name of the file being saved. callback function to call when save is complete. matrix.file.save(url, filename, function(){ //.. }); Load Load the buffer of a file you saved. filename file to load. callback function to call after file is read matrix.file.load(filename, function(error, data){ console.log(data);// prints buffer of loaded file }); List See all currently stored files in application. callback function to call after files are counted matrix.file.list(function(error, files){ console.log(files);// prints array of downloaded files }) Remove filename file to remove from application storage callback function to call when remove is complete matrix.file.remove(filename, function(){ //.. });","title":"System Methods"},{"location":"matrix-os/reference/system/#settings","text":"When an application requires a variable which should be user provided or will change between different instances, settings is a way to approach this problem.","title":"Settings"},{"location":"matrix-os/reference/system/#local-database","text":"MATRIX OS provides a local, file-based key-value store for app usage. This storage is globally accessible to any application installed on the same device. It is not recommended to set end user specific configurations here. use settings instead.","title":"Local Database"},{"location":"matrix-os/reference/system/#file-storage","text":"MATRIX applications utilize a local file storage for storing files. This enables MATRIX applications to dynamically download content that was not initially packaged with the app.","title":"File Storage"},{"location":"matrix-os/reference/widgets/","text":"Widgets You should have familiarity with Data Types , Cross Talk and Dashboard before exploring further. Widgets are what allow you to visualize and or control your MATRIX applications through the MATRIX Dashboard. Widget Configuration Each widget requires certain options to be defined before they can properly show on the dashboard. The list below will go through each available option for widgets . Widget Types Display Widgets - Displays data from an application. Control Widgets - Sends real-time events to an application. All Widget Options label - Optional display title for widget. size - Optional percentage value for a widget's width ( 25 , 50 , 75 , etc..). widgets can only have either a display or control option when choosing a widget type. Display Widget Options Display widgets, like tables, charts and value outputs are only concerned with what data to display and how to display it. display - Which display widget to load type - Select type from a defined data type (see Sending Data ). key / keys - Select key or keys being used from type . format - Filter the data. choose from count , sum , avg , percent , max , min , fixed , round . realtime - Defaults to true . Use the refresh option for manual updates. refresh - How many seconds between data refresh. use with realtime set to false . Interactive Widget Options Interactive widgets, like buttons, switches, and controllers are meant to send data from the MATRIX Dashboard to your MATRIX app. control - Which control widget option load trigger - The event to listen for in your application ( see Reference Crosstalk ) value - On button widgets, what text should be in the button map - On button widgets, a collection of value: trigger where value is the button text, and trigger is the event fired Display widgets Indicated via a display option. Each example will show how to configure their respective widget. screens and dataTypes will be left up to you to configure. `bar` - bar chart ![Bar Chart](../img/ios/bar.png) \u0002wzxhzdk:0\u0003 \u0002wzxhzdk:1\u0003 `digit` - numerical ![Digit](../img/ios/digit.png) \u0002wzxhzdk:2\u0003 \u0002wzxhzdk:3\u0003 `radar` - radar chart ![Radar Chart](../img/ios/radar.png) \u0002wzxhzdk:4\u0003 \u0002wzxhzdk:5\u0003 `line` - line chart ![Line Chart](../img/ios/line.png) \u0002wzxhzdk:6\u0003 \u0002wzxhzdk:7\u0003 `list` - data table ![List](../img/ios/list.png) \u0002wzxhzdk:8\u0003 \u0002wzxhzdk:9\u0003 `list-group` - grouped data table **Simple Group** ![List Group](../img/listgroup.png) \u0002wzxhzdk:10\u0003 \u0002wzxhzdk:11\u0003 **Group By Key** ![List Group](../img/listgroupby.png) \u0002wzxhzdk:12\u0003 \u0002wzxhzdk:13\u0003 `pie-chart` - pie chart ![Radar Chart](../img/ios/pie.png) \u0002wzxhzdk:14\u0003 \u0002wzxhzdk:15\u0003 `polar` - polar area chart ![Polar Chart](../img/ios/polar.png) \u0002wzxhzdk:16\u0003 \u0002wzxhzdk:17\u0003 `label` - string display ![Label](../img/ios/label.PNG) \u0002wzxhzdk:18\u0003 \u0002wzxhzdk:19\u0003 `gauge` - gauge ![Gauge](../img/ios/gauge.png) \u0002wzxhzdk:20\u0003 \u0002wzxhzdk:21\u0003 `indicator` - light indicator on/off ![Indicator](../img/ios/indicator.png) \u0002wzxhzdk:22\u0003 \u0002wzxhzdk:23\u0003 `map` - google maps ![Map](../img/ios/map.png) \u0002wzxhzdk:24\u0003 \u0002wzxhzdk:25\u0003 `link` - link to a destination (URL) ![Link](../img/link.png) \u0002wzxhzdk:26\u0003 Control Widgets Indicated via a control option. Each example will show how to configure their respective widget. screens and dataTypes will be left up to you to configure. `input` - input field, single or multiple **Single Inputs** ![input](../img/ios/input.png) \u0002wzxhzdk:27\u0003 \u0002wzxhzdk:28\u0003 **Multiple Inputs** ![button Map](../img/ios/inputMap.png) \u0002wzxhzdk:29\u0003 \u0002wzxhzdk:30\u0003 `button` - button, single or multiple **Single Buttons** ![button](../img/ios/button.png) \u0002wzxhzdk:31\u0003 \u0002wzxhzdk:32\u0003 **Multiple Buttons** ![button Map](../img/ios/buttonMap.png) \u0002wzxhzdk:33\u0003 \u0002wzxhzdk:34\u0003 `switch` - switch, single or multiple **Single Switch** ![switch](../img/ios/switch.png) \u0002wzxhzdk:35\u0003 \u0002wzxhzdk:36\u0003 **Multiple Switches** ![switch](../img/ios/switchMap.png) \u0002wzxhzdk:37\u0003 \u0002wzxhzdk:38\u0003 `radio` - radio, single or multiple ![radio](../img/ios/radio.png) \u0002wzxhzdk:39\u0003 \u0002wzxhzdk:40\u0003 `dropdown` - dropdown menu ![DropDown](../img/ios/dropdown.png) \u0002wzxhzdk:41\u0003 \u0002wzxhzdk:42\u0003 `range` - range slider ![range](../img/ios/range.png) \u0002wzxhzdk:43\u0003 \u0002wzxhzdk:44\u0003 `xy` - track pad ![xy](../img/ios/xy.png) \u0002wzxhzdk:45\u0003 \u0002wzxhzdk:46\u0003 `radial` - joystick, single or multiple **Single Radial** ![radial](../img/ios/radial.png) \u0002wzxhzdk:47\u0003 \u0002wzxhzdk:48\u0003 **Multiple Radials** ![radial](../img/ios/radialMap.png) \u0002wzxhzdk:49\u0003 \u0002wzxhzdk:50\u0003 `color` - color picker ![color](../img/color.png) ![colorSelector](../img/colorSelector.png) \u0002wzxhzdk:51\u0003 \u0002wzxhzdk:52\u0003","title":"Widgets"},{"location":"matrix-os/reference/widgets/#widget-configuration","text":"Each widget requires certain options to be defined before they can properly show on the dashboard. The list below will go through each available option for widgets .","title":"Widget Configuration"},{"location":"matrix-os/reference/widgets/#display-widgets","text":"Indicated via a display option. Each example will show how to configure their respective widget. screens and dataTypes will be left up to you to configure. `bar` - bar chart ![Bar Chart](../img/ios/bar.png) \u0002wzxhzdk:0\u0003 \u0002wzxhzdk:1\u0003 `digit` - numerical ![Digit](../img/ios/digit.png) \u0002wzxhzdk:2\u0003 \u0002wzxhzdk:3\u0003 `radar` - radar chart ![Radar Chart](../img/ios/radar.png) \u0002wzxhzdk:4\u0003 \u0002wzxhzdk:5\u0003 `line` - line chart ![Line Chart](../img/ios/line.png) \u0002wzxhzdk:6\u0003 \u0002wzxhzdk:7\u0003 `list` - data table ![List](../img/ios/list.png) \u0002wzxhzdk:8\u0003 \u0002wzxhzdk:9\u0003 `list-group` - grouped data table **Simple Group** ![List Group](../img/listgroup.png) \u0002wzxhzdk:10\u0003 \u0002wzxhzdk:11\u0003 **Group By Key** ![List Group](../img/listgroupby.png) \u0002wzxhzdk:12\u0003 \u0002wzxhzdk:13\u0003 `pie-chart` - pie chart ![Radar Chart](../img/ios/pie.png) \u0002wzxhzdk:14\u0003 \u0002wzxhzdk:15\u0003 `polar` - polar area chart ![Polar Chart](../img/ios/polar.png) \u0002wzxhzdk:16\u0003 \u0002wzxhzdk:17\u0003 `label` - string display ![Label](../img/ios/label.PNG) \u0002wzxhzdk:18\u0003 \u0002wzxhzdk:19\u0003 `gauge` - gauge ![Gauge](../img/ios/gauge.png) \u0002wzxhzdk:20\u0003 \u0002wzxhzdk:21\u0003 `indicator` - light indicator on/off ![Indicator](../img/ios/indicator.png) \u0002wzxhzdk:22\u0003 \u0002wzxhzdk:23\u0003 `map` - google maps ![Map](../img/ios/map.png) \u0002wzxhzdk:24\u0003 \u0002wzxhzdk:25\u0003 `link` - link to a destination (URL) ![Link](../img/link.png) \u0002wzxhzdk:26\u0003","title":"Display widgets"},{"location":"matrix-os/reference/widgets/#control-widgets","text":"Indicated via a control option. Each example will show how to configure their respective widget. screens and dataTypes will be left up to you to configure. `input` - input field, single or multiple **Single Inputs** ![input](../img/ios/input.png) \u0002wzxhzdk:27\u0003 \u0002wzxhzdk:28\u0003 **Multiple Inputs** ![button Map](../img/ios/inputMap.png) \u0002wzxhzdk:29\u0003 \u0002wzxhzdk:30\u0003 `button` - button, single or multiple **Single Buttons** ![button](../img/ios/button.png) \u0002wzxhzdk:31\u0003 \u0002wzxhzdk:32\u0003 **Multiple Buttons** ![button Map](../img/ios/buttonMap.png) \u0002wzxhzdk:33\u0003 \u0002wzxhzdk:34\u0003 `switch` - switch, single or multiple **Single Switch** ![switch](../img/ios/switch.png) \u0002wzxhzdk:35\u0003 \u0002wzxhzdk:36\u0003 **Multiple Switches** ![switch](../img/ios/switchMap.png) \u0002wzxhzdk:37\u0003 \u0002wzxhzdk:38\u0003 `radio` - radio, single or multiple ![radio](../img/ios/radio.png) \u0002wzxhzdk:39\u0003 \u0002wzxhzdk:40\u0003 `dropdown` - dropdown menu ![DropDown](../img/ios/dropdown.png) \u0002wzxhzdk:41\u0003 \u0002wzxhzdk:42\u0003 `range` - range slider ![range](../img/ios/range.png) \u0002wzxhzdk:43\u0003 \u0002wzxhzdk:44\u0003 `xy` - track pad ![xy](../img/ios/xy.png) \u0002wzxhzdk:45\u0003 \u0002wzxhzdk:46\u0003 `radial` - joystick, single or multiple **Single Radial** ![radial](../img/ios/radial.png) \u0002wzxhzdk:47\u0003 \u0002wzxhzdk:48\u0003 **Multiple Radials** ![radial](../img/ios/radialMap.png) \u0002wzxhzdk:49\u0003 \u0002wzxhzdk:50\u0003 `color` - color picker ![color](../img/color.png) ![colorSelector](../img/colorSelector.png) \u0002wzxhzdk:51\u0003 \u0002wzxhzdk:52\u0003","title":"Control Widgets"},{"location":"matrix-os/reference/zigbee/","text":"Zigbee Device Compatibility Alpha API, subject to deprecation Version Introduced: 0.9.0 Configuration Zigbee requires zigbee to be added to integrations in the config.yaml # config.yaml integrations: - zigbee Base matrix.zigbee() - activates the zigbee network and sees if any of the remembered devices are available Returns an object which is used to activate other zigbee commands var zb = matrix.zigbee(); Network zb.discover() - put zigbee into discover mode for 60 seconds. power on your zigbee device to have it be found zb.reset() - if you get into problems, issue a reset command Lights currently, only zigbee lights are supported zb.light(n) - address found lights. n indicates the number of the light, in order of which it was added, default to the first. zb.light().on() - turns on the light zb.light().off() - turns off the light zb.light().toggle() - turns the light on or off zb.light().fadeIn(time) - slowly turn a light over time seconds zb.light().fadeOut(time) - slowly turn off a light over time seconds zb.light().color(hue, time) - sets the light to hue color, over time seconds, defaulting to 3 seconds. hue accepts 0-360 hue values, in addition any color value which would be passed to the Everloop, like 'blue' or '#0000FF' . see Everloop zb.light().level(level, time) - sets the light level to level 0-100 over time seconds, defaults to 3 Example Use events to have precise control over your zigbee devices. matrix.on('discover', function(){ matrix.zigbee().discover(); }); matrix.on('reset', function(){ matrix.zigbee().reset(); }); matrix.on('toggle', function(){ matrix.zigbee().light().toggle(); }); matrix.on('off', function(){ matrix.zigbee().light().fadeOut(10); }); matrix.on('on', function(){ matrix.zigbee().light().fadeIn(10); }); matrix.on('dim', function(){ matrix.zigbee().light().level(10, 5); }); var spin; matrix.on('spin', function(){ var hue = 0; var i = 0; setInterval( function(){ spin = matrix.led({ h: hue++, s: 1, l: 0.5 }).render(); if ( i 35 ){ i = 0; } if ( hue 360){ hue = 0; } if ( hue % 10 === 0){ matrix.zigbee().light().color(hue, 1); } }, 50); }); matrix.on('stop', function(){ clearInterval(spin); }); Issue a spin event against the above application to cycle colors on the Everloop and set the zigbee light to the same color.","title":"Zigbee"},{"location":"matrix-os/reference/zigbee/#zigbee","text":"","title":"Zigbee"},{"location":"matrix-os/reference/zigbee/#device-compatibility","text":"Alpha API, subject to deprecation Version Introduced: 0.9.0","title":"Device Compatibility"},{"location":"matrix-os/reference/zigbee/#configuration","text":"Zigbee requires zigbee to be added to integrations in the config.yaml # config.yaml integrations: - zigbee","title":"Configuration"},{"location":"matrix-os/reference/zigbee/#base","text":"matrix.zigbee() - activates the zigbee network and sees if any of the remembered devices are available Returns an object which is used to activate other zigbee commands var zb = matrix.zigbee();","title":"Base"},{"location":"matrix-os/reference/zigbee/#network","text":"zb.discover() - put zigbee into discover mode for 60 seconds. power on your zigbee device to have it be found zb.reset() - if you get into problems, issue a reset command","title":"Network"},{"location":"matrix-os/reference/zigbee/#lights","text":"currently, only zigbee lights are supported zb.light(n) - address found lights. n indicates the number of the light, in order of which it was added, default to the first. zb.light().on() - turns on the light zb.light().off() - turns off the light zb.light().toggle() - turns the light on or off zb.light().fadeIn(time) - slowly turn a light over time seconds zb.light().fadeOut(time) - slowly turn off a light over time seconds zb.light().color(hue, time) - sets the light to hue color, over time seconds, defaulting to 3 seconds. hue accepts 0-360 hue values, in addition any color value which would be passed to the Everloop, like 'blue' or '#0000FF' . see Everloop zb.light().level(level, time) - sets the light level to level 0-100 over time seconds, defaults to 3","title":"Lights"},{"location":"matrix-os/reference/zigbee/#example","text":"Use events to have precise control over your zigbee devices. matrix.on('discover', function(){ matrix.zigbee().discover(); }); matrix.on('reset', function(){ matrix.zigbee().reset(); }); matrix.on('toggle', function(){ matrix.zigbee().light().toggle(); }); matrix.on('off', function(){ matrix.zigbee().light().fadeOut(10); }); matrix.on('on', function(){ matrix.zigbee().light().fadeIn(10); }); matrix.on('dim', function(){ matrix.zigbee().light().level(10, 5); }); var spin; matrix.on('spin', function(){ var hue = 0; var i = 0; setInterval( function(){ spin = matrix.led({ h: hue++, s: 1, l: 0.5 }).render(); if ( i 35 ){ i = 0; } if ( hue 360){ hue = 0; } if ( hue % 10 === 0){ matrix.zigbee().light().color(hue, 1); } }, 50); }); matrix.on('stop', function(){ clearInterval(spin); }); Issue a spin event against the above application to cycle colors on the Everloop and set the zigbee light to the same color.","title":"Example"},{"location":"matrix-os/reference/not_implemented/ir/","text":"Sending IR Commands as a remote control Currently, we have implemented remote emulation. We will offer a more precise way to send and recieve information over IR. Find the remote you want to emulate at the LIRC Remote Table . Open the .conf file and take note of the codes . Sending these through MATRIX OS via matrix.ir().send() will replicate a button press and blast a signal out the IR transmitters. matrix.ir( brand, model ) This tells your device to lookup a definition for the remote and use those values for the IR transmission. Example matrix.ir('SONY', 'RM-833').send('KEY_POWER')","title":"Ir"},{"location":"matrix-os/reference/not_implemented/ir/#sending-ir-commands-as-a-remote-control","text":"Currently, we have implemented remote emulation. We will offer a more precise way to send and recieve information over IR. Find the remote you want to emulate at the LIRC Remote Table . Open the .conf file and take note of the codes . Sending these through MATRIX OS via matrix.ir().send() will replicate a button press and blast a signal out the IR transmitters.","title":"Sending IR Commands as a remote control"},{"location":"matrix-os/reference/not_implemented/ir/#matrixir-brand-model","text":"This tells your device to lookup a definition for the remote and use those values for the IR transmission.","title":"matrix.ir( brand, model )"},{"location":"matrix-os/reference/not_implemented/ir/#example","text":"matrix.ir('SONY', 'RM-833').send('KEY_POWER')","title":"Example"},{"location":"matrix-os/reference/not_implemented/microphone/","text":"Voice Control MATRIX OS provides for voice recognition via wakeword detection. \"Hey Siri\", \"Alexa\", \"Ok Google\" are examples of common wakewords used in commercial products. The default wakeword for MATRIX OS is \"Matrix\", however, you can train any wakeword you want. Configuration services: customListener: engine: voice phrase: hey joe Wakeword Training matrix.listen('hey joe', function(err, phrase){ }); // equivalent to matrix.listen('customListener', function(err, phrase){ }); // equivalent to matrix.service('voice').listen('hey joe', function(err, phrase){ }); // equivalent to matrix.service('customListener').listen(function(err, phrase){ })","title":"Microphone"},{"location":"matrix-os/reference/not_implemented/microphone/#voice-control","text":"MATRIX OS provides for voice recognition via wakeword detection. \"Hey Siri\", \"Alexa\", \"Ok Google\" are examples of common wakewords used in commercial products. The default wakeword for MATRIX OS is \"Matrix\", however, you can train any wakeword you want.","title":"Voice Control"},{"location":"matrix-os/reference/not_implemented/microphone/#configuration","text":"services: customListener: engine: voice phrase: hey joe","title":"Configuration"},{"location":"matrix-os/reference/not_implemented/microphone/#wakeword-training","text":"matrix.listen('hey joe', function(err, phrase){ }); // equivalent to matrix.listen('customListener', function(err, phrase){ }); // equivalent to matrix.service('voice').listen('hey joe', function(err, phrase){ }); // equivalent to matrix.service('customListener').listen(function(err, phrase){ })","title":"Wakeword Training"},{"location":"matrix-os/reference/not_implemented/zwave/","text":"Still working out the precise API for this. Stay tuned. matrix.init('zwave')...","title":"Zwave"},{"location":"matrix-voice/device-setup/","text":"Hardware Prerequisites MATRIX Voice Compatible Raspberry Pi: 3 Model B+ 3 Model B 2 Model B 1 Model B+ Zero Zero W 5V 2.5A Micro USB Power Supply MicroSD Card With Raspbian Stretch Lite or Desktop Installed We recommend using Etcher.io for easy flashing Device Installation Steps Insert flashed microSD card into Raspberry Pi Attach MATRIX Voice onto Raspberry Pi GPIO pins Power Raspberry Pi with micro USB power supply The yellow startup LED sequence (with 1 LED off) will be removed when a programming environment is installed. Choosing A Programming Environment After your MATRIX Voice is setup, visit Ecosystem Overview for information about the three programming environments available to you in the MATRIX platform. All 3 programming environments are compatible with the MATRIX Voice MATRIX Voice ESP32 version on a Raspberry Pi. ESP32 Setup Users with a MATRIX Voice ESP32 version can also follow this guide on how to program their ESP32 module.","title":"Device Setup"},{"location":"matrix-voice/device-setup/#hardware-prerequisites","text":"MATRIX Voice Compatible Raspberry Pi: 3 Model B+ 3 Model B 2 Model B 1 Model B+ Zero Zero W 5V 2.5A Micro USB Power Supply MicroSD Card With Raspbian Stretch Lite or Desktop Installed We recommend using Etcher.io for easy flashing","title":"Hardware Prerequisites"},{"location":"matrix-voice/device-setup/#device-installation","text":"","title":"Device Installation"},{"location":"matrix-voice/device-setup/#choosing-a-programming-environment","text":"After your MATRIX Voice is setup, visit Ecosystem Overview for information about the three programming environments available to you in the MATRIX platform. All 3 programming environments are compatible with the MATRIX Voice MATRIX Voice ESP32 version on a Raspberry Pi.","title":"Choosing A Programming Environment"},{"location":"matrix-voice/device-setup/#esp32-setup","text":"Users with a MATRIX Voice ESP32 version can also follow this guide on how to program their ESP32 module.","title":"ESP32 Setup"},{"location":"matrix-voice/esp32/","text":"ESP32 Setup This guide will show you how to get started with the ESP32 module on the MATRIX Voice ESP32 version. Step 1: Raspberry Pi Setup Run the following commands inside your Raspberry Pi terminal to install the MATRIX Voice Software. This will keep the FPGA firmware updated and install few tools to flash the ESP-WROOM-32. Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the MATRIX init package. sudo apt install matrixio-creator-init Reboot your Raspberry Pi. sudo reboot Step 2: Personal Computer Setup Here we're installing the requirements needed to allow your pc to develop and compile ESP32 projects. Install Git: https://git-scm.com/downloads Install ESP32 toolchain: Linux: https://esp-idf.readthedocs.io/en/latest/get-started/linux-setup.html Mac: https://esp-idf.readthedocs.io/en/latest/get-started/macos-setup.html Windows: https://esp-idf.readthedocs.io/en/latest/get-started/windows-setup.html (currently not functioning) Stop Following when you reach \"Next Steps\" Setup ESP-IDF development framework: Download ESP-IDF: https://esp-idf.readthedocs.io/en/latest/get-started/index.html#get-esp-idf Set ESP-IDF Path: https://esp-idf.readthedocs.io/en/latest/get-started/add-idf_path-to-profile.html Clone MATRIX Voice ESP32 repository This repository contains the necessary libraries to control the MATRIX Voice's components. # windows must be using MINGw32 terminal from toolchain step git clone https://github.com/matrix-io/matrixio_hal_esp32.git Step 3: Build and Deploy Here we will be deploying and running one of the example apps in the Repository we just downloaded. Configuring IDF (one time setup): cd matrixio_hal_esp32/examples/mic_energy/ make menuconfig You will now be taken to the IDF Configuration screen, as shown above. Once there, select the option to save default configuration. Running example project: To finish running the example, all that's left is to make and deploy the code to the Raspberry Pi. This requires the Pi's IP address and you will be prompted to insert the Pi's password as well. export RPI_HOST=pi@RASPBERRY_IP_ADDRESS make deploy Step 4: Finishing Up Your MATRIX Voice ESP32 should now be running the deployed example. With the program properly flashed in the ESP32, the Voice can now run without the Pi if you choose to do so. Ensure the MATRIX Voice and Pi are not powered before connecting or disconnecting.","title":"ESP32"},{"location":"matrix-voice/esp32/#esp32-setup","text":"This guide will show you how to get started with the ESP32 module on the MATRIX Voice ESP32 version.","title":"ESP32 Setup"},{"location":"matrix-voice/esp32/#step-1-raspberry-pi-setup","text":"Run the following commands inside your Raspberry Pi terminal to install the MATRIX Voice Software. This will keep the FPGA firmware updated and install few tools to flash the ESP-WROOM-32. Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the MATRIX init package. sudo apt install matrixio-creator-init Reboot your Raspberry Pi. sudo reboot","title":"Step 1: Raspberry Pi Setup"},{"location":"matrix-voice/esp32/#step-2-personal-computer-setup","text":"Here we're installing the requirements needed to allow your pc to develop and compile ESP32 projects. Install Git: https://git-scm.com/downloads Install ESP32 toolchain: Linux: https://esp-idf.readthedocs.io/en/latest/get-started/linux-setup.html Mac: https://esp-idf.readthedocs.io/en/latest/get-started/macos-setup.html Windows: https://esp-idf.readthedocs.io/en/latest/get-started/windows-setup.html (currently not functioning) Stop Following when you reach \"Next Steps\" Setup ESP-IDF development framework: Download ESP-IDF: https://esp-idf.readthedocs.io/en/latest/get-started/index.html#get-esp-idf Set ESP-IDF Path: https://esp-idf.readthedocs.io/en/latest/get-started/add-idf_path-to-profile.html Clone MATRIX Voice ESP32 repository This repository contains the necessary libraries to control the MATRIX Voice's components. # windows must be using MINGw32 terminal from toolchain step git clone https://github.com/matrix-io/matrixio_hal_esp32.git","title":"Step 2: Personal Computer Setup"},{"location":"matrix-voice/esp32/#step-3-build-and-deploy","text":"Here we will be deploying and running one of the example apps in the Repository we just downloaded. Configuring IDF (one time setup): cd matrixio_hal_esp32/examples/mic_energy/ make menuconfig You will now be taken to the IDF Configuration screen, as shown above. Once there, select the option to save default configuration. Running example project: To finish running the example, all that's left is to make and deploy the code to the Raspberry Pi. This requires the Pi's IP address and you will be prompted to insert the Pi's password as well. export RPI_HOST=pi@RASPBERRY_IP_ADDRESS make deploy","title":"Step 3: Build and Deploy"},{"location":"matrix-voice/esp32/#step-4-finishing-up","text":"Your MATRIX Voice ESP32 should now be running the deployed example. With the program properly flashed in the ESP32, the Voice can now run without the Pi if you choose to do so. Ensure the MATRIX Voice and Pi are not powered before connecting or disconnecting.","title":"Step 4: Finishing Up"},{"location":"matrix-voice/overview/","text":"MATRIX Voice The MATRIX Voice is a development board for building sound driven behaviors and interfaces. MATRIX Voice was built with a mission to give every maker, tinkerer, and developer around the world a complete, affordable, and user-friendly tool for simple to complex Internet of Things (IoT) voice app creation. Overview Device Setup How to get started with your MATRIX Voice MATRIX Voice ESP32 version ESP32 Instructions to setup your ESP32 module Resources View and download helpful information about the MATRIX Voice Troubleshooting Look at common debugging solutions and test the hardware on your MATRIX Voice Board Versions Both versions of these boards run the same on a Raspberry Pi, however, the MATRIX Voice ESP32 version has the option to run standalone by programming the ESP32 module.","title":"Overview"},{"location":"matrix-voice/overview/#matrix-voice","text":"The MATRIX Voice is a development board for building sound driven behaviors and interfaces. MATRIX Voice was built with a mission to give every maker, tinkerer, and developer around the world a complete, affordable, and user-friendly tool for simple to complex Internet of Things (IoT) voice app creation.","title":"MATRIX Voice"},{"location":"matrix-voice/overview/#overview","text":"","title":"Overview"},{"location":"matrix-voice/overview/#board-versions","text":"Both versions of these boards run the same on a Raspberry Pi, however, the MATRIX Voice ESP32 version has the option to run standalone by programming the ESP32 module.","title":"Board Versions"},{"location":"matrix-voice/troubleshooting/","text":"Community Please visit our community support forums at community.matrix.one Reinstall MATRIX Init Package and Reflash FPGA If you experience strange behavior, reinstall the MATRIX init package and reflash FPGA. Uninstall the matrixio-creator-init package. sudo apt-get --purge remove matrixio-creator-init Reboot your device. sudo reboot Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the matrixio-creator-init package. sudo apt-get install matrixio-creator-init Reboot your device. sudo reboot FPGA will be reflashed with stock firmware. Now you can flash the FPGA. Reset the FPGA. echo 26 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio26/direction echo 1 /sys/class/gpio/gpio26/value echo 0 /sys/class/gpio/gpio26/value echo 1 /sys/class/gpio/gpio26/value Flash the SPI Flash bootloader onto FPGA. xc3sprog -c matrix_voice blob/bscan_spi_s6lx9_ftg256.bit You should receive the following. XC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux Free software: If you contribute nothing, expect nothing! Feedback on success/failure/enhancement requests: http://sourceforge.net/mail/?group_id=170565 Check Sourceforge for updates: http://sourceforge.net/projects/xc3sprog/develop DNA is 0xf9d61a1ecbb64401 Flash the SPI Flash. xc3sprog -c matrix_voice -I blob/system_voice.bit You should receive the following. XC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux Free software: If you contribute nothing, expect nothing! Feedback on success/failure/enhancement requests: http://sourceforge.net/mail/?group_id=170565 Check Sourceforge for updates: http://sourceforge.net/projects/xc3sprog/develop JEDEC: c2 20 0x17 0xc2 Found Macronix MX25L Device, Device ID 0x2017 256 bytes/page, 262144 pages = 67108864 bytes total Verify: Success! Reset the FPGA. echo 26 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio26/direction echo 1 /sys/class/gpio/gpio26/value echo 0 /sys/class/gpio/gpio26/value echo 1 /sys/class/gpio/gpio26/value Power off your device. sudo poweroff Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi. Plug the power cable back into your Raspberry Pi. Reinstall MATRIX Kernel Modules If you experience strange behavior, reinstall the MATRIX kernel modules. Uninstall the matrixio-kernel-modules package. sudo apt-get --purge remove matrixio-kernel-modules Reboot your device. sudo reboot Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the matrixio-kernel-modules package. sudo apt-get install matrixio-kernel-modules Reboot your device. sudo reboot Check Raspberry Pi GPIO If you experience strange behavior, check the Raspberry Pi GPIO. sudo cat /sys/kernel/debug/gpio You should receive the following. gpiochip0: GPIOs 0-53, parent: platform/3f200000.gpio, pinctrl-bcm2835: gpio-18 ( |sysfs ) out hi gpio-24 ( |sysfs ) out hi gpio-25 ( |sysfs ) out hi gpio-26 ( |sysfs ) out hi If sysfs above is replaced with w1 , use raspi-config to disable the 1-Wire interface. sudo raspi-config Inside raspi-config, navigate to Interfacing Options 1-Wire NO . Hardware Tests These tests will check if your MATRIX Voice is functioning properly. We first need to install matrixio-creator-init, which handles the flashing of FPGA. Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the MATRIX init package. sudo apt-get install matrixio-creator-init Reboot your device. sudo reboot Matrix Init Script After the reboot, run the matrix init script manually. sudo /usr/share/matrixlabs/matrixio-devices/matrix-init.bash You should receive the following. *** MATRIX Voice has a updated firmware *** MATRIX Voice initial process has been launched FPGA Info This program checks the fpga info. sudo /usr/share/matrixlabs/matrixio-devices/fpga_info You should receive the following. INFO: [/dev/spidev0.0] was opened FPGA IDENTIFY = 6032bad2 FPGA VERSION = 1000a If you have the matrixio-kernel-modules installed, you should receive this instead. INFO: [/dev/matrixio_regmap] was opened FPGA IDENTIFY = 6032bad2 FPGA VERSION = 1000a FPGA Flash If you don\u2019t get the proper FPGA info you will need to run the FPGA flashing process. cd /usr/share/matrixlabs/matrixio-devices/ sudo ./fpga-program.bash You should receive the following. *** MATRIX Voice has a updated firmware If you get **** Could not program FPGA , please contact us . Test Other Components Install MATRIX HAL and test other components such as the microphone array using the MATRIX HAL examples .","title":"Troubleshooting"},{"location":"matrix-voice/troubleshooting/#community","text":"Please visit our community support forums at community.matrix.one","title":"Community"},{"location":"matrix-voice/troubleshooting/#reinstall-matrix-init-package-and-reflash-fpga","text":"If you experience strange behavior, reinstall the MATRIX init package and reflash FPGA. Uninstall the matrixio-creator-init package. sudo apt-get --purge remove matrixio-creator-init Reboot your device. sudo reboot Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the matrixio-creator-init package. sudo apt-get install matrixio-creator-init Reboot your device. sudo reboot FPGA will be reflashed with stock firmware. Now you can flash the FPGA. Reset the FPGA. echo 26 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio26/direction echo 1 /sys/class/gpio/gpio26/value echo 0 /sys/class/gpio/gpio26/value echo 1 /sys/class/gpio/gpio26/value Flash the SPI Flash bootloader onto FPGA. xc3sprog -c matrix_voice blob/bscan_spi_s6lx9_ftg256.bit You should receive the following. XC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux Free software: If you contribute nothing, expect nothing! Feedback on success/failure/enhancement requests: http://sourceforge.net/mail/?group_id=170565 Check Sourceforge for updates: http://sourceforge.net/projects/xc3sprog/develop DNA is 0xf9d61a1ecbb64401 Flash the SPI Flash. xc3sprog -c matrix_voice -I blob/system_voice.bit You should receive the following. XC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux Free software: If you contribute nothing, expect nothing! Feedback on success/failure/enhancement requests: http://sourceforge.net/mail/?group_id=170565 Check Sourceforge for updates: http://sourceforge.net/projects/xc3sprog/develop JEDEC: c2 20 0x17 0xc2 Found Macronix MX25L Device, Device ID 0x2017 256 bytes/page, 262144 pages = 67108864 bytes total Verify: Success! Reset the FPGA. echo 26 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio26/direction echo 1 /sys/class/gpio/gpio26/value echo 0 /sys/class/gpio/gpio26/value echo 1 /sys/class/gpio/gpio26/value Power off your device. sudo poweroff Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi. Plug the power cable back into your Raspberry Pi.","title":"Reinstall MATRIX Init Package and Reflash FPGA"},{"location":"matrix-voice/troubleshooting/#reinstall-matrix-kernel-modules","text":"If you experience strange behavior, reinstall the MATRIX kernel modules. Uninstall the matrixio-kernel-modules package. sudo apt-get --purge remove matrixio-kernel-modules Reboot your device. sudo reboot Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the matrixio-kernel-modules package. sudo apt-get install matrixio-kernel-modules Reboot your device. sudo reboot","title":"Reinstall MATRIX Kernel Modules"},{"location":"matrix-voice/troubleshooting/#check-raspberry-pi-gpio","text":"If you experience strange behavior, check the Raspberry Pi GPIO. sudo cat /sys/kernel/debug/gpio You should receive the following. gpiochip0: GPIOs 0-53, parent: platform/3f200000.gpio, pinctrl-bcm2835: gpio-18 ( |sysfs ) out hi gpio-24 ( |sysfs ) out hi gpio-25 ( |sysfs ) out hi gpio-26 ( |sysfs ) out hi If sysfs above is replaced with w1 , use raspi-config to disable the 1-Wire interface. sudo raspi-config Inside raspi-config, navigate to Interfacing Options 1-Wire NO .","title":"Check Raspberry Pi GPIO"},{"location":"matrix-voice/troubleshooting/#hardware-tests","text":"These tests will check if your MATRIX Voice is functioning properly. We first need to install matrixio-creator-init, which handles the flashing of FPGA. Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the MATRIX init package. sudo apt-get install matrixio-creator-init Reboot your device. sudo reboot","title":"Hardware Tests"},{"location":"matrix-voice/troubleshooting/#matrix-init-script","text":"After the reboot, run the matrix init script manually. sudo /usr/share/matrixlabs/matrixio-devices/matrix-init.bash You should receive the following. *** MATRIX Voice has a updated firmware *** MATRIX Voice initial process has been launched","title":"Matrix Init Script"},{"location":"matrix-voice/troubleshooting/#fpga-info","text":"This program checks the fpga info. sudo /usr/share/matrixlabs/matrixio-devices/fpga_info You should receive the following. INFO: [/dev/spidev0.0] was opened FPGA IDENTIFY = 6032bad2 FPGA VERSION = 1000a If you have the matrixio-kernel-modules installed, you should receive this instead. INFO: [/dev/matrixio_regmap] was opened FPGA IDENTIFY = 6032bad2 FPGA VERSION = 1000a","title":"FPGA Info"},{"location":"matrix-voice/troubleshooting/#fpga-flash","text":"If you don\u2019t get the proper FPGA info you will need to run the FPGA flashing process. cd /usr/share/matrixlabs/matrixio-devices/ sudo ./fpga-program.bash You should receive the following. *** MATRIX Voice has a updated firmware If you get **** Could not program FPGA , please contact us .","title":"FPGA Flash"},{"location":"matrix-voice/troubleshooting/#test-other-components","text":"Install MATRIX HAL and test other components such as the microphone array using the MATRIX HAL examples .","title":"Test Other Components"},{"location":"matrix-voice/resources/fpga/","text":"FPGA Flashing Guide \u26a0\ufe0fModifying FPGA source may have unintended consequences\u26a0\ufe0f Device Compatibility Overview The FPGA handles: GPIO output Connections between board components Microphone processing (not provided in source code) FPGA Source \u26a0\ufe0fFPGA source does not contain audio processing code\u26a0\ufe0f FPGA source code is located here . FPGA Flashing Below is a guide on how to flash a premade user-provided FPGA bitstream onto the Xilinx Spartan-6 FPGA for the MATRIX Voice. We first need to install a few prerequisites. Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the required packages. sudo apt-get install matrixio-creator-init Reboot your device. sudo reboot Backup the stock system_voice.bit file. sudo mv /usr/share/matrixlabs/matrixio-devices/blob/system_voice.bit /usr/share/matrixlabs/matrixio-devices/blob/system_voice_stock.bit Copy your built system_voice.bit FPGA bitstream file to the blob folder. sudo cp /path/to/your/file /usr/share/matrixlabs/matrixio-devices/blob/system_voice.bit Now you can flash the FPGA. Reset the FPGA. echo 26 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio26/direction echo 1 /sys/class/gpio/gpio26/value echo 0 /sys/class/gpio/gpio26/value echo 1 /sys/class/gpio/gpio26/value Flash the SPI Flash bootloader onto FPGA. xc3sprog -c matrix_voice blob/bscan_spi_s6lx9_ftg256.bit You should receive the following (may vary due to user-provided file). XC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux Free software: If you contribute nothing, expect nothing! Feedback on success/failure/enhancement requests: http://sourceforge.net/mail/?group_id=170565 Check Sourceforge for updates: http://sourceforge.net/projects/xc3sprog/develop DNA is 0xf9d61a1ecbb64401 Flash the SPI Flash. xc3sprog -c matrix_voice -I blob/system_voice.bit You should receive the following (may vary due to user-provided file). XC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux Free software: If you contribute nothing, expect nothing! Feedback on success/failure/enhancement requests: http://sourceforge.net/mail/?group_id=170565 Check Sourceforge for updates: http://sourceforge.net/projects/xc3sprog/develop JEDEC: c2 20 0x17 0xc2 Found Macronix MX25L Device, Device ID 0x2017 256 bytes/page, 262144 pages = 67108864 bytes total Verify: Success! Reset the FPGA. echo 26 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio26/direction echo 1 /sys/class/gpio/gpio26/value echo 0 /sys/class/gpio/gpio26/value echo 1 /sys/class/gpio/gpio26/value In order to maintain compatibility with the matrixio-creator-init package, you'll need to backup the original voice.version file, and create your own. cd /usr/share/matrixlabs/matrixio-devices/ sudo mv /usr/share/matrixlabs/matrixio-devices/voice.version /usr/share/matrixlabs/matrixio-devices/voice_stock.version (./fpga_info | grep FPGA) | sudo tee voice.version Updating the matrixio-creator-init package will cause the stock FPGA bitstream to be flashed upon next boot. You can stop sudo apt-get upgrade from automatically updating the matrixio-creator-init package with the following command. sudo apt-mark hold matrixio-creator-init Power off your device. sudo poweroff Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi. Plug the power cable back into your Raspberry Pi. Restore Original Firmware To restore the original firmware, restore the stock system_voice.bit file in the blob folder. sudo rm /usr/share/matrixlabs/matrixio-devices/blob/system_voice.bit sudo cp /usr/share/matrixlabs/matrixio-devices/blob/system_voice_stock.bit /usr/share/matrixlabs/matrixio-devices/blob/system_voice.bit Now you can flash the FPGA. Reset the FPGA. echo 26 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio26/direction echo 1 /sys/class/gpio/gpio26/value echo 0 /sys/class/gpio/gpio26/value echo 1 /sys/class/gpio/gpio26/value Flash the SPI Flash bootloader onto FPGA. xc3sprog -c matrix_voice blob/bscan_spi_s6lx9_ftg256.bit You should receive the following. XC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux Free software: If you contribute nothing, expect nothing! Feedback on success/failure/enhancement requests: http://sourceforge.net/mail/?group_id=170565 Check Sourceforge for updates: http://sourceforge.net/projects/xc3sprog/develop DNA is 0xf9d61a1ecbb64401 Flash the SPI Flash. xc3sprog -c matrix_voice -I blob/system_voice.bit You should receive the following. XC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux Free software: If you contribute nothing, expect nothing! Feedback on success/failure/enhancement requests: http://sourceforge.net/mail/?group_id=170565 Check Sourceforge for updates: http://sourceforge.net/projects/xc3sprog/develop JEDEC: c2 20 0x17 0xc2 Found Macronix MX25L Device, Device ID 0x2017 256 bytes/page, 262144 pages = 67108864 bytes total Verify: Success! Reset the FPGA. echo 26 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio26/direction echo 1 /sys/class/gpio/gpio26/value echo 0 /sys/class/gpio/gpio26/value echo 1 /sys/class/gpio/gpio26/value Restore the stock voice.version file. sudo rm /usr/share/matrixlabs/matrixio-devices/voice.version sudo cp /usr/share/matrixlabs/matrixio-devices/voice_stock.version /usr/share/matrixlabs/matrixio-devices/voice.version Allow sudo apt-get upgrade to update the matrixio-creator-init package. sudo apt-mark unhold matrixio-creator-init Power off your device. sudo poweroff Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi. Plug the power cable back into your Raspberry Pi.","title":"FPGA"},{"location":"matrix-voice/resources/fpga/#device-compatibility","text":"","title":"Device Compatibility"},{"location":"matrix-voice/resources/fpga/#overview","text":"The FPGA handles: GPIO output Connections between board components Microphone processing (not provided in source code)","title":"Overview"},{"location":"matrix-voice/resources/fpga/#fpga-source","text":"\u26a0\ufe0fFPGA source does not contain audio processing code\u26a0\ufe0f FPGA source code is located here .","title":"FPGA Source"},{"location":"matrix-voice/resources/fpga/#fpga-flashing","text":"Below is a guide on how to flash a premade user-provided FPGA bitstream onto the Xilinx Spartan-6 FPGA for the MATRIX Voice. We first need to install a few prerequisites. Add the MATRIX repository and key. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list Update your repository and packages. sudo apt-get update sudo apt-get upgrade Install the required packages. sudo apt-get install matrixio-creator-init Reboot your device. sudo reboot Backup the stock system_voice.bit file. sudo mv /usr/share/matrixlabs/matrixio-devices/blob/system_voice.bit /usr/share/matrixlabs/matrixio-devices/blob/system_voice_stock.bit Copy your built system_voice.bit FPGA bitstream file to the blob folder. sudo cp /path/to/your/file /usr/share/matrixlabs/matrixio-devices/blob/system_voice.bit Now you can flash the FPGA. Reset the FPGA. echo 26 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio26/direction echo 1 /sys/class/gpio/gpio26/value echo 0 /sys/class/gpio/gpio26/value echo 1 /sys/class/gpio/gpio26/value Flash the SPI Flash bootloader onto FPGA. xc3sprog -c matrix_voice blob/bscan_spi_s6lx9_ftg256.bit You should receive the following (may vary due to user-provided file). XC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux Free software: If you contribute nothing, expect nothing! Feedback on success/failure/enhancement requests: http://sourceforge.net/mail/?group_id=170565 Check Sourceforge for updates: http://sourceforge.net/projects/xc3sprog/develop DNA is 0xf9d61a1ecbb64401 Flash the SPI Flash. xc3sprog -c matrix_voice -I blob/system_voice.bit You should receive the following (may vary due to user-provided file). XC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux Free software: If you contribute nothing, expect nothing! Feedback on success/failure/enhancement requests: http://sourceforge.net/mail/?group_id=170565 Check Sourceforge for updates: http://sourceforge.net/projects/xc3sprog/develop JEDEC: c2 20 0x17 0xc2 Found Macronix MX25L Device, Device ID 0x2017 256 bytes/page, 262144 pages = 67108864 bytes total Verify: Success! Reset the FPGA. echo 26 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio26/direction echo 1 /sys/class/gpio/gpio26/value echo 0 /sys/class/gpio/gpio26/value echo 1 /sys/class/gpio/gpio26/value In order to maintain compatibility with the matrixio-creator-init package, you'll need to backup the original voice.version file, and create your own. cd /usr/share/matrixlabs/matrixio-devices/ sudo mv /usr/share/matrixlabs/matrixio-devices/voice.version /usr/share/matrixlabs/matrixio-devices/voice_stock.version (./fpga_info | grep FPGA) | sudo tee voice.version Updating the matrixio-creator-init package will cause the stock FPGA bitstream to be flashed upon next boot. You can stop sudo apt-get upgrade from automatically updating the matrixio-creator-init package with the following command. sudo apt-mark hold matrixio-creator-init Power off your device. sudo poweroff Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi. Plug the power cable back into your Raspberry Pi.","title":"FPGA Flashing"},{"location":"matrix-voice/resources/fpga/#restore-original-firmware","text":"To restore the original firmware, restore the stock system_voice.bit file in the blob folder. sudo rm /usr/share/matrixlabs/matrixio-devices/blob/system_voice.bit sudo cp /usr/share/matrixlabs/matrixio-devices/blob/system_voice_stock.bit /usr/share/matrixlabs/matrixio-devices/blob/system_voice.bit Now you can flash the FPGA. Reset the FPGA. echo 26 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio26/direction echo 1 /sys/class/gpio/gpio26/value echo 0 /sys/class/gpio/gpio26/value echo 1 /sys/class/gpio/gpio26/value Flash the SPI Flash bootloader onto FPGA. xc3sprog -c matrix_voice blob/bscan_spi_s6lx9_ftg256.bit You should receive the following. XC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux Free software: If you contribute nothing, expect nothing! Feedback on success/failure/enhancement requests: http://sourceforge.net/mail/?group_id=170565 Check Sourceforge for updates: http://sourceforge.net/projects/xc3sprog/develop DNA is 0xf9d61a1ecbb64401 Flash the SPI Flash. xc3sprog -c matrix_voice -I blob/system_voice.bit You should receive the following. XC3SPROG (c) 2004-2011 xc3sprog project $Rev: 774 $ OS: Linux Free software: If you contribute nothing, expect nothing! Feedback on success/failure/enhancement requests: http://sourceforge.net/mail/?group_id=170565 Check Sourceforge for updates: http://sourceforge.net/projects/xc3sprog/develop JEDEC: c2 20 0x17 0xc2 Found Macronix MX25L Device, Device ID 0x2017 256 bytes/page, 262144 pages = 67108864 bytes total Verify: Success! Reset the FPGA. echo 26 /sys/class/gpio/export 2 /dev/null echo out /sys/class/gpio/gpio26/direction echo 1 /sys/class/gpio/gpio26/value echo 0 /sys/class/gpio/gpio26/value echo 1 /sys/class/gpio/gpio26/value Restore the stock voice.version file. sudo rm /usr/share/matrixlabs/matrixio-devices/voice.version sudo cp /usr/share/matrixlabs/matrixio-devices/voice_stock.version /usr/share/matrixlabs/matrixio-devices/voice.version Allow sudo apt-get upgrade to update the matrixio-creator-init package. sudo apt-mark unhold matrixio-creator-init Power off your device. sudo poweroff Wait until the green led on your Raspberry Pi blinks 10 times, then unplug the power cable from your Raspberry Pi. Plug the power cable back into your Raspberry Pi.","title":"Restore Original Firmware"},{"location":"matrix-voice/resources/microphone/","text":"Microphone Array on MATRIX Voice Usage Driver installation Follow the instructions below for allowing your MATRIX Voice to register as a microphone for your Raspberry Pi. curl https://apt.matrix.one/doc/apt-key.gpg | sudo apt-key add - echo deb https://apt.matrix.one/raspbian $(lsb_release -sc) main | sudo tee /etc/apt/sources.list.d/matrixlabs.list sudo apt-get update sudo apt-get upgrade A reboot will be required after the MATRIX packages above are installed. sudo reboot The next commands will install the MATRIX kernel modules, overriding the stock Raspbian kernel. sudo apt install matrixio-kernel-modules A second reboot will be required. sudo reboot Check If Everything Works Your Raspberry Pi should now treat your MATRIX Voice as a regular microphone. You can test this by using the following commands to record and play a 5 second long audio file on your Raspberry Pi. Be sure to have something connected to the Raspberry Pi's audio output. arecord recording.wav -f S16_LE -r 16000 -d 5 aplay recording.wav ALSA Configuration The microphones can be grabbed using ALSA. Multiple libraries that support ALSA use these configurations to read microphone data with ALSA. Device name - hw:2,0 Rates(Hz) - 8000 12000 16000 22050 24000 32000 44100 48000 96000 Channels for each microphone - 1 2 3 4 5 6 7 8 Audio specs Sample Rate: 8 to 96 kHz Bit Depth: Signed 16 bit Position [x,y] of each mic in the array (mm) Mic X Y M1 00.00 0.00 M2 -38.13 3.58 M3 -20.98 32.04 M4 11.97 36.38 M5 35.91 13.32 M6 32.81 -19.77 M7 5.00 -37.97 M8 -26.57 -27.58 Connection to the FPGA Mic FPGA pin PDM_Data M1 E6 pdm_data 0 M2 B8 pdm_data 1 M3 A8 pdm_data 2 M4 C7 pdm_data 3 M5 A7 pdm_data 4 M6 A6 pdm_data 5 M7 B6 pdm_data 6 M8 A5 pdm_data 7 CLK B5 pdm_clk","title":"Microphones"},{"location":"matrix-voice/resources/microphone/#microphone-array-on-matrix-voice","text":"","title":"Microphone Array on MATRIX Voice"},{"location":"matrix-voice/resources/microphone/#usage","text":"","title":"Usage"},{"location":"matrix-voice/resources/microphone/#audio-specs","text":"Sample Rate: 8 to 96 kHz Bit Depth: Signed 16 bit","title":"Audio specs"},{"location":"matrix-voice/resources/overview/","text":"Resources Pinout Lists and labels of the MATRIX Voice's Pinouts Microphones Microphone drivers, sample rate, and board position Reference Models Download or view the Matrix Voice's 3D models System Architecture View a technical diagram of the MATRIX Voice architecture Technical Datasheets PDFs of MATRIX Creator Components FPGA FPGA source and flashing guide","title":"Overview"},{"location":"matrix-voice/resources/overview/#resources","text":"","title":"Resources"},{"location":"matrix-voice/resources/pinout/","text":"Expansion GPIO Raspberry Pi GPIO GPIO Locations","title":"Pinout"},{"location":"matrix-voice/resources/pinout/#expansion-gpio","text":"","title":"Expansion GPIO"},{"location":"matrix-voice/resources/pinout/#raspberry-pi-gpio","text":"","title":"Raspberry Pi GPIO"},{"location":"matrix-voice/resources/pinout/#gpio-locations","text":"","title":"GPIO Locations"},{"location":"matrix-voice/resources/reference-models/","text":"Board Model Top View Bottom View Model Download Access to 3D models here . Also, you can take a look online here .","title":"Reference Models"},{"location":"matrix-voice/resources/reference-models/#board-model","text":"","title":"Board Model"},{"location":"matrix-voice/resources/system-architecture/","text":"System Architecture","title":"System Architecture"},{"location":"matrix-voice/resources/system-architecture/#system-architecture","text":"","title":"System Architecture"},{"location":"matrix-voice/resources/technical-datasheets/","text":"Datasheets: Xilinx Spartan 6 FPGA - XC6SLX9-2FTG256C 8 MEMS audio sensor digital microphones - MP34DB02 Serial Flash 64MBIT - MX25L6406E DDR2 SDRAM 512MBIT - MT47H32M16 3W Stereo Class-D Audio Amplifier and Class-AB Headphone Driver - PAM8019 RGBW LED - SK6812RGBW ESP32-WROOM","title":"Technical Datasheets"},{"location":"matrix-voice/resources/technical-datasheets/#datasheets","text":"Xilinx Spartan 6 FPGA - XC6SLX9-2FTG256C 8 MEMS audio sensor digital microphones - MP34DB02 Serial Flash 64MBIT - MX25L6406E DDR2 SDRAM 512MBIT - MT47H32M16 3W Stereo Class-D Audio Amplifier and Class-AB Headphone Driver - PAM8019 RGBW LED - SK6812RGBW ESP32-WROOM","title":"Datasheets:"}]}